<!DOCTYPE html>
<html lang="en" ng-app="tevApp">
<head>
    <meta charset="UTF-8">
    <title>TEV</title>
</head>
<style>
    body {
        padding-top: 75px; /* Required padding for .navbar-fixed-top. Remove if using .navbar-static-top. Change if height of navigation changes. */
    }

    /* bootstrap hack: fix content width inside hidden tabs */
    .tab-content > .tab-pane:not(.active),
    .pill-content > .pill-pane:not(.active) {
        display: block;
        height: 0;
        overflow-y: hidden;
    }

    .title-text {
        font-family: Arial, Helvetica, sans-serif;
        font-size: large;
        text-decoration: underline;
    }

    tr [colspan="2"] {
        text-align: center;
    }

    /* bootstrap hack end */

    .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .purity-line-ticks {
        font-size: 10px;
    }

    .node circle {
        stroke-width: 1.5px;
    }

    .node_text {
        font: 10px sans-serif;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 1.5px;
    }

    .info_rects, .median_line:hover {
        cursor: pointer;
    }

    div.tooltip {
        position: absolute;
        text-align: center;
        padding: 2px;
        font: 12px sans-serif;
        background: #222;
        border: 2px;
        border-color: #222222;
        border-radius: 8px;
    }

    /* Hide arrows in number inputs */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        margin: 0;
    }

    /* When mini fishplot is being dragged (mousedown -> mousemove), prevent any other mouse operations */
    .noselect {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .modal-header-inverse {
        background: #222222;
        color: #ffffff;
    }

    .panel-default > .panel-heading-custom {
        background: #222222;
        color: #ffffff;
    }

</style>

<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.js"></script>
<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css"
      integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r"
      crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://use.fontawesome.com/6138a840c3.js"></script>

<script>
    //Function to calculate CCF based on ploidy and purity specified
    function find_CCFs(independent_evos, counter, nested_data, purity, num_of_evos, cells_per_evo_array, timepoints,
                       options, timepoint_index, is_child, pre_determined_total_chrs){
        //need to update to keep track of how many times we need to recursively call this function
        var max_cells_of_this_evo = purity; //- (num_of_evos-1);

        if(is_child == true && independent_evos.length == 1){
                calculate_child_CCF(independent_evos, nested_data, purity, timepoints, options,
                        timepoint_index);
        }

        if((counter == num_of_evos) && (num_of_evos == 1)){
            return;
        }

        else {

            //The following lines of this function are for generating all possible combinations of cell counts per
            //independent clonal expansion based on the purity (or percentage of cells assigned to parent)
            //initialize cells_per_evo_array
            if ((counter == num_of_evos) && (counter > 1)) {
                counter = counter - 1;
                for (var i = 0; i < max_cells_of_this_evo + 1; i++) {
                    cells_per_evo_array.push(i);
                    find_CCFs(independent_evos, counter, nested_data, purity, num_of_evos, cells_per_evo_array, timepoints,
                            options, timepoint_index, is_child, pre_determined_total_chrs);
                    cells_per_evo_array = [];
                }
            }

            //if this is not the last independent evolution, continue with the process
            //generate additional combinations if the below is true
            if ((counter > 1) && (counter < num_of_evos)) {
                counter = counter - 1;
                for (var i = 0; i < max_cells_of_this_evo + 1; i++) {
                    var cells_array = cells_per_evo_array.slice();
                    cells_array.push(i);
                    var sum = cells_array.reduce(function (a, b) {
                        return a + b;
                    }, 0);
                    //if we've already reached our limit, break out of the loop
                    if (sum > purity) {
                        break;
                    }
                    else {
                        find_CCFs(independent_evos, counter, nested_data, purity, num_of_evos, cells_array, timepoints,
                                options, timepoint_index, is_child, pre_determined_total_chrs);
                    }
                }
            }
            //else if we are on the last one, start checking the combinations
            if ((counter == 1) && (counter != num_of_evos)) {
                if (cells_per_evo_array.length != 0) {
                    for (var i = 0; i < max_cells_of_this_evo + 1; i++) {
                        var cells_array = cells_per_evo_array.slice();
                        cells_array.push(i);
                        sum = cells_array.reduce(function (a, b) {
                            return a + b;
                        }, 0);
                        if (sum > purity) {
                            break;
                        }
                        //if we have a good combination, see if it is possible to calculate the cancer cell fraction
                        if ((sum <= purity) && (cells_array.length == num_of_evos)) {
                            if (nested_data[independent_evos[0]].parent_index_of_this == 'plot' && sum != purity) {
                                continue;
                            }
                            else {
                                //function to see if there is a solution using the given ploidys
                                calculate_CCF(cells_array, independent_evos, nested_data, purity, timepoints, options, timepoint_index);
                            }
                        }
                        else {
                            continue;
                        }
                    }
                }
            }
        }
    }

    function calculate_child_CCF(independent_evos, nested_data, parent_cell_count, timepoints,
                                 options, timepoint_index) {
        var max_cells_of_this_evo = parent_cell_count;
        for (var i = 0; i < max_cells_of_this_evo + 1; i++) {
            var cells_array = [];
            cells_array.push(i);
            var sum = i;
            if ((sum <= parent_cell_count)){
                //function to see if there is a solution using the given ploidys
                calculate_CCF(cells_array, independent_evos, nested_data, parent_cell_count, timepoints, options, timepoint_index);
            }
        }

    }

    //Function to see if there is a solution for CCF given the independent clonal expansions and cell ploidys
    //cells_per_evo_array contains proposed cell counts for all independent clonal expansions except the last listed one
    function calculate_CCF(cells_per_evo_array, independent_evos, nested_data, purity, timepoints, options, timepoint_index){
        var normal_cells =  100-purity;
        //number of chromosomes coming from normal (impure) cells
        var num_chrs_normal_cells = normal_cells*2;

        //calculate total number of chromosomes
        var total_chromosomes = calculate_chromosome_total(cells_per_evo_array, num_chrs_normal_cells, nested_data, independent_evos);

        //and the number of chromosomes in each independent clonal expansion
        var chromosome_counts = {};

        //get the cells counts from each independent clonal expansion by adding the last cell count to array
        var all_evo_cell_counts = cells_per_evo_array;

        //Initialize the chromosome count coming from normal cells
        chromosome_counts.normal = num_chrs_normal_cells;

            chromosome_counts[timepoints.toString()] = {};
            for (var i = 0; i < independent_evos.length; i++) {
                //calculate number of chromsomes from each specific independent evolution
                //by multiplying number of cells for that independent evolution by the proposed ploidy of those cells
                var chrs_for_this_evo = all_evo_cell_counts[i] * nested_data[independent_evos[i]].ploidy;
                chromosome_counts[timepoints.toString()][nested_data[independent_evos[i]].key] = chrs_for_this_evo;
            }

            var chromosomes_affected_of_each = [];
            var will_work = true;

            for (var i = 0; i < independent_evos.length; i++) {
                //variant allele frequency
                var vaf = nested_data[independent_evos[i]].values[timepoint_index].alt_count;
                var chromosomes_needed = total_chromosomes * (vaf/100);
                chromosomes_needed = Math.round(chromosomes_needed);

                //if the number of cells we have for this independent evolution is greater than the chromosomes needed for
                //the VAF at this timepoint, then it wont work. Need at least 1 chrs affected per cell
                if ((chromosomes_needed < all_evo_cell_counts[i]) && (nested_data[independent_evos[i]].values[timepoint_index].alt_count != 0)) {
                    will_work = false;
                }

                if(all_evo_cell_counts[i] > 0 && chromosomes_needed == 0){
                    will_work = false;
                }

                if (chromosomes_needed > ((chromosome_counts[timepoints.toString()][nested_data[independent_evos[i]].key]) + nested_data[independent_evos[i]].ploidy-1)) {
                    will_work = false;
                }

                //else, try to find the closest number of chromosomes affected per independent evolution
                else {
                    var proportions = generate_portions(nested_data[independent_evos[i]].ploidy);
                    var proportion_affected = chromosomes_needed / chromosome_counts[timepoints.toString()][nested_data[independent_evos[i]].key];
                    var closest_proportion = find_closest_proportion(proportions, proportion_affected);
                    var num_of_chromosomes_affected = proportions.indexOf(closest_proportion) + 1;
                    chromosomes_affected_of_each.push(num_of_chromosomes_affected);
                }
            }

            if (will_work == true) {
                var CCF = {};
                for (var i = 0; i < independent_evos.length; i++) {
                    var allele = nested_data[independent_evos[i]].key;
                    CCF[allele] = [cells_per_evo_array[i]];
                    CCF[allele+'_chrs'] = chromosomes_affected_of_each[i];
                }
                options[timepoints.toString()].push(CCF);
            }

        return;
    }

    //function to generate possible proportions of chromosomes affected in cell based on ploidy
    function generate_portions(ploidy){
        var proportions_array = [];
        var increment = 1/ploidy;
        for(var i = 0; i < ploidy; i++){
            var proportion = (i+1)*increment;
            proportion = parseFloat(proportion.toFixed(2));
            proportions_array.push(proportion);
        }
        return proportions_array;
    }

    //calculate the total number of chromosomes based on the purity, ploidy, and cells distribution
    function calculate_chromosome_total(cells_per_evo_array, num_chrs_normal_cells, nested_data, independent_evos) {
        var total_chromosomes = num_chrs_normal_cells;
        for (var i = 0; i < cells_per_evo_array.length; i++) {
            var chrs_for_this_evo = cells_per_evo_array[i] * nested_data[independent_evos[i]].ploidy;
            total_chromosomes = total_chromosomes + chrs_for_this_evo;
        }
        return total_chromosomes;
    }

    //find the closest proportion of chromosomes affected by variation
    function find_closest_proportion(proportions, proportion_affected){
        var closest = proportions[0];
        for(var i = 1; i < proportions.length; i++){
            if(Math.abs(proportion_affected-proportions[i]) < Math.abs(proportion_affected-closest)){
                closest = proportions[i];
            }
        }
        return closest;
    }

    //Find unique values for oridinal scale
    function uniqueAxisLabels(data, key) {
        var unique = {};
        var distinct = [];
        data.forEach(function (x) {
            if (!unique[x[key]]) {
                distinct.push(x[key]);
                unique[x[key]] = true;
            }
        });

        return distinct;
    }


    //Find difference between two arrays
    Array.prototype.diff = function(a) {
    return this.filter(function(i) {return a.indexOf(i) < 0;});
    };

    //Sort each allele in nested data by timepoint
    function sort_nested_alleles(nested_data){
        for(var i = 0; i < nested_data.length; i++){
            nested_data[i].values = nested_data[i].values.sort(function(a, b){
               return a.Sample_Barcode - b.Sample_Barcode;
            });
        }
        return nested_data;
    }

    //functions for adjusting beginning and end of fishplots
    function pinch_data(data) {
        for (var i = 0; i < data.length; i++) {
            var current_allele = data[i];
            for (var j = 0; j < current_allele.values.length; j++) {
                //Initialize all pinches to false
                //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                current_allele.values[j].pinch = false;
            }
            current_allele.values = find_origin(current_allele);
        }
    }

    function remove_unnecessary_values(data) {
        for (var i = 0; i < data.length; i++) {
            var current_allele = data[i];
            current_allele.values.reverse();
            for (var j = 0; j < current_allele.values.length; j++) {
                if (current_allele.values[j].alt_count != 0) {
                    if (j != 0) {
                        current_allele.values.splice(0, j - 1);
                    }
                    current_allele.values.reverse();
                    break;
                }
            }
        }
    }


    //Order fish plot data by first timepoint, and then by alternative allele freq
    //Directives used in: figure5Plot
    function order_by_rank(data, rank_data){
        var reordered_data = [];
        for(var i = 0; i < data.length; i++){
            var current_allele = data.findIndex(x => x.key == rank_data[i].allele);
            current_allele = data[current_allele];
            reordered_data[i] = current_allele;
        }
        return reordered_data;
    }


    //Dirty way of adding origin (tail fin of fish plot)
    //Important to unshift, because the order of the x-values matters when using d3.line.svg()!
    function add_origin(nestedData, Sample_Barcode) {
        for (var i = 0; i < nestedData.length; i++) {
            var allele_cluster = nestedData[i].values[0].cluster;
            var parent_allele = nestedData[i].values[0].parent_allele;
            nestedData[i].values.unshift({
                Sample_Barcode: Sample_Barcode,
                alt_count: 0,
                conserved_alt_count: 0,
                allele: nestedData[i].key,
                cluster: allele_cluster,
                parent_allele: parent_allele
            });
        }
        return nestedData;
    }

    //Is one < 0 or > 100?
    function parent_border_collision_detection(parent, start_point, min, max, measure) {
        for (var j = 0; j < parent.values.length; j++) {
            if ((start_point - parent.values[j][measure] / 2) < min) {
                parent.values[j].bottom = min;
                parent.values[j].top = parent.values[j][measure];
            }
            else if ((start_point + parent.values[j][measure] / 2) > max) {
                parent.values[j].top = max;
                parent.values[j].bottom = max - parent.values[j][measure];
            }
            else {
                parent.values[j].top = (start_point + parent.values[j][measure] / 2);
                parent.values[j].bottom = (start_point - parent.values[j][measure] / 2);
            }
        }
        return parent;
    }


    //pass in nestedData, and the index representing the timepoint
    function collision_detection(data, children, timepoint_index, min, max, measure) {
        var range = max - min;
        var total_alt_counts = 0;
        for (var i = 0; i < children.length; i++) {
            //loop through children, and see where we can move the tops and bottoms
            total_alt_counts = data[children[i]].values[timepoint_index][measure] + total_alt_counts;
        }
        var space = (range - total_alt_counts);
        space = space / (children.length + 1);

        var new_bottom = min + space;

        for (var i = 0; i < children.length; i++) {
            data[children[i]].values[timepoint_index].bottom = new_bottom;
            data[children[i]].values[timepoint_index].top = new_bottom + data[children[i]].values[timepoint_index][measure];
            data[children[i]].values[timepoint_index].pinch_point = (data[children[i]].values[timepoint_index].top
                    + data[children[i]].values[timepoint_index].bottom) / 2;
            new_bottom = data[children[i]].values[timepoint_index].top + space;
        }
        return data;
    }


    //Find if there are any conflicts with the adjusted borders for the independent evolutions
    //And adjust the borders if there are any conflicts
    function adjust_independent_evolution_positions(nestedData, plot_background, num_of_timepoints, measure, max_vaf) {
        for (var i = 0; i < num_of_timepoints + 1; i++) {
            for (var j = 1; j < plot_background.children.length; j++) {
                var last_top = nestedData[plot_background.children[j - 1]].values[i].top;
                var current_bottom = nestedData[plot_background.children[j]].values[i].bottom;
                if (current_bottom < last_top) {
                    nestedData = collision_detection(nestedData, plot_background.children, i, 0, max_vaf, measure);
                    break;
                }
            }
        }
    }


    //Adjust children top and bottom based on parents
    function adjust_children_positioning(nestedData, num_of_timepoints, measure) {
        for (var i = 0; i < nestedData.length; i++) {
            var parent_index = nestedData[i].parent_index_of_this;
            //Added || != 'none' to satisfy fishplot editor (Had to add separate if statement for some reason??)
            //All fishplots that havent been placed down yet have a parent_index of 'none'
            //This is so I can do the collision prevention for the children that are already plotted
            if (parent_index != "plot") {
                if (parent_index != "none") {
                    var parent = nestedData[parent_index];
                    var children = parent.children;
                    var start_point = parent.start_point;
                    //Potentially include an && the children has not already been checked
                    //If parent has 2+ children, then the loop below will have taken care of those children already
                    if (children.length != 0) {
                        for (var j = 0; j < children.length; j++) {
                            var child = nestedData[children[j]];
                            for (var k = 0; k < child.values.length; k++) {
                                var start_point_space = parent.values[k][measure] / children.length;
                                var start_point_base = start_point_space / 2;
                                child.start_point = start_point_base + (start_point_space * j) + parent.values[k].bottom;
                                child.values[k].start_point = child.start_point;
                                if ((child.start_point - child.values[k][measure] / 2) < parent.values[k].bottom) {
                                    child.values[k].bottom = parent.values[k].bottom;
                                    child.values[k].top = child.values[k].bottom + child.values[k][measure];
                                }
                                else if (( child.start_point + child.values[k][measure] / 2) > parent.values[k].top) {
                                    child.values[k].top = parent.values[k].top;
                                    child.values[k].bottom = child.values[k].top - child.values[k][measure];
                                }
                                else {
                                    child.values[k].top = (child.start_point + child.values[k][measure] / 2);
                                    child.values[k].bottom = (child.start_point - child.values[k][measure] / 2);
                                }
                            }
                            child.start_point = child.values[0].bottom;
                        }
                        for (var j = 0; j < num_of_timepoints + 1; j++) {
                            nestedData = collision_detection(nestedData, children, j, parent.values[j].bottom, parent.values[j].top, measure);
                        }
                    }
                }
            }
        }
        return nestedData;
    }


    //Function to find the actual origin of the fishplots
    //Directives used in: figure5Plot
    function find_origin(current_allele){
        var allele_data = current_allele.values;
        var zeroes = [];
        //Find out if "origin" is the only timepoint that has an alternative allele frequency of zero
        for(var i = 0; i < allele_data.length; i++){
            if(allele_data[i].alt_count == 0){
                zeroes.push(i);
            }
            else {
                break;
            }
        }
        //If "origin" is not the actuall origin of the tumor
        //Trim the data until one timepoint before the actual origin
        if(zeroes.length > 1){
                allele_data.splice(0, zeroes.length - 1);
            }
        return allele_data;
    }

    //Reformat the data based on the cutoff point of the slider in the elbow dendrogram (Figure 3)
    //Directives used in: figure3Plot
    function cut_data(max_path_y, alleleified_data, nodes, timepoints) {

        var new_data = [];
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].y <= max_path_y) {
                new_data.push(nodes[i]);
            }
        }

        var upper_level_data = [];
        var used_nodes = [];
        for (var i = 0; i < new_data.length; i++) {
            var allele_level_data = [];
            var current_data = new_data[i];
            if (current_data.name != " " && used_nodes.indexOf(current_data.id) == -1) {
                used_nodes.push(current_data.id);
                allele_level_data.push(current_data.name);
                upper_level_data.push(allele_level_data);
                nodes[nodes.indexOf(current_data)].cluster = upper_level_data.length;
                nodes[nodes.indexOf(current_data)].parent_allele = current_data.name;
            }
            else if (current_data.name == " " && used_nodes.indexOf(current_data.id) == -1) {
                var cluster = upper_level_data.length + 1;
                var parent_allele = find_parent_allele(alleleified_data, allele_level_data);
                get_all_children(current_data, used_nodes, allele_level_data, nodes, cluster, parent_allele);
                upper_level_data.push(allele_level_data);
            }
        }

        var updated_linked_alleleified_data = convert_to_allelified(alleleified_data, upper_level_data, timepoints);
        var new_alleleified_data = update_alleleified_data(alleleified_data, upper_level_data);
        var parents = alleleified_parent_alleles(new_alleleified_data);

        return [updated_linked_alleleified_data, new_alleleified_data, upper_level_data, parents];
    }

    //for figure3 node color assignment... gets array of parent alleles
    function alleleified_parent_alleles(alleleified_data){
        var nested_data = d3.nest().key(function(d){
            return d.parent_allele;
        }).entries(alleleified_data);

        var parents = [];
        for(var i = 0; i < nested_data.length; i++){
            parents.push(nested_data[i].key);
        }
        return parents;
    }

    //for figure 3, cut_data function
    function find_parent_allele(alleleified_data, allele_level_data) {
        var nested_data = d3.nest().key(function (d) {
                    return d.allele;
                })
                .entries(alleleified_data);
        var parent_allele = '';
        var max_avg = 0;

        for(var i = 0; i < nested_data.length; i++) {
            var current_allele = nested_data[i];
            if (allele_level_data.indexOf(current_allele.key) == -1) {
                continue;
            }
            else {
                var sum = 0;
                for (var j = 0; j < current_allele.values.length; j++) {
                    sum = sum + current_allele.values[j].alt_count;
                }
                if (sum > max_avg) {
                    max_avg = sum;
                    parent_allele = current_allele.key;
                }
            }
        }
        return parent_allele;
    }

    function find_largest_allele(alleleified_data, allele_list, timepoints){
        var max_vaf = 0;
        var alleles_with_max_vaf = [];
        for(var i = 0; i < timepoints.length; i++){
            var timepoint = timepoints[i];
            for(var j = 0; j < allele_list.length; j++){
                for(var k = 0; k < alleleified_data.length; k++){
                    if(alleleified_data[k].allele == allele_list[j] && alleleified_data[k].Sample_Barcode == timepoint){
                        if(alleleified_data[k].alt_count == max_vaf){
                            alleles_with_max_vaf.push(alleleified_data[k].allele);
                        }
                        if(alleleified_data[k].alt_count > max_vaf){
                            max_vaf = alleleified_data[k].alt_count;
                            alleles_with_max_vaf = [];
                            alleles_with_max_vaf.push(alleleified_data[k].allele);
                        }
                        break;
                    }
                    else{
                        continue;
                    }
                }
            }
            //if there is more than one allele with the maximum VAF, compare those alleles VAF at the next timepoint
            if(alleles_with_max_vaf.length > 1){
                max_vaf = 0;
                allele_list = JSON.parse(JSON.stringify(alleles_with_max_vaf));
                alleles_with_max_vaf = [];
            }
            //if there is only one allele with the largest VAF, return the allele name
            if(alleles_with_max_vaf.length == 1){
                return alleles_with_max_vaf[0];
            }
        }
        //if > 1 have same VAF at every timepoint, it doesnt matter what one we pick
        return alleles_with_max_vaf[0];
    }

    //Convert newly cut data into linked alleleified data, so it is readable by fishplot & fishbone
    //Directives used in: figure3Plot
    function convert_to_allelified(alleleified_data, upper_level_data, timepoint_data) {
        var new_linked_alleleified_data = [];
        var allele;
        var timepoints = [];
        for(var i = 0; i < timepoint_data.length; i++){
            timepoints.push(timepoint_data[i].timepoint);
        }

        for (var i = 0; i < upper_level_data.length; i++) {
            var allele_list = upper_level_data[i];
            var parent_allele = find_parent_allele(alleleified_data, allele_list);
            if (allele_list.length > 1) {
                var new_allele_name = allele_list.join("\n");
            }
            else {
                new_allele_name = allele_list[0];
            }
            for (var j = 0; j < alleleified_data.length; j++) {
                //Now generate data grouping the alleles for the fishbone and fishplot
                if (alleleified_data[j].allele == parent_allele) {
                    allele = JSON.parse(JSON.stringify(alleleified_data[j]));
                    allele.allele = new_allele_name;
                    allele.parent_allele = parent_allele;
                    new_linked_alleleified_data.push(allele);
                }
            }
        }
        return new_linked_alleleified_data;
    }

    //Update the clusters of the alleleified data for the line plot and box plot
    //Directives used in: figure3Plot
    function update_alleleified_data(alleleified_data, upper_level_data) {
        for (var i = 0; i < upper_level_data.length; i++) {
            var allele_list = upper_level_data[i];
            var parent_allele = find_parent_allele(alleleified_data, allele_list);
            for (var j = 0; j < alleleified_data.length; j++) {
                for (var k = 0; k < allele_list.length; k++) {
                    if (alleleified_data[j].allele == allele_list[k]) {
                        alleleified_data[j].cluster = i + 1;
                        alleleified_data[j].parent_allele = parent_allele;
                    }
                }
            }
        }
        return alleleified_data;
    }

    //If the cutoff point of the slider is above a node that isn't directly associated with an allele
    //Find all of the alleles (children) under that node
    //Directives used in: figure3Plot
    function get_all_children(current_data, used_nodes, allele_level_data, nodes, cluster, parent_allele) {
        if (current_data.children != undefined) {
            for (var i = 0; i < current_data.children.length; i++) {
                if (current_data.children[i].name == " ") {
                    used_nodes.push(current_data.children[i].id);
                    get_all_children(current_data.children[i], used_nodes, allele_level_data, nodes, cluster, parent_allele);
                }
                else {
                    if (used_nodes.indexOf(current_data.children[i].id) == -1) {
                        nodes[nodes.indexOf(current_data.children[i])].cluster = cluster;
                        nodes[nodes.indexOf(current_data.children[i])].parent_allele = parent_allele;
                        used_nodes.push(current_data.children[i].id);
                        allele_level_data.push(current_data.children[i].name);
                    }
                }
            }
        }
    }

    //Function to correctly format data passed from fishplot (figure5Plot) to fishbone (figure4Plot) for d3 dendrogram
    //Directives used in: figure4Plot
    function add_children(child, parent, data) {
        var childData = {name: child.key, children: [], cluster: child.values[0].cluster,
            parent_allele: child.values[0].parent_allele};
        parent.children.push(childData);

        for (var i = 0; i < child.children.length; i++) {
            var newChild = data[child.children[i]];
            add_children(newChild, childData, data);
        }
    }

    //get purity at each timepoint for fishplot editor
    //only works when parent is plot_background
    function get_purity_dict(tick_labels) {
        var purity_dict = {};
        for (var i = 0; i < tick_labels.length; i++) {

            var purity_value = parseInt(d3.select('#day' + tick_labels[i].toString() + '_input').node().value);
            if (purity_value > 100) {
                purity_value = 100;
            }
            if (purity_value < 0) {
                purity_value = 0;
            }
            purity_dict[tick_labels[i].toString()] = purity_value;
        }
        return purity_dict;
    }

    function can_plot_CCF(canvas_nested_data, fishplot_svgs){
        var can_plot = true;
        for(var i = 0; i < fishplot_svgs.length; i++){
            var current_allele = canvas_nested_data[fishplot_svgs[i]];
            for(var j = 0; j < current_allele.values.length; j++){
                if(current_allele.values[j].ccf == undefined){
                    can_plot = false;
                    break;
                }
            }
            if(can_plot == false){
                break;
            }
        }
        return can_plot;
    }

    function get_pre_determined_total_chrs_count(nested_data, plot_background, tick_labels) {
        var total_chrs = {};
        for (var i = 0; i < tick_labels.length; i++) {
            var purity_value = parseInt(d3.select('#day' + tick_labels[i].toString() + '_input').node().value);
            total_chrs[tick_labels[i].toString()] = [];
            //chrs from normal cells at timepoint
            total_chrs[tick_labels[i].toString()].push((100 - purity_value) * 2);
        }

        var independent_evos = plot_background.children;
        for (var i = 0; i < independent_evos.length; i++) {
            var current_allele = nested_data[independent_evos[i]];
            for (var j = 0; j < tick_labels.length; j++) {
                total_chrs[tick_labels[j].toString()].push(
                        current_allele.values[j + 1].ccf * current_allele.ploidy
                );
            }
        }
        return total_chrs;
    }

    //function to plot CCF relative to cancer cells, not to total cells in sample
    function relative_to_cancer_cells(nested_data, fishplot_svgs, purity_dict, timepoints){
        for(var i = 0; i < fishplot_svgs.length; i++){
            var allele_data = nested_data[fishplot_svgs[i]].values;
            allele_data[0].only_cancer_ccf = 0;
            for (var j = 0; j < timepoints.length; j++) {
                var total_cc_cells = purity_dict[timepoints[j].toString()];
                if (allele_data[j + 1].ccf == undefined) {
                    return 0;
                }
                allele_data[j + 1].only_cancer_ccf = parseInt((allele_data[j + 1].ccf / total_cc_cells) * 100);
            }
        }
    }

    function load_CCF_options(CCF_options, sample_timepoints) {
        for (var i = 0; i < sample_timepoints.length; i++) {
            CCF_options[sample_timepoints[i].toString()] = [];
        }
    }

    function associated_allele_colors(canvas_nested_data) {
        var allele_dict = {};
        for (var i = 0; i < canvas_nested_data.length; i++) {
            allele_dict[canvas_nested_data[i].key] = canvas_nested_data[i].color;
        }
        return allele_dict;
    }


    function is_valid(CCF_options, timepoints) {
        var valid = true;
        for (var i = 0; i < timepoints.length; i++) {
            if (CCF_options[timepoints[i]].length < 1) {
                valid = false;
            }
        }
        return valid;
    }

    function all_cell_combos(CCF_options, timepoints, alleles) {
        for (var i = 0; i < timepoints.length; i++) {
            if (i == 0) {
                var opts = CCF_options[timepoints[i].toString()];
            }
            else {
                var timepoint_data = CCF_options[timepoints[i].toString()];

                opts = add_combo(opts, timepoint_data, alleles);
            }
        }
        return opts;
    }

    function add_combo(opts, timepoint_data, alleles) {
        var updated_opts = [];
        for (var i = 0; i < opts.length; i++) {
            //object
            var current_opt = opts[i];
            for (var j = 0; j < timepoint_data.length; j++) {
                var opt_copy = JSON.parse(JSON.stringify(current_opt));
                var chrs_check = true;
                for (var k = 0; k < alleles.length; k++) {
                    if (opt_copy[(alleles[k] + '_chrs').toString()] != timepoint_data[j][(alleles[k] + '_chrs').toString()]) {
                        chrs_check = false;
                    }
                    opt_copy[alleles[k].toString()] = opt_copy[alleles[k].toString()].concat(timepoint_data[j][alleles[k].toString()]);
                }
                if (chrs_check == true) {
                    updated_opts.push(opt_copy);
                }
            }
        }
        return updated_opts;
    }

    function get_parent_alleles(plot_background_children, canvas_nested_data) {
        var alleles = [];
        for (var i = 0; i < plot_background_children.length; i++) {
            alleles.push(canvas_nested_data[parseInt(plot_background_children[i])].key);
        }
        return alleles;
    }

    function get_ploidy(allele, nested_data, plot_background_children) {
        for (var i = 0; i < plot_background_children.length; i++) {
            if (nested_data[plot_background_children[i]].key == allele) {
                return nested_data[plot_background_children[i]].ploidy;
            }
        }
    }

    function set_up_ccf_boundries(canvas_nested_data, fishplot_svgs, ccf_type) {
        for (var i = 0; i < fishplot_svgs.length; i++) {
            var current_allele = canvas_nested_data[fishplot_svgs[i]];
            var start_point = current_allele.start_point;
            for (var j = 0; j < current_allele.values.length; j++) {
                var half_ccf = current_allele.values[j][ccf_type] / 2;
                current_allele.values[j].top = start_point + half_ccf;
                current_allele.values[j].bottom = start_point - half_ccf;
            }
        }
    }

    //Retains un-trimmed copy of updated values
    function update_canvas_nested_data(canvas_nested_data, fishplot_svgs) {
        for (var i = 0; i < fishplot_svgs.length; i++) {
            var current_index = fishplot_svgs[i];
            canvas_nested_data[current_index] = JSON.parse(JSON.stringify(canvas_nested_data[current_index]));
        }
    }


    //Check if it can fit within parent
    function can_fit(nested_data, parent, current_data, num_of_timepoints) {
        //Add 1 to include the origin
        num_of_timepoints = num_of_timepoints + 1;
        var children = parent.children;
        for (var i = 0; i < num_of_timepoints; i++) {
            var freq_at_timepoint = current_data.values[i].alt_count;
            for (var j = 0; j < children.length; j++) {
                freq_at_timepoint = freq_at_timepoint + nested_data[children[j]].values[i].alt_count;
            }
            if (freq_at_timepoint > parent.values[i].alt_count) {
                return false;
            }
        }
        return true;
    }

    //Make nested data in correct order using only those plotted
    //This makes the data being plotted compatible with the adjust children positioning function
    function reconstruct_data(nested_data, fishplot_svgs) {
        var new_data = [];
        for (var i = 0; i < fishplot_svgs.length; i++) {
            var current_data = nested_data[fishplot_svgs[i]];
            var new_children = [];
            if (current_data.parent_index_of_this != 'plot') {
                current_data.parent_index_of_this = fishplot_svgs.indexOf(current_data.parent_index_of_this);
            }
            for (var j = 0; j < current_data.children.length; j++) {
                new_children.push(fishplot_svgs.indexOf(parseInt(current_data.children[j])));
            }
            current_data.children = new_children;
            new_data.push(current_data);
        }
        return new_data;
    }

    //Update the start points as we see them on plot, so fishes are relative to where they are dropped
    function set_new_start_point(canvas_nested_data, nested_data, fishplot_svgs, children) {
        for (var i = 0; i < children.length; i++) {
            var index = nested_data[children[i]].index;
            canvas_nested_data[index].start_point = nested_data[children[i]].start_point;
            canvas_nested_data[index] = JSON.parse(JSON.stringify(canvas_nested_data[index]));
        }
    }

    function prompt(sample_timepoints, tick_labels, nested_data, parent, origin_timepoint, complete_nested_data,
                    plot_background, allele_color_reference, fishplot_svgs, parent_of_this) {

        d3.select('#modal_table_reprompt').remove();

        var CCF_options = {};
        load_CCF_options(CCF_options, sample_timepoints);


        if (parent.key == 'plot') {
            var purity_dict = get_purity_dict(tick_labels);
            var is_subclone = false;
            var total_chrs = null;
        }
        if (parent.key != 'plot') {
            var viable_parents = true;
            is_subclone = true;
            var purity_dict = {};
            for (var i = 0; i < tick_labels.length; i++) {

                var purity_value = complete_nested_data[parent_of_this].values[i + 1].ccf;
                if (purity_value == undefined) {
                    viable_parents = false;
                    break;
                }
                if (purity_value > 100) {
                    purity_value = 100;
                }
                if (purity_value < 0) {
                    purity_value = 0;
                }
                purity_dict[tick_labels[i].toString()] = purity_value;
            }
            var total_chrs_counts = get_pre_determined_total_chrs_count(complete_nested_data,
                    plot_background, tick_labels);
        }

        for (var i = 0; i < tick_labels.length; i++) {
            //actual timepoint index is +1 since first timepoint is the origin
            var timepoint_index = i + 1;
            if (is_subclone == true) {
                var total_chrs = total_chrs_counts[tick_labels[i].toString()].reduce(function (a, b) {
                    return a + b;
                }, 0);
            }

            find_CCFs(parent.children, parent.children.length, complete_nested_data,
                    purity_dict[tick_labels[i].toString()], parent.children.length, [], tick_labels[i],
                    CCF_options, timepoint_index, is_subclone, total_chrs);
        }

        delete CCF_options[origin_timepoint.toString()];

        var valid = is_valid(CCF_options, tick_labels);


        if (valid == true) {
            var parent_alleles = get_parent_alleles(parent.children, nested_data);
            CCF_options = all_cell_combos(CCF_options, tick_labels, parent_alleles);
        }
        else {
            CCF_options = [];
        }

        if(CCF_options.length > 100){
            var first_fifty = CCF_options.slice(0, 50);
            var last_fifty = CCF_options.slice((CCF_options.length - 50))
            CCF_options = first_fifty.concat(last_fifty);
        }

        var modal_table = d3.select('#CCF_modal_body_reprompt').append('table')
                .attr('id', 'modal_table_reprompt')
                .attr('class', 'table table-hover');
        var thead = modal_table.append('thead').append('tr');

        var alleles_column = thead.append('th').html('Parent Alleles');
        var chrs_affected_column = thead.append('th').html('Chrs Affected');
        var timepoints_column = thead.append('th').html('CCFs at Timepoints');

        var table_body = modal_table.append('tbody')
                .style('cursor', 'pointer');

        var rows = table_body.selectAll('possible_ccfs')
                .data(CCF_options)
                .enter()
                .append('tr')
                .attr('index', function (d, i) {
                    return i;
                })
                .attr('is-clicked', 0)
                .on('mouseover', function () {
                    if (d3.select(this).attr('is-clicked') != 1) {
                        d3.select(this).style('background-color', '#f5f5f5');
                    }
                })
                .on('mouseout', function () {
                    if (d3.select(this).attr('is-clicked') != 1) {
                        d3.select(this).style('background-color', '#ffffff');
                    }
                })
                .on('mouseenter', function () {
                    if (d3.select(this).attr('is-clicked') != 1) {
                        d3.select(this).style('background-color', '#f5f5f5');
                    }
                })
                .on('click', function (d) {
                    //unselect previously selected tr
                    if (d3.select('#selected-tr').node() != null && d3.select(this).attr('id') != 'selected-tr') {
                        d3.select('#selected-tr').attr('id', '')
                                .attr('is-clicked', 0)
                                .style('background-color', '#ffffff');
                    }

                    d3.select(this).attr('id', 'selected-tr');

                    var is_clicked = d3.select(this).attr('is-clicked');
                    if (is_clicked == 0) {
                        d3.select(this).attr('class', 'is-clicked');
                        d3.select(this).attr('is-clicked', 1);
                        d3.select(this).style('background-color', '#DCDCDC');
                    }
                    else if (is_clicked == 1) {
                        d3.select(this).attr('is-clicked', 0);
                        d3.select(this).style('background-color', '#f5f5f5');
                    }
                });

        rows.append('td')
                .attr('class', function (d, i) {
                    return 'row-data-' + i;
                })
                .html(function (d) {
                    var alleles = JSON.parse(JSON.stringify(parent_alleles));
                    for (var i = 0; i < alleles.length; i++) {
                        var allele = alleles[i];
                        var color = allele_color_reference[allele];
                        var string = '<span style="color:' + color + '">'
                                + allele + '</span>';
                        alleles[i] = string;
                    }
                    alleles = alleles.join(' </br> ');
                    return alleles;
                });

        rows.append('td')
                .attr('class', function (d, i) {
                    return 'row-data-' + i;
                })
                .html(function (d) {
                    var alleles = JSON.parse(JSON.stringify(parent_alleles));
                    var chrs_affected_array = [];
                    for (var i = 0; i < alleles.length; i++) {
                        var chrs_key = alleles[i] + '_chrs';
                        var ploidy = get_ploidy(alleles[i], nested_data, parent.children);
                        var string = d[chrs_key] + '/' + ploidy;
                        chrs_affected_array.push(string);
                    }
                    chrs_affected_array = chrs_affected_array.join(' </br> ');
                    return chrs_affected_array;
                });

        rows.append('td')
                .attr('class', function (d, i) {
                    return 'row-data-' + i;
                })
                .html(function (d) {
                    var alleles = JSON.parse(JSON.stringify(parent_alleles));
                    var cell_fraction_array = [];
                    for (var i = 0; i < alleles.length; i++) {
                        var current_allele = alleles[i];
                        var allele_string = [];
                        for (j = 0; j < tick_labels.length; j++) {
                            allele_string.push('<span style="color:#0000FF">'
                                    + tick_labels[j] + ': '
                                    + '</span>' + d[current_allele][j]);
                        }
                        var string = allele_string.join(', ');
                        cell_fraction_array.push(string);
                    }
                    cell_fraction_array = cell_fraction_array.join(' </br> ');
                    return cell_fraction_array;
                });

                $('#CCF_modal_reprompt').modal('show');

    }

    function alleles_in_nested_data(canvas_nested_data) {
        var alleles = [];
        for (var i = 0; i < canvas_nested_data.length; i++) {
            alleles.push(canvas_nested_data[i].key);
        }
        return alleles;
    }
    function update_variant_info(data, alleles, canvas_nested_data) {
        var all_alleles = alleles_in_nested_data(canvas_nested_data);
        for (var i = 0; i < alleles.length; i++) {
            var index = all_alleles.indexOf(alleles[i]);

            //applying info for ploidy
            var chrs_aff = data[alleles[i] + '_chrs'].toString() + '/' + canvas_nested_data[index].ploidy.toString();
            var string = d3.select('#chrs_aff_text' + index.toString()).node().innerHTML.split(':')[0];
            string = string + ': ' + chrs_aff;
            d3.select('#chrs_aff_text' + index.toString()).text(function () {
                return string;
            });

            //applying info for CCF
            var ccf = data[alleles[i]];
            //CCF was 0 before the origin
            ccf.unshift(0);
            for (var j = 0; j < canvas_nested_data[index].values.length; j++) {
                canvas_nested_data[index].values[j].ccf = ccf[j];
            }
        }
    }

    //function to keep record of conserved alt count, mainly for fishplot table
    //called in fishplot table scope, and fishplot editor (need when saving fishplot)
    function add_conserved_alt_count(nested_data) {
        for (var i = 0; i < nested_data.length; i++) {
            var timepoint_data = nested_data[i].values;
            for (var j = 0; j < timepoint_data.length; j++) {
                timepoint_data[j].conserved_alt_count = timepoint_data[j].alt_count;
            }
        }
    }

    function fishplot_plot(canvas_svg, tick_labels, canvas_nested_data, fishplot_svgs, plot_background, num_of_timepoints,
    canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor, contextMenuShowing,
    contextMenuForPrevious, type, allele_color_reference, max_vaf) {

        canvas_svg.html('');
        var purity = get_purity_dict(tick_labels);
        if(type == 'only_cancer_ccf'){
            relative_to_cancer_cells(canvas_nested_data, fishplot_svgs, purity, tick_labels);
        }
        set_up_ccf_boundries(canvas_nested_data, fishplot_svgs, type);

        var nested_data = canvas_nested_data.slice(0);

        //Create shallow copy for values of each fishplot used
        //Prevents find_origin function from permanently trimming allele values
        update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

        for (var i = 0; i < plot_background.children.length; i++) {
            var parent = nested_data[plot_background.children[i]];
            var start_point = parent.start_point;
            nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, max_vaf, type);
        }

        adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, type, max_vaf);

        nested_data = reconstruct_data(nested_data, fishplot_svgs);

        //collision detection for children after adjusting the independent evolution positions
        nested_data = adjust_children_positioning(nested_data, num_of_timepoints, type);

        //load pinches
        //Have to use fishplot svgs to select specific indices of nested_data
        //Otherwise, we prematurely clip off the origin of fishplots starting after
        //The first timepoint (i.e. Pretreatment in example file)
        for (var i = 0; i < fishplot_svgs.length; i++) {
            var current_allele = nested_data[i];
            for (var j = 0; j < current_allele.values.length; j++) {
                //Initialize all pinches to false
                //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                current_allele.values[j].pinch = false;
            }
            current_allele.values = find_origin(current_allele);
        }

        remove_unnecessary_values(nested_data);

        d3.selectAll('.big_fish').remove();

        for (var i = 0; i < nested_data.length; i++) {
            var current_data = nested_data[i];

            canvas_svg.append('path')
                    .attr('fill', 'none')
                    .attr('stroke-width', 5)
                    .attr("stroke", "transparent")
                    .attr('class', 'big_fish')
                    .style("stroke-linejoin", "round")
                    .attr('d', function () {
                        return canvas_top_line_gen(current_data.values);
                    });

            canvas_svg.append('path')
                    .attr('fill', 'none')
                    .attr("stroke", "transparent")
                    .style("stroke-linejoin", "round")
                    .attr('class', 'big_fish')
                    .attr('stroke-width', 8)
                    .attr('d', function () {
                        return canvas_bottom_line_gen(current_data.values);
                    });

            canvas_svg.append('path')
                    .datum(current_data.values)
                    .attr('fill', current_data.color)
                    .attr('opacity', 1)
                    .attr('class', 'big_fish dropdown-toggle')
                    .attr('d', canvas_area_between_lines)
                    .attr('index', current_data.index)
                    .attr('id', 'big_fish' + current_data.index)
                    .style('cursor', 'pointer')
                    .on('mouseenter', function (d) {
                        moused_over = parseInt(d3.select(this).attr('index'));
                    })
                    .on('mouseover', function(){
                        moused_over = parseInt(d3.select(this).attr('index'));
                    })
                    .on('mouseleave', function () {
                        d3.select(this).attr('opacity', 1);
                    })
                    .on('contextmenu', function () {
                        contextMenuFor = parseInt(d3.select(this).attr('index'));

                        //give the button an attribute to reference the fishplots they're dealing with
                        //now we can invoke a function on click
                        d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                        d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                        if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                            contextMenuShowing = false;
                        }
                        if (contextMenuShowing == false) {
                            contextMenuForPrevious = contextMenuFor;
                            d3.event.preventDefault();
                            d3.select('#context-div').attr('cm-showing', 'true');
                            contextMenuShowing = true;
                            d3.select('#context-div').style('left', function () {
                                        var left = d3.event.pageX;
                                        return left + 'px';
                                    })
                                    .style('top', function () {
                                        //-75 pixels because of navbar padding
                                        var top = d3.event.pageY - 75;
                                        return top + 'px';
                                    })
                                    .style('z-index', 10)
                                    .style('opacity', 1);
                        }
                        else {
                            d3.event.preventDefault();
                            contextMenuShowing = false;
                            d3.select('#context-div').attr('cm-showing', 'false');
                            d3.select('#context-div').style('opacity', 0)
                                    .style('z-index', -1);
                        }
                    });
        }
    }

    function reprompt(sample_timepoints, tick_labels, canvas_nested_data, ten_percent_below_zero,
                      complete_nested_data, plot_background, allele_color_reference, fishplot_svgs, index,
                      canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                      contextMenuShowing, contextMenuForPrevious, type, canvas_svg, num_of_timepoints, max_vaf) {
        d3.select('#save-CCF-button-reprompt').attr('index', index);
        var from_button = d3.select('#save-CCF-button-reprompt').attr('from-button');

        var allele = canvas_nested_data[fishplot_svgs[index]];
            var prompt_ccf = false;
        for (var j = 0; j < allele.values.length; j++) {
            if (allele.values[j].ccf == undefined) {
                prompt_ccf = true;
                var parent_of_this = allele.parent_index_of_this;
                if (parent_of_this == 'plot') {
                    var parent = plot_background;
                }
                else {
                    parent = canvas_nested_data[parent_of_this];
                }
                break;
            }
        }


        if (index == fishplot_svgs.length-1) {
            if(prompt_ccf == true){
                d3.select('#save-CCF-button-reprompt').attr('last-prompt', true);
                if(from_button == true || from_button == 'true') {
                    setTimeout(function(){
                        prompt(sample_timepoints, tick_labels, canvas_nested_data, parent, ten_percent_below_zero,
                            complete_nested_data, plot_background, allele_color_reference,
                            fishplot_svgs, parent_of_this);
                    }, 400);
                    return;
                }
                else{
                    prompt(sample_timepoints, tick_labels, canvas_nested_data, parent, ten_percent_below_zero,
                            complete_nested_data, plot_background, allele_color_reference,
                            fishplot_svgs, parent_of_this);
                    return;
                }
            }
             d3.select('#save-CCF-button-reprompt').attr('last-prompt', false);
            fishplot_plot(canvas_svg, tick_labels, canvas_nested_data, fishplot_svgs, plot_background, num_of_timepoints,
                    canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                    contextMenuShowing, contextMenuForPrevious, type, allele_color_reference, max_vaf);
            return;
        }

            if (prompt_ccf == true) {
                if(from_button == true || from_button == 'true') {
                    setTimeout(function(){
                        prompt(sample_timepoints, tick_labels, canvas_nested_data, parent, ten_percent_below_zero,
                            complete_nested_data, plot_background, allele_color_reference,
                            fishplot_svgs, parent_of_this);
                    }, 400);
                    return;
                }
                prompt(sample_timepoints, tick_labels, canvas_nested_data, parent, ten_percent_below_zero,
                        complete_nested_data, plot_background, allele_color_reference,
                        fishplot_svgs, parent_of_this);
            }

            if(prompt_ccf == false) {
                if(index < fishplot_svgs.length-1){
                    index = index+1;
                    reprompt(sample_timepoints, tick_labels, canvas_nested_data, ten_percent_below_zero,
                      complete_nested_data, plot_background, allele_color_reference, fishplot_svgs, index,
                      canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                      contextMenuShowing, contextMenuForPrevious, type, canvas_svg, num_of_timepoints, max_vaf);
                }
            }
    }





    (function() {
        //Application name: tevApp
        //Dependencies: None
        var tevApp = angular.module('tevApp', []);

        //To distinguish between Django variables used in HTML
        tevApp.config(function($interpolateProvider) {
            $interpolateProvider.startSymbol('[{');
            $interpolateProvider.endSymbol('}]');
        });

        tevApp.config(function ($httpProvider) {
            $httpProvider.defaults.xsrfCookieName = 'csrftoken';
            $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';
        });

        tevApp.factory('alleleify', ['$http', function($http){
            return {
                alleleify: function(data, gene_data){
                    var allele_data = [];

                    //Loop through to get all uuid
                    //So we only have to access them, instead of loop through for every amino acid change
                    var gene_uuids = [];
                    var chromosomes = {};
                    var positions = {};
                    var types = {};
                    var cDNAs = {};
                    var ref_seqs = {};
                    var references = {};
                    var alternatives = {};

                    for(var i = 0; i < gene_data.length; i++){
                        gene_uuids.push(gene_data[i].uuid);
                    }

                    for(var i = 0; i < data.length; i++){
                        var timepoint = data[i].timepoint;
                        var alleles = data[i].VariantAlleles;
                        for(var j = 0; j < alleles.length; j++){
                            var allele = gene_data[gene_uuids.indexOf(alleles[j].gene)].name
                                    + '-'
                                    + alleles[j].AA_original
                                    + alleles[j].AA_position.toString()
                                    + alleles[j].AA_variant;
                            var alt_count = alleles[j].alternative_freq;
                            if(chromosomes[allele] == undefined){
                                chromosomes[allele] = gene_data[gene_uuids.indexOf(alleles[j].gene)].chromosome;
                                positions[allele] = gene_data[gene_uuids.indexOf(alleles[j].gene)].position;
                                types[allele] = alleles[j].type;
                                cDNAs[allele] = alleles[j].cDNA_change;
                                ref_seqs[allele] = alleles[j].ref_seq;
                                references[allele] = alleles[j].reference;
                                alternatives[allele] = alleles[j].alternative;
                            }
                            allele_data.push({
                                allele: allele,
                                Sample_Barcode: timepoint,
                                alt_count: alt_count
                            });
                        }
                    }
                    return [allele_data, chromosomes, positions, types, cDNAs, ref_seqs, references, alternatives];
                },

                patch: function(data){
                    var timepoints = uniqueAxisLabels(data, 'Sample_Barcode');
                    data.sort(function(a,b) {return (a.allele > b.allele) ? 1 : ((b.allele > a.allele) ? -1 : 0);} );

                    var current_allele = data[0].allele;
                    var timepoints_hit = [];
                    var unhit_array = [];

                    for(var i = 0; i < data.length; i++){
                        if(data[i].allele == current_allele){
                            timepoints_hit.push(data[i].Sample_Barcode);
                        }
                        else{
                            var unhit_timepoints = timepoints.diff(timepoints_hit);
                            for(var j = 0; j < unhit_timepoints.length; j++){
                                unhit_array.push({
                                    allele: current_allele,
                                    Sample_Barcode: unhit_timepoints[j],
                                    alt_count: 0
                                });
                            }
                            timepoints_hit = [];
                            current_allele = data[i].allele;
                            timepoints_hit.push(data[i].Sample_Barcode);
                        }
                    }
                    //Get the unhit timepoints from last remaining allele
                    unhit_timepoints = timepoints.diff(timepoints_hit);
                    for(var j = 0; j < unhit_timepoints.length; j++){
                                unhit_array.push({
                                    allele: current_allele,
                                    Sample_Barcode: unhit_timepoints[j],
                                    alt_count: 0
                                });
                            }

                    data = data.concat(unhit_array);
                    return data;
                },

                allele_color_reference: function(alleleified_data){
                    var colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#bcbd22', '#17becf',
                    '#393b79', '#637939', '#b5cf6b', '#e7ba52', '#d6616b', '#843c39', '#7b4173'];

                    var nested_data = d3.nest().key(function (d) {
                                return d.allele;
                            })
                            .entries(alleleified_data);

                    var color_ref = {};
                    for(var i = 0; i < nested_data.length; i++){
                        var allele = nested_data[i].key;
                        color_ref[allele] = colors[i];
                    }
                    return color_ref;
                },

                patients_with_gene: function (alleleified_data, source_data, gene_data) {
                    //nest alleles to get gene names, will use gene_data to convert uuid to these gene names when done
                    var alleles = d3.nest().key(function (d) {
                                return d.allele;
                            })
                            .entries(alleleified_data);
                    var genes = [];
                    var gene_to_uuid = {};
                    var gene_uuids = [];
                    var genes_dict = {};
                    for (var i = 0; i < alleles.length; i++) {
                        genes.push(alleles[i].key.split('-')[0]);
                    }
                    //grab gene uuids to look up in sources (foreign key)
                    for (var i = 0; i < gene_data.length; i++) {
                        if (genes.indexOf(gene_data[i].name) != -1) {
                            genes_dict[gene_data[i].uuid] = [];
                            gene_uuids.push(gene_data[i].uuid);
                            gene_to_uuid[gene_data[i].name] = gene_data[i].uuid;
                        }
                    }

                    for (var i = 0; i < source_data.length; i++) {
                        var source = source_data[i].subject_id;
                        var samples = source_data[i].Samples;
                        var genes_used = [];
                        for (var j = 0; j < samples.length; j++) {
                            var variants = samples[j].VariantAlleles;
                            for (var k = 0; k < variants.length; k++) {
                                if (gene_uuids.indexOf(variants[k].gene) != -1 && genes_used.indexOf(variants[k].gene) == -1) {
                                    genes_used.push(variants[k].gene);
                                    genes_dict[variants[k].gene].push(source);
                                }
                                if (genes_used.length == gene_uuids.length) {
                                    break;
                                }
                            }
                            if (genes_used.length == gene_uuids.length) {
                                break;
                            }
                        }
                    }

                    for(var i = 0; i < genes.length; i++){
                        genes_dict[genes[i]] = genes_dict[gene_to_uuid[genes[i]]];
                    }
                    return genes_dict;
                }
            };
        }]);

        tevApp.factory('saved_fishplots', function(){
           return {
              get_names: function (name_data){
                  var names_array = [];
                  name_data =  name_data.saved_as;

                  for(var i = 0; i < name_data.length; i++){
                      names_array.push(name_data[i].name);
                  }
                  return names_array;
              }
           } ;
        });

        tevApp.factory('purity', function(){
           return {
               init_purities: function(data){
                   var timepoints = uniqueAxisLabels(data, 'Sample_Barcode');
                   var purity_dict = {};
                   for(var i = 0; i < timepoints.length; i++){
                       purity_dict[timepoints[i]] = 90;
                   }
                   return purity_dict;
               }
           }
        });


        //Controller name: TevDataController
        //Services: scope, http
        tevApp.controller('tevDataController', ['$scope', '$http', '$filter', 'alleleify', '$q', 'saved_fishplots', 'purity', '$window',
            function($scope, $http, $filter, allelify, $q, saved_fishplots, purity, $window){
            //Initialize the scopes data to empty (will render blank plots until we've fetched data)

                angular.element($window).on('resize', $scope.$apply.bind($scope));

                $scope.tevData = [];
                $scope.alleleified_data = [];
                //parameter for editor table only, when user loads previously saved fishplot
                $scope.loaded_fishplot_data = [];
                $scope.chromosome_dict = {};
                $scope.position_dict = {};
                $scope.type_dict = {};
                $scope.cDNA_dict = {};
                $scope.ref_seq_dict = {};
                $scope.reference_dict = {};
                $scope.alternative = {};
                $scope.linked_alleleified_data = [];
                $scope.dendro_data = [];
                $scope.dendro_y_data = [];
                $scope.fishbone_data = [];
                //Created this variable because if alleleified_data is changed by dendrogram grouping,
                // it would keep calling itself
                $scope.clustered_alleleified_data = [];
                $scope.alleles = [];
                $scope.subject_id = '';
                $scope.saved_fishplot_names = [];
                $scope.updated_editor_info = [];
                $scope.color_ref = {};
                //dictionary with how many patients in DB share mutation in gene
                //could do on allele basis?
                $scope.patient_gene_dict = {};

                //data for purity line plot above fishplot editor
                $scope.purity_data = {};

                //Check if an allele has already been plotted. For editor table... dont allow change if plotted
                $scope.plotted = [];
                $scope.prompt = 0;

                var source_uuid = '{{ source }}';
                var dendro_data = {{ d3_dendro_data|safe }};
                var dendro_y_data = {{ dendro_y_data }};

                //Get the data from the API
                var source_request = $http.get('../api/v1/sources/');
                var gene_request = $http.get('../api/v1/genes/');
                var sample_request = $http.get('../api/v1/samples/');
                var saved_fishplot_names_request = $http.get('../api/v1/saved_fishplots_just_names/');

                $q.all([source_request, gene_request, saved_fishplot_names_request]).then(function(results_array){
                    var tevData = results_array[0].data;
                    var source_data = results_array[0].data;
                    var gene_data = results_array[1].data;
                    var saved_fishplot_names = results_array[2].data;
                    tevData = $filter('filter')(tevData, {'uuid': source_uuid})[0];
                    $scope.subject_id = tevData.subject_id;
                    saved_fishplot_names = $filter('filter')(saved_fishplot_names, {'subject_id': tevData.subject_id})[0];
                    if(saved_fishplot_names != undefined){
                        saved_fishplot_names = saved_fishplots.get_names(saved_fishplot_names);
                        $scope.saved_fishplot_names = saved_fishplot_names;
                    }

                    d3.select('#subject_brand').html(function(){
                        return $scope.subject_id;
                    });
                    $scope.tevData = tevData.Samples;

                    var alleleified_data = allelify.alleleify($scope.tevData, gene_data);
                    $scope.chromosome_dict = alleleified_data[1];
                    $scope.position_dict = alleleified_data[2];
                    $scope.type_dict = alleleified_data[3];
                    $scope.cDNA_dict = alleleified_data[4];
                    $scope.ref_seq_dict = alleleified_data[5];
                    $scope.reference_dict = alleleified_data[6];
                    $scope.alternative_dict = alleleified_data[7];
                    alleleified_data = alleleified_data[0];
                    alleleified_data = allelify.patch(alleleified_data);
                    $scope.alleleified_data = alleleified_data;
                    $scope.color_ref = allelify.allele_color_reference(alleleified_data);
                    $scope.patient_gene_dict = allelify.patients_with_gene(alleleified_data, source_data, gene_data);

                    $scope.purity_data = purity.init_purities(alleleified_data);

                    //Send through this data, when the data from the API has been recieved
                    $scope.dendro_data = dendro_data;
                    $scope.dendro_y_data = dendro_y_data;
                });
        }]);

        //Directive that contains d3 code to render allele frequency change over timepoints
        //Plot type: Line plot
        tevApp.directive('figure1Plot',['$window', function($window){
            return {
               scope: {
                   data: '=',
                   colors: '='
               },
               restrict: 'A',
               link: link
           };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var color_ref = scope.colors;

                scope.$watch('colors', function(new_colors){
                   color_ref = new_colors;
                });

                function overtimeLinePlot(updatedData, el, height, width){
                    d3.select(el).select('svg').remove();
                    d3.select(el).selectAll('div').remove();

                    data = updatedData;


                    if(data.length == 0){
                        return;
                    }

                    var canvas = d3.select(el).append("svg")
                        .attr("height", height)
                        .attr("width", width);

                    var title = canvas.append('text')
                            .attr('class', 'title-text')
                            .attr('x', width/2)
                            .attr('y', 20)
                            .style('text-anchor', 'middle')
                            .text(function(){
                                return 'VAF Over Time for Each Allele';
                            });

                    var div_tooltip = d3.select(el).append("div")
                            .attr('id', 'fig1-tooltip')
                            .attr("class", "tooltip")
                            .style('white-space', 'nowrap')
                            .style("opacity", 0);

                    var yScale = d3.scale.linear().range([40, height-40]).domain([1, 0]);
                    var yAxis = d3.svg.axis().scale(yScale).orient("left");

                    var axisLabels = uniqueAxisLabels(data, 'Sample_Barcode');
                    axisLabels = axisLabels.sort(function(a, b){
                       return a - b;
                    });

                    var xScale = d3.scale.ordinal().rangePoints([40, width-40], 0.5).domain(axisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    var lineGen = d3.svg.line()
                            .x(function(d){
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                                return yScale(d.alt_count/100);
                            });

                    var nestedData = d3.nest()
                            .key(function(d){
                               return d.allele;
                            })
                            .entries(data);

                    nestedData = sort_nested_alleles(nestedData);

                    var lineSvg = canvas.append("g");
                    var pointSvg = canvas.append("g");

                    nestedData.forEach(function(d, i){

                        lineSvg.append("path")
                                .attr("fill", "none")
                                .attr("stroke", function(){
                                    return color_ref[d.values[0].parent_allele];
                                })
                                .attr("stroke-width", 2)
                                .attr("d", lineGen(d.values));

                        pointSvg.selectAll("timepoints")
                                .data(d.values)
                                .enter()
                                .append("rect")
                                .attr("x", function(d){
                                    return (xScale(d.Sample_Barcode)-5);
                                })
                                .attr("y", function(d){
                                    return (yScale(d.alt_count/100) - 5);
                                })
                                .attr("width", 12)
                                .attr("height", 12)
                                .attr('class', 'info_rects')
                                .attr("fill", function(){
                                    return color_ref[d.values[0].parent_allele];
                                })
                                .on("mouseover", function(d){
                                    div_tooltip.style("opacity", 0.9)
                                    .html('<p id="timepoint_p" align="left" style="text-overflow: ellipsis; color: #fff;"> <b>'
                                            + 'Timepoint: </b> ' + d.Sample_Barcode + '</p>'
                                            + '<p id="allele_p" align="left" style="text-overflow: ellipsis; color: #fff">'
                                            + '<b>Allele: </b>' + d.allele + '</p>'
                                            + '<p id="vaf_p" align="left" style="text-overflow: ellipsis; color: #fff;">'
                                            + '<b>VAF: </b>' + d.alt_count + '</p>')
                                            .style("top", (d3.mouse(this)[1] - 40) + "px")
                                            .style("left", (d3.mouse(this)[0] + 40) + "px");

                                    var timepoint_p_height = d3.select('#timepoint_p').node().clientHeight + (parseInt(d3.select('#timepoint_p').style('margin-bottom')));
                                    var allele_p_height = d3.select('#allele_p').node().clientHeight + (parseInt(d3.select('#allele_p').style('margin-bottom')));
                                    var vaf_p_height = d3.select('#vaf_p').node().clientHeight + (parseInt(d3.select('#vaf_p').style('margin-bottom')));
                                    var height = timepoint_p_height + allele_p_height + vaf_p_height;
                                    height = height + parseInt(d3.select('#allele_p').style('margin-bottom')); //extra cushion on bottom of tooltip

                                    var widths = [];
                                    widths.push(parseInt(d3.select('#timepoint_p').node().offsetWidth));
                                    widths.push(parseInt(d3.select('#allele_p').node().offsetWidth));
                                    widths.push(parseInt(d3.select('#vaf_p').node().offsetWidth));

                                    var width = Math.max.apply(null, widths);

                                    d3.select('#fig1-tooltip').style('height', function () {
                                                return height + 'px';
                                            })
                                            .style('width', function(){
                                                var width_padding  = 10;
                                                return (width + width_padding) + 'px';
                                            })
                                            .style('padding-top', function () {
                                                return parseInt(d3.select('#timepoint_p').style('margin-bottom')) + 'px';
                                            })
                                            .style('padding-bottom', function(){
                                                return parseInt(d3.select('#vaf_p').style('margin-bottom')) + 'px';
                                            })

                                })
                                .on("mouseout", function(){
                                    div_tooltip.remove();
                                    div_tooltip = d3.select(el).append("div")
                                            .attr('id', 'fig1-tooltip')
                                            .attr("class", "tooltip")
                                            .style('white-space', 'nowrap')
                                            .style("opacity", 0);
                                });

                    });

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + (height-40) + ")")
                        .call(xAxis);

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);

                }

                scope.$watch('data', function(updated_data){
                    overtimeLinePlot(updated_data, el, height, width);

                    $window.addEventListener('resize', overtime_resize);
                    function overtime_resize() {
                        var new_height = d3.select(el).node().clientHeight;
                        var new_width = d3.select(el).node().clientWidth;
                        overtimeLinePlot(updated_data, el, new_height, new_width);
                    }
                }, true);
            }
        }]);

        //Directive that contains d3 code to render distribution of allele frequency at timepoints
        //Plot type: Box plots
        tevApp.directive('figure2Plot',['$window', function($window){
            return{
                restrict: 'A',
                link: link,
                scope: {
                    data: '=',
                    colors: '='
                }
            };

            function link(scope, element){
                var data = scope.data[0];
                var alleles = scope.data[1];
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var color_ref = scope.colors;
                var current_extension = d3.select(el).attr('ext', 0);


                scope.$watch('colors', function(new_colors){
                    color_ref = new_colors;
                });

                function makeBoxPlots(updatedData, el, height, width){
                    d3.select(el).select('svg').remove();
                    d3.select(el).selectAll('div').remove();

                    data = updatedData[0];
                    alleles = updatedData[1];

                    if(data.length == 0){
                        return;
                    }

                    var canvas = d3.select(el).append("svg")
                        .attr("height", height)
                        .attr("width", width);

                    var title = canvas.append('text')
                            .attr('class', 'title-text')
                            .attr('x', width/2)
                            .attr('y', 20)
                            .style('text-anchor', 'middle')
                            .text(function(){
                                return 'Distribution of VAF Over Time';
                            });

                    var information = ['90th:', 'Q3:', 'median:', 'Q1:', '10th:'];
                    var informationSvg = canvas.append("g");

                    informationSvg.selectAll("information_text")
                            .data(information)
                            .enter()
                            .append('text')
                            .attr('x', (width*0.82))
                            .attr('y', function(d, i){
                                return 60 + (25*i);
                            })
                            .style('font', '12px sans-serif')
                            .style('text-anchor', 'left')
                            .text(function(d){return d;});

                    var div_tooltip = d3.select(el).append("div")
                                            .attr('id', 'fig2-tooltip')
                                            .attr("class", "tooltip")
                                            .style('white-space', 'nowrap')
                                            .style("opacity", 0);

                    var axisLabels = uniqueAxisLabels(data, 'cluster');
                    axisLabels.sort(function(a, b){
                       return a - b;
                    });

                    var yScale = d3.scale.linear().range([40, height-40]).domain([1, 0]);
                    var yAxis = d3.svg.axis().scale(yScale).orient("left");

                    var xScale = d3.scale.ordinal().rangePoints([40, (width*0.8)], 0.5).domain(axisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    if(alleles.length == axisLabels.length){
                        axisLabels = uniqueAxisLabels(data, 'allele');
                        var nestedData = d3.nest().key(function(d){return d.allele}).entries(data);
                        xScale = d3.scale.ordinal().rangePoints([40, (width*0.8)], 0.5).domain(axisLabels);
                        xAxis = d3.svg.axis().scale(xScale);
                    }
                    else{
                        nestedData = d3.nest().key(function(d){return d.cluster}).entries(data);
                        xAxis.tickFormat(function(d){return "cluster " + d;})
                    }

                    var boxData = [];
                    nestedData.forEach(function(d, i){
                        var quartileData = [];
                        var alleles = [];
                        for(var j = 0; j < d.values.length; j++){
                            quartileData[j] = d.values[j].alt_count/100;
                            if(alleles.indexOf(d.values[j].allele) == -1){
                                alleles.push(d.values[j].allele);
                            }
                        }

                        alleles = alleles.join('<br>');
                        alleles = ('<p align="left" ' +
                        'style="text-overflow: ellipsis; padding: 0em; margin-top: 0em; margin-bottom: 0em; border: 0em; color: #fff;">'
                        + alleles + '<\p>');
                        alleles = '<p align="center" ' +
                                'style="text-overflow: ellipsis; padding: 0em; margin-top: 0em; margin-bottom: 3px; border: 0em; color: #fff;">'
                                + '<b><u> alleles </u></b></p>' + alleles;
                        quartileData.sort(function(a,b) { return a - b;});

                        boxData[i] = {
                            x: d.key,
                            y: d3.quantile(quartileData, 0.75),
                            Q3: d3.quantile(quartileData, 0.75).toFixed(2),
                            Q1: d3.quantile(quartileData, 0.25).toFixed(2),
                            median: d3.median(quartileData).toFixed(2),
                            pNinety: d3.quantile(quartileData, 0.90).toFixed(2),
                            pTen: d3.quantile(quartileData, 0.10).toFixed(2),
                            color: color_ref[d.values[0].parent_allele],
                            alleles: alleles

                        };
                    });

                    //Start of d3 box plot
                    canvas.selectAll('boxes')
                            .data(boxData)
                            .enter()
                            .append('rect')
                            .attr('x', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('y', function(d){
                                return yScale(d.Q3);
                            })
                            .attr('width', 20)
                            .attr('height', function(d){
                                return (yScale(d.Q1) - yScale(d.Q3));
                            })
                            .attr('class', 'info_rects')
                            .attr('fill', function(d){
                               return d.color;
                            })
                            .on('mouseover', function(d){
                                var box_information = [d.pNinety, d.Q3, d.median, d.Q1, d.pTen];
                                informationSvg.selectAll('information_text')
                                        .data(box_information)
                                        .enter()
                                        .append('text')
                                        .attr('x', (width*0.82) + 50)
                                        .attr('y', function(d, i){
                                            return 60 + (25*i);
                                        })
                                        .attr('class', 'box_info')
                                        .style('font', '12px sans-serif')
                                        .style('text-anchor', 'left')
                                        .text(function(d){
                                           return d;
                                        });

                                div_tooltip.style("opacity", 0.9)
                                    .html(d.alleles)
                                        .style("top", (d3.mouse(this)[1] - 40) + "px")
                                        .style("left", (d3.mouse(this)[0] + 40) + "px");
                            })
                            .on('mouseout', function(){
                                div_tooltip.remove();
                                div_tooltip = d3.select(el).append("div")
                                            .attr('id', 'fig2-tooltip')
                                            .attr("class", "tooltip")
                                            .style('white-space', 'nowrap')
                                            .style("opacity", 0);

                                d3.selectAll('.box_info').remove();

                                div_tooltip.style('opacity', 0);
                            });

                    canvas.selectAll('upperVerticalBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x);
                            })
                            .attr('x2', function(d){
                                return xScale(d.x);
                            })
                            .attr('y1', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('y2', function(d){
                                return yScale(d.Q3);
                            })
                            .attr('fill', 'none')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1);


                    canvas.selectAll('lowerVerticalBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x);
                            })
                            .attr('x2', function(d){
                                return xScale(d.x);
                            })
                            .attr('y1', function(d){
                                return yScale(d.Q1);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('pNinetyBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('pTenBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('medianLines')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.median);
                            })
                            .attr('y2', function(d){
                                return yScale(d.median);
                            })
                            .attr('class', 'median_line')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none')
                            .on('mouseover', function(d){
                                if(d.Q1 == d.Q3) {
                                    var box_information = [d.pNinety, d.Q3, d.median, d.Q1, d.pTen];
                                    informationSvg.selectAll('information_text')
                                            .data(box_information)
                                            .enter()
                                            .append('text')
                                            .attr('x', 520 + 50)
                                            .attr('y', function (d, i) {
                                                return 60 + (25 * i);
                                            })
                                            .attr('class', 'box_data')
                                            .style('font', '12px sans-serif')
                                            .style('text-anchor', 'left')
                                            .text(function (d) {
                                                return d;
                                            });

                                    div_tooltip.style("opacity", 0.9)
                                            .html(d.alleles)
                                            .style("top", (d3.event.y - 40) + "px")
                                            .style("left", (d3.event.x + 40) + "px");
                                }
                            })
                            .on('mouseout', function(d){
                                if(d.Q1 == d.Q3) {
                                    d3.selectAll('.box_data').remove();

                                    div_tooltip.style('opacity', 0);
                                }
                            });

                    canvas.append("svg:g")
                            .attr("class", "axis")
                            .attr('id', 'fig2-x-axis')
                            .attr("transform", "translate(0," + (height-40) + ")")
                            .call(xAxis)
                            .selectAll("text")
                            .style('text-anchor', 'end')
                            .attr('transform', 'rotate(-65)');

                    canvas.append("svg:g")
                            .attr("class", "axis")
                            .attr("transform", "translate(" + 4 + "0)")
                            .call(yAxis);

                    var x_axis_svgs = d3.select('#fig2-x-axis').selectAll('text')[0];
                    var extend_height_by = [];

                    for(var i = 0; i < x_axis_svgs.length; i++){
                        extend_height_by.push(x_axis_svgs[i].clientWidth);
                    }

                    extend_height_by = Math.max.apply(null, extend_height_by);
                    if(extend_height_by > parseInt(d3.select(el).attr('ext'))){
                        d3.select(el).attr('ext', extend_height_by);
                    }
                    else {
                        extend_height_by = parseInt(d3.select(el).attr('ext'));
                    }

                    d3.select(el).style('height', function(){
                        var new_height = height + extend_height_by;
                        return new_height + 'px';
                    });

                    canvas.attr('height', function(){
                        var height = parseInt(d3.select(el).style('height'));
                        return height;
                    });

                }

                scope.$watch('data', function(updatedData){
                    makeBoxPlots(updatedData, el, height, width);

                    $window.addEventListener('resize', boxplot_resize);
                    function boxplot_resize(){
                        var new_width = d3.select(el).node().clientWidth;
                        makeBoxPlots(updatedData, el, height, new_width);
                    }
                }, true);
            }
        }]);

        //Directive that contains d3 code to render dendrogram clustered by alternative allele freq
        //Plot type: Elbow dendrogram
        tevApp.directive('figure3Plot', function(){

            return {
               restrict: 'A',
               scope: {
                   data: '=',
                   colors: '='
               },
               link: link
            };

            function link(scope, element){
                var data = scope.data[0];
                var dendro_y_positions = scope.data[1];
                var alleleified_data = scope.data[2];
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var color_ref = scope.data[3];

                var cluster = d3.layout.cluster()
                        .size([420, 420]);

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    var alleles = [];

                    data = updatedData[0];
                    dendro_y_positions = updatedData[1];
                    alleleified_data = updatedData[2];

                    color_ref = updatedData[3];

                    if(alleleified_data.length == 0){
                        return;
                    }

                    var canvas = d3.select(el).append('svg')
                            .attr('height', height)
                            .attr('width', width);

                    var title = canvas.append('text')
                            .attr('class', 'title-text')
                            .attr('x', width/2)
                            .attr('y', 20)
                            .style('text-anchor', 'middle')
                            .text(function(){
                                return 'Clustering of Alleles by VAF';
                            });

                    var sliderSvg = canvas.append('g');

                    canvas = canvas.append('g')
                            .attr('transform', 'translate(0, 75)');

                    var nodes = cluster.nodes(data);
                    var links = cluster.links(nodes);

                    //Update dendrogram position based on python clustering position
                    nodes.forEach(function(d, i){
                        d.y = dendro_y_positions[i];
                        d.id = i;
                    });

                    var drag = d3.behavior.drag()
                                .on('drag', function () {
                                    var slider = d3.select(this);
                                    var max_path_y = yScale.invert(30);
                                    if (d3.event.x < 30) {
                                        slider.attr('cx', 30);
                                        d3.select('#cutoff_line').attr('x1', 30).attr('x2', 30);
                                        max_path_y = yScale.invert(30);
                                    }
                                    else if (d3.event.x > 450) {
                                        slider.attr('cx', 450);
                                        d3.select('#cutoff_line').attr('x1', 450).attr('x2', 450);
                                        max_path_y = yScale.invert(450);
                                    }
                                    else {
                                        slider.attr('cx', d3.event.x);
                                        var cutoff = d3.select('#cutoff_line').attr('x1', d3.event.x).attr('x2', d3.event.x);
                                        max_path_y = yScale.invert(d3.event.x);
                                    }
                                    var linked_alleleified_data = cut_data(max_path_y, alleleified_data, nodes, scope.$parent.tevData);
                                    var clusters = linked_alleleified_data[2];
                                    var parents = linked_alleleified_data[3];

                                    for(var i = 0; i < clusters.length; i++){
                                        var alleles_in_cluster = clusters[i];
                                        for(var j = 0; j < alleles_in_cluster.length; j++){
                                            var id = '#allele' + alleles.indexOf(alleles_in_cluster[j]);
                                            var node = d3.select(id);
                                            for(var k = 0; k < parents.length; k++) {
                                                if(alleles_in_cluster.indexOf(parents[k]) != -1) {
                                                    node.attr('fill', color_ref[parents[k]]);
                                                }
                                            }
                                        }
                                    }
                                    scope.$apply(function(){
                                        scope.$parent.linked_alleleified_data = linked_alleleified_data[0];
                                        scope.$parent.clustered_alleleified_data = linked_alleleified_data[1];
                                    });
                                });

                    sliderSvg.append('line')
                            .attr('x1', 30)
                            .attr('x2', 450)
                            .attr('y1', 50)
                            .attr('y2', 50)
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1.5)
                            .attr('fill', 'none');

                    sliderSvg.append('circle')
                            .attr('r', 7)
                            .attr('cy', 50)
                            .attr('cx', 450)
                            .attr('id', 'slider_circle')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 0.5)
                            .attr('fill', '#EEEEEE')
                            .style('cursor', 'pointer')
                            .call(drag);

                    var y_max = Math.max.apply(null, dendro_y_positions);
                    var yScale = d3.scale.linear().domain([y_max, 0]).range([30, 450]);
                    var yAxis = d3.svg.axis().scale(yScale).orient('top');

                    var link = canvas.selectAll('.link')
                            .data(links)
                            .enter()
                            .append('path')
                            .attr('class', 'link')
                            .attr('d', function elbow(d, i) {
                                return "M" + yScale(d.source.y) + "," + d.source.x
                                        + "V" + d.target.x + "H" + yScale(d.target.y);
                            })
                            .attr('fill', 'none')
                            .attr('stroke', "#ccc")
                            .attr('stroke-width', 1.5)
                            .attr('transform', 'translate(0,40)');

                    var node = canvas.selectAll('.node')
                            .data(nodes)
                            .enter()
                            .append('g')
                            .attr('transform', function(d){return "translate("+ yScale(d.y) + "," + (d.x + 40) + ")";});

                    node.append('circle')
                            .attr('r', function(d){
                                if(d.name == " "){
                                    return 0;
                                }
                                return 4.5;
                            })
                            .attr('id', function(d){
                                if(d.name != " ") {
                                    alleles.push(d.name);
                                    return 'allele'+ (d.cluster-1);
                                }
                                else{
                                    return "empty";
                                }
                            })
                            .attr('stroke-width', 1.5)
                            .attr('fill', function(d){
                                if(d3.select(this).attr('id') == 'empty'){
                                    return;
                                }
                                return color_ref[d.parent_allele];
                            });

                    canvas.append('line')
                            .attr('x1', function(){
                                var x = d3.select('#slider_circle').attr('cx');
                                return x;
                            })
                            .attr('x2', function(){
                                var x = d3.select('#slider_circle').attr('cx');
                                return x;
                            })
                            .attr('y1', 30)
                            .attr('y2', 450)
                            .attr('id', 'cutoff_line')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    node.append("text")
                            .attr("dx", function(d) { return d.children ? -8 : 8; })
                            .attr("dy", 3)
                            .attr('class', 'node_text')
                            .attr("text-anchor", function(d) { return d.children ? "end" : "start"; })
                            .text(function(d) { return d.name; });

                    canvas.append("svg:g")
                            .attr("class", "axis")
                            .attr('transform', 'translate(0, 25)')
                            .call(yAxis);

                    //Initialize the fishplot data
                    var linked_alleleified_data = cut_data(0, alleleified_data, nodes, scope.$parent.tevData);
                    scope.$parent.linked_alleleified_data = linked_alleleified_data[0];
                    scope.$parent.clustered_alleleified_data = linked_alleleified_data[1];
                    //Input the alleles, ordered by clustering
                    scope.$parent.alleles = alleles;

                }, true);
            }

        });

        //Directive that contains d3 code to render proposed clonal evolution
        //Plot type: Fishbone
        tevApp.directive('figure4Plot', function(){
            return {
                restrict: 'A',
                scope: {
                    data: '=',
                    colors: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el =  element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var color_ref = scope.colors;

                var cluster = d3.layout.cluster()
                        .size([420, 420]);

                //padding between independent fishplot backbones
                var fishbone_padding = 50;

                scope.$watchGroup(['data', 'colors'], function(updatedData){
                    d3.select(el).select('svg').remove();

                    data = updatedData[0];
                    color_ref = updatedData[1];
                    var additive_y = 50;

                    if(data.length == 0){
                        return;
                    }

                    function get_parent_clones(data){
                        var parent_indices = [];
                        for(var i = 0; i < data.length; i++){
                            if(data[i].parent_index_of_this == 'plot'){
                                parent_indices.push(i);
                            }
                        }
                        return parent_indices;
                    }

                    var independent_clonal_evos = get_parent_clones(data);

                    var svg = d3.select(el).append("svg")
                            .attr('id', 'fishbone_svg')
                            .attr("height", height)
                            .attr("width", width);

                    var title = svg.append('text')
                            .attr('class', 'title-text')
                            .attr('x', width/2)
                            .attr('y', 20)
                            .style('text-anchor', 'middle')
                            .text(function(){
                                return 'Fishbone of Suggested Fishplot';
                            });

                    for(var p = 0; p < independent_clonal_evos.length; p++) {

                        var fishbone_data = {};
                        fishbone_data.name = data[independent_clonal_evos[p]].key;
                        fishbone_data.children = [];
                        fishbone_data.cluster = data[independent_clonal_evos[p]].values[0].cluster;
                        fishbone_data.parent_allele = data[independent_clonal_evos[p]].values[0].parent_allele;

                        for (var i = 0; i < data[independent_clonal_evos[p]].children.length; i++) {
                            var child = data[independent_clonal_evos[p]].children[i];
                            child = data[child];
                            add_children(child, fishbone_data, data);
                        }

                        var cluster = d3.layout.cluster()
                                .size([100, 400]);

                        var diagonal = d3.svg.diagonal()
                                .projection(function (d) {
                                    return [d.y, d.x];
                                });

                        var fishbone = svg.append('svg')
                                .attr('width', width)
                                .attr('x', 0)
                                .attr('y', additive_y)
                                .append("g")
                                .attr('id', 'fishbone'+p)
                                .attr("transform", "translate(100," + 20 + ")");

                        var nodes = cluster.nodes(fishbone_data),
                                links = cluster.links(nodes);

                        var link = fishbone.selectAll(".link")
                                .data(links)
                                .enter().append("path")
                                .attr("class", "link")
                                .attr("d", diagonal);

                        var node = fishbone.selectAll(".node")
                                .data(nodes)
                                .enter().append("g")
                                .attr("class", "node")
                                .attr("transform", function (d) {
                                    return "translate(" + d.y + "," + d.x + ")";
                                });

                        node.append("circle")
                                .attr("r", 4.5)
                                .attr('fill', function (d) {
                                    return color_ref[d.parent_allele];
                                });

                        nodes.forEach(function (d) {
                            var names = d.name.split('\n');
                            for (var i = 0; i < names.length; i++) {
                                var name = names[i];
                                fishbone.append('text')
                                        .attr('class', 'node_text')
                                        .attr("transform", "translate(" + d.y + "," + d.x + ")")
                                        .attr('dx', function () {
                                            return d.children ? -8 : 8;
                                        })
                                        .attr('dy', function () {
                                            return ((i + 1) * 10);
                                        })
                                        .style("text-anchor", function () {
                                            return d.children ? "end" : "start";
                                        })
                                        .text(name);
                            }
                        });

                        additive_y = additive_y + d3.select('#fishbone'+p).node().getBBox().height + fishbone_padding;
                        if(additive_y > parseInt(d3.select(el).style('height'))){
                            d3.select(el).style('height', additive_y+'px');
                        }
                    }
                });

            }

        });

        //Directive that contains d3 code to render proposed clonal evolution and alternative allele freq
        //Plot type: Fishplot
        tevApp.directive('figure5Plot',['$window', function($window){

            return {
                restrict: 'A',
                scope: {
                    data: '=',
                    colors: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;
                var color_ref = scope.colors;

                function plotSuggestedFishplot(updatedData, el, height, width){
                    d3.select(el).selectAll('svg').remove();

                    data = updatedData[0];
                    color_ref = updatedData[1];

                    if(data.length == 0 || data[0].cluster == undefined){
                        return;
                    }

                    var canvas = d3.select(el).append('svg')
                        .attr('width', width)
                        .attr('height', height);

                    var title = canvas.append('text')
                            .attr('class', 'title-text')
                            .attr('x', width/2)
                            .attr('y', 20)
                            .style('text-anchor', 'middle')
                            .text(function(){
                                return 'A Fishplot Suggesting One Option of Clonal Expansion';
                            });

                    var div_tooltip = d3.select(el).append("div")
                            .attr('id', 'fig5-tooltip')
                            .attr("class", "tooltip")
                            .style('white-space', 'nowrap')
                            .style("opacity", 0);

                    var xAxisLabels = uniqueAxisLabels(data, 'Sample_Barcode');
                    xAxisLabels = xAxisLabels.sort(function(a, b){
                       return a - b;
                    });
                    var num_of_timepoints = xAxisLabels.length;
                    var sample_timepoints = uniqueAxisLabels(data, 'Sample_Barcode');

                    var x_max = Math.max.apply(null, xAxisLabels);

                    var ten_percent_below_zero = 0.1 * x_max;
                    ten_percent_below_zero = parseInt(0 - ten_percent_below_zero);
                    xAxisLabels.unshift(ten_percent_below_zero);

                    var ten_percent_above_max = 0.1 * x_max;
                    ten_percent_above_max = x_max + ten_percent_above_max;
                    xAxisLabels.push(ten_percent_above_max);

                    var xScale = d3.scale.linear().rangeRound([40, width-40], 0.5)
                            .domain(d3.extent(xAxisLabels, function(d){return d;}));
                    var xAxis = d3.svg.axis().scale(xScale).tickValues(sample_timepoints);

                    var yScale = d3.scale.linear().range([40, height-40], 0.5).domain([101, -1]);
                    var yAxis = d3.svg.axis().scale(yScale).orient('left').ticks(0);

                    var nestedData = d3.nest().key(function(d){return d.allele}).entries(data);

                    nestedData = sort_nested_alleles(nestedData);

                    nestedData = add_origin(nestedData, ten_percent_below_zero);

                    //Set up data for comparisons
                    var fishplot_data = [];

                    nestedData.forEach(function(d, i){
                        var allele_data = {};
                        allele_data['allele'] = d.key;
                        allele_data['freqs'] = [];
                        var freqs = d.values;
                        for(var j = 0; j < freqs.length; j++){
                            allele_data['freqs'].push(freqs[j].alt_count);
                        }
                        fishplot_data.push(allele_data);
                    });


                    var sort_array = [];
                    for(var i = 0; i < fishplot_data.length; i++){
                        //Have to rank when ordering, because a subclone that develops later
                        //cannot be parent of clone that derived earlier, even if it has a higher variant allele freq
                        var ranking_adjustment = Math.pow(10, num_of_timepoints);
                        var allele_freqs = fishplot_data[i].freqs;
                        for(var j = 0; j < allele_freqs.length; j++){
                            if(allele_freqs[j] != 0){
                                var rank = ranking_adjustment * allele_freqs[j];
                                sort_array.push({
                                    allele: fishplot_data[i].allele,
                                    rank: rank
                                });
                                break;
                            }
                            ranking_adjustment = ranking_adjustment/10;
                        }
                    }

                    sort_array.sort(function(a, b){
                       return b.rank - a.rank;
                    });

                    //Order data based on rank
                    nestedData = order_by_rank(nestedData, sort_array);



                    var plot_background = {};
                    plot_background.key = "plot";
                    plot_background.values = [];
                    plot_background.values.length = nestedData[0].values.length;
                    plot_background.values.fill({alt_count: 100});
                    plot_background.children = [0];
                    plot_background.groups = {0: 0};

                    //Initialize first parent group
                    nestedData[0].group = 0;
                    nestedData[0].start_point = 50;
                    nestedData[0].parent_index_of_this = "plot";
                    nestedData[0].children = [];
                    nestedData[0].id = 0;

                    //Array to hold alleles that didn't fit on plot
                    var unused = [];


                    for(var i = 1; i < nestedData.length; i++) {
                        var current_allele_data = nestedData[i];
                        var former_allele_data = nestedData[i-1];
                        current_allele_data.group = former_allele_data.group;
                        current_allele_data.start_point = former_allele_data.start_point;
                        current_allele_data.parent_index_of_this = i-1;
                        current_allele_data.children = [];
                        current_allele_data.id = i;


                        //check if it can fit inside its parent
                        var append_as_child = 'yes';
                        var parent_of_child_index = i;
                        for(var j = 1; j < current_allele_data.values.length; j++){
                            if(current_allele_data.values[j].alt_count > former_allele_data.values[j].alt_count) {
                                append_as_child = 'no';
                                break;
                            }
                        }
                        if(append_as_child == 'yes'){
                            former_allele_data.children.push(parent_of_child_index);
                        }
                        else {
                            var done = 0;
                            var children_used = [];
                            while (done != 1){
                                var next_up = former_allele_data.parent_index_of_this;
                                current_allele_data.parent_index_of_this = next_up;
                                if(next_up == "plot"){
                                    children_used.push(former_allele_data.id);
                                    var children = plot_background.children.diff(children_used);
                                    if(children.length == 0) {
                                        var parent_allele = plot_background;
                                    }
                                    else {
                                        var next_group = nestedData[children[0]].group;
                                        //find the last allele that was a child of the new group
                                        for(var l = i; l >= 0; l--){
                                            if(nestedData[l].group == next_group){
                                                parent_allele = nestedData[l];
                                                var new_group_dummy_data = {};
                                                new_group_dummy_data.group = next_group;
                                                new_group_dummy_data.parent_index_of_this = parent_allele.id;
                                                new_group_dummy_data.values = [];
                                                new_group_dummy_data.values.length = parent_allele.values.length;
                                                new_group_dummy_data.values.fill({alt_count: 0});
                                                former_allele_data = new_group_dummy_data;
                                                current_allele_data.parent_index_of_this = parent_allele.id;
                                                break;
                                            }
                                        }
                                    }
                                }
                                else{
                                    if(next_up == "none"){
                                        break;
                                    }
                                    var parent_allele = nestedData[next_up];
                                }
                                //Check if it can fit inside parent_allele alongside parent_allele's children
                                //Array that holds total freq of children alleles at timepoint
                                var total_children_freq = [];
                                total_children_freq.length = parent_allele.values.length;
                                total_children_freq.fill(0);
                                for(var j = 0; j < parent_allele.children.length; j++){
                                    var child_allele = parent_allele.children[j];
                                    child_allele = nestedData[child_allele];
                                    for(var k = 0; k < total_children_freq.length; k++){
                                        total_children_freq[k] = child_allele.values[k].alt_count + total_children_freq[k];
                                    }
                                }
                                //Now add the current_allele values to the children total and see if they fit inside of parent
                                var check_if_fits = 1;
                                for(var j = 0; j < total_children_freq.length; j++){
                                    if((total_children_freq[j] + current_allele_data.values[j].alt_count) > parent_allele.values[j].alt_count){
                                        //If this is true at least one, check_if_fits will be 0 and we assign the parent
                                        //as the former allele
                                        former_allele_data = parent_allele;
                                        check_if_fits = 0;
                                    }
                                }
                                if(check_if_fits == 1){
                                    parent_allele.children.push(i);
                                    if(parent_allele.key == "plot"){
                                        current_allele_data.group = (parent_allele.children.length - 1);
                                        plot_background.groups[current_allele_data.group.toString()] = i;
                                        var start_point_space = 100/parent_allele.children.length;
                                        var base_start_point = start_point_space/2;
                                        for(var g = 0; g < i+1; g++){
                                            var start = base_start_point + (nestedData[g].group * start_point_space);
                                            nestedData[g].start_point = start;
                                        }
                                    }
                                    else{
                                        current_allele_data.group = parent_allele.group;
                                        current_allele_data.start_point = parent_allele.start_point;
                                        }
                                    done = 1;
                                }
                                if(check_if_fits == 0 && parent_allele.key == "plot"){
                                    current_allele_data.parent_index_of_this = 'none';
                                    //Doesn't fit... done=1 to move on
                                    unused.push(current_allele_data.key);
                                    done = 1;
                                }
                            }
                        }
                    }

                    scope.$parent.fishbone_data = nestedData;

                    //Find where the lines of the border should be, adjusting so that no line goes below 0
                    //and no line goes above 100
                    for(var i = 0; i < plot_background.children.length; i++) {
                        var parent = nestedData[plot_background.children[i]];
                        var start_point = parent.start_point;
                        nestedData[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100, 'alt_count');
                    }

                    adjust_independent_evolution_positions(nestedData, plot_background, num_of_timepoints, 'alt_count', 100);

                    nestedData = adjust_children_positioning(nestedData, num_of_timepoints, 'alt_count');

                    //load pinches
                    for(var i = 0; i < nestedData.length; i++){
                        var current_allele = nestedData[i];
                        for(var j = 0; j < current_allele.values.length; j++){
                            //Initialize all pinches to false
                            //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                            current_allele.values[j].pinch = false;
                        }
                    }

                    var topLineGen = d3.svg.line()
                            .interpolate('cardinal').tension(0.85)
                            .x(function(d){
                                if(d.pinch == true){
                                    var x_pos = (xScale(d.Sample_Barcode) + xScale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                                return yScale(d.top);
                            });

                    var bottomLineGen = d3.svg.line()
                            .interpolate('cardinal').tension(0.85)
                            .x(function(d, i){
                                if(d.pinch == true){
                                    var x_pos = (xScale(d.Sample_Barcode) + xScale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                               return yScale(d.bottom);
                            });

                    //Get all of the x-values that make up the top line (will be same as bottom, symmetrical)
                    //Then take area along y-axis between the top and bottom lines
                    var areaBetweenLines = d3.svg.area()
                            .interpolate('cardinal').tension(0.85)
                            .x(topLineGen.x())
                            .y0(topLineGen.y())
                            .y1(bottomLineGen.y());

                    nestedData.forEach(function(d, i){

                        canvas.append('path')
                                .attr('fill', 'none')
                                .attr('stroke-width', 5)
                                .attr("stroke", "transparent")
                                .style("stroke-linejoin", "round")
                                .attr('d', topLineGen(d.values));

                        canvas.append('path')
                                .attr('fill', 'none')
                                .attr("stroke", "transparent")
                                .style("stroke-linejoin", "round")
                                .attr('stroke-width', 8)
                                .attr('d', bottomLineGen(d.values));

                        var old_x = 0;
                        var old_y = 0;

                        canvas.append('path')
                                .datum(d.values)
                                .attr('fill', function(d){
                                    return color_ref[d[0].parent_allele];
                                })
                                .attr('opacity', 1)
                                .attr('d', areaBetweenLines)
                                .style('cursor', 'pointer')
                                .on('mouseover', function(d){
                                    var alleles = d[0].allele;
                                    alleles = alleles.split('\n');
                                    alleles = alleles.join('<br>');
                                    alleles = ('<p align="left" ' +
                                    'style="text-overflow: ellipsis; padding: 0em; margin-top: 0em; margin-bottom: 0em; border: 0em; color: #fff;">'
                                    + alleles + '</p>');
                                    alleles = '<p align="center" ' +
                                            'style="text-overflow: ellipsis; padding: 0em; margin-top: 0em; margin-bottom: 3px; border: 0em; color: #fff;">'
                                            + '<b><u> alleles </u></b></p>' + alleles;

                                    div_tooltip.style("opacity", 0.9)
                                            .html(alleles)
                                            .style("top", (d3.mouse(this)[1] - 40) + "px")
                                            .style("left", (d3.mouse(this)[0] + 40) + "px");

                                    old_x = d3.event.x;
                                    old_y = d3.event.y;
                                })
                                .on('mousemove', function(){
                                    var new_x = d3.event.x;
                                    var new_y = d3.event.y;
                                    var x_difference = new_x - old_x;
                                    var y_difference = new_y - old_y;

                                    old_x = new_x;
                                    old_y = new_y;

                                    div_tooltip.style('top', function () {
                                                var top = parseInt(div_tooltip.style('top'));
                                                top = top + y_difference;
                                                return top + 'px';
                                            })
                                            .style('left', function () {
                                                var left = parseInt(div_tooltip.style('left'));
                                                left = left + x_difference;
                                                return left + 'px';
                                            });
                                })
                                .on('mouseleave', function () {
                                    div_tooltip.remove();

                                    div_tooltip = d3.select(el).append("div")
                                            .attr('id', 'fig5-tooltip')
                                            .attr("class", "tooltip")
                                            .style('white-space', 'nowrap')
                                            .style("opacity", 0);
                                });
                    });



                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + (height-40) + ")")
                        .call(xAxis);

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);

                }

                scope.$watchGroup(['data', 'colors'], function(updatedData){
                    plotSuggestedFishplot(updatedData, el, height, width);

                    $window.addEventListener('resize', suggested_fishplot_resize);

                    function suggested_fishplot_resize(){
                        var new_width = d3.select(el).node().clientWidth;
                        plotSuggestedFishplot(updatedData, el, height, new_width);
                    }
                });
            }

        }]);

        tevApp.directive('fishplotEditor',['$http', '$filter', '$window', function ($http, $filter, $window) {
            return {
                restrict: 'A',
                scope: {
                    data: '=',
                    values: '=',
                    colors: '=',
                    chromosomes: '=',
                    positions: '=',
                    types: '=',
                    cdnas: '=',
                    refseqs: '=',
                    references: '=',
                    alternatives: '=',
                    patientswithgene: '='
                },
                link: link
            };

            function link(scope, element) {
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;
                var color_ref = scope.colors;
                var chromosome_ref = scope.chromosomes;
                var position_ref = scope.positions;
                var type_ref = scope.types;
                var cDNA_ref = scope.cdnas;
                var ref_seq_ref = scope.refseqs;
                var reference_ref = scope.references;
                var alternative_ref = scope.alternatives;
                var patients_with_gene_ref = scope.patientswithgene;

                //variables to hold canvas_nested_data and fishplot_svgs
                var resize_canvas_nested_data = [];
                var resize_fishplot_svgs = [];

                //When trying to get offsetTop for figure6 div it doesn't use heights of collapsed div
                //It uses their full heights, as if they were expanded
                var panel_heading_one_height = d3.select('#heading1').node().clientHeight;
                var panel_heading_two_height = d3.select('#heading2').node().clientHeight;
                var purity_div_height = d3.select('#purity-row').node().clientHeight;
                var estimated_accordian_padding = 3*20;
                var estimated_offsetTop = panel_heading_one_height+panel_heading_two_height+purity_div_height+estimated_accordian_padding;
                height = d3.select(window).node().outerHeight - estimated_offsetTop;

                //initial max VAF
                var max_VAF_value = 100;

                scope.$watch('colors', function(new_colors){
                    color_ref = new_colors;
                });

                scope.$watch('chromosomes', function(updated_info){
                    chromosome_ref = updated_info;
                });

                scope.$watch('positions', function(updated_info){
                    position_ref = updated_info;
                });

                scope.$watch('types', function(updated_info){
                    type_ref = updated_info;
                });

                scope.$watch('cdnas', function(updated_info){
                    cDNA_ref = updated_info;
                });

                scope.$watch('refseqs', function(updated_info){
                    ref_seq_ref = updated_info;
                });

                scope.$watch('references', function(updated_info){
                    reference_ref = updated_info;
                });

                scope.$watch('alternatives', function(updated_info){
                    alternative_ref = updated_info;
                });

                scope.$watch('patientswithgene', function(updated_info){
                    patients_with_gene_ref = updated_info;
                });

                function create_fishplot_editor(updated_data, el, height, width) {
                    d3.select(el).selectAll('svg').remove();
                    d3.select(el).selectAll('div').remove();
                    data = updated_data;

                    var mini_nested_data = d3.nest().key(function (d) {
                        return d.allele;
                    }).entries(data);

                    mini_nested_data = sort_nested_alleles(mini_nested_data);

                    var canvas_nested_data = d3.nest().key(function (d) {
                        return d.allele;
                    }).entries(data);

                    canvas_nested_data = sort_nested_alleles(canvas_nested_data);

                    for(var i = 0; i < canvas_nested_data.length; i++){
                        canvas_nested_data[i].chromosome = chromosome_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i].position = position_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i].type = type_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i].cDNA = cDNA_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i].ref_seq = ref_seq_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i].reference = reference_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i].alternative = alternative_ref[canvas_nested_data[i].key];
                        canvas_nested_data[i]['patients with gene']= patients_with_gene_ref[canvas_nested_data[i].key.split('-')[0]].length;

                        mini_nested_data[i].chromosome = chromosome_ref[mini_nested_data[i].key];
                        mini_nested_data[i].position = position_ref[mini_nested_data[i].key];
                        mini_nested_data[i].type = type_ref[mini_nested_data[i].key];
                        mini_nested_data[i].cDNA = cDNA_ref[mini_nested_data[i].key];
                        mini_nested_data[i].ref_seq = ref_seq_ref[mini_nested_data[i].key];
                        mini_nested_data[i].reference = reference_ref[mini_nested_data[i].key];
                        mini_nested_data[i].alternative = alternative_ref[mini_nested_data[i].key];
                        mini_nested_data[i]['patients with gene'] = patients_with_gene_ref[mini_nested_data[i].key.split('-')[0]].length;
                    }

                    var fishplot_data = [];

                    canvas_nested_data.forEach(function(d, i){
                        var allele_data = {};
                        allele_data['allele'] = d.key;
                        allele_data['freqs'] = [];
                        var freqs = d.values;
                        for(var j = 0; j < freqs.length; j++){
                            allele_data['freqs'].push(freqs[j].alt_count);
                        }
                        fishplot_data.push(allele_data);
                    });

                    add_conserved_alt_count(canvas_nested_data);
                    add_conserved_alt_count(mini_nested_data);


                    var x_axis_labels = [];
                    x_axis_labels = uniqueAxisLabels(data, 'Sample_Barcode');
                    x_axis_labels = x_axis_labels.sort(function(a, b){
                       return a - b;
                    });

                    var num_of_timepoints = x_axis_labels.length;
                    var sample_timepoints = uniqueAxisLabels(data, 'Sample_Barcode');
                    sample_timepoints = sample_timepoints.sort(function(a, b){
                       return a - b;
                    });

                    var tick_labels = uniqueAxisLabels(data, 'Sample_Barcode');
                    tick_labels = tick_labels.sort(function(a, b){
                       return a - b;
                    });

                    var x_max = Math.max.apply(null, x_axis_labels);

                    var ten_percent_below_zero = 0.1 * x_max;
                    ten_percent_below_zero = parseInt(0 - ten_percent_below_zero);
                    x_axis_labels.unshift(ten_percent_below_zero);

                    sample_timepoints.unshift(ten_percent_below_zero);

                    var ten_percent_above_max = 0.1 * x_max;
                    ten_percent_above_max = x_max + ten_percent_above_max;
                    x_axis_labels.push(ten_percent_above_max);

                    //Sorting data by what can fit in what
                    var sort_array = [];
                    for(var i = 0; i < fishplot_data.length; i++){
                        //Have to rank when ordering, because a subclone that develops later
                        //cannot be parent of clone that derived earlier, even if it has a higher variant allele freq
                        var ranking_adjustment = Math.pow(10, num_of_timepoints);
                        var allele_freqs = fishplot_data[i].freqs;
                        for(var j = 0; j < allele_freqs.length; j++){
                            if(allele_freqs[j] != 0){
                                var rank = ranking_adjustment * allele_freqs[j];
                                sort_array.push({
                                    allele: fishplot_data[i].allele,
                                    rank: rank
                                });
                                break;
                            }
                            ranking_adjustment = ranking_adjustment/10;
                        }
                    }

                    sort_array.sort(function(a, b){
                       return b.rank - a.rank;
                    });

                    //Order mini fishplot svgs by rank
                    mini_nested_data = order_by_rank(mini_nested_data, sort_array);
                    //Also reorder nested data to be used for canvas to keep it consistent
                    canvas_nested_data = order_by_rank(canvas_nested_data, sort_array);

                    scope.$parent.ordered_data = canvas_nested_data;

                    //Add children, parent, and index fields
                    for (var i = 0; i < canvas_nested_data.length; i++) {
                        canvas_nested_data[i].children = [];
                        canvas_nested_data[i].parent_index_of_this = 'none';
                        canvas_nested_data[i].index = i;
                        canvas_nested_data[i].ploidy = 2;
                        canvas_nested_data[i].chrs_affected = 'N/A';
                        canvas_nested_data[i].color = color_ref[canvas_nested_data[i].key];

                        mini_nested_data[i].ploidy = 2;
                        mini_nested_data[i].color = color_ref[mini_nested_data[i].key];
                    }

                    var CCF_options = {};


                    var allele_color_reference = associated_allele_colors(canvas_nested_data);

                    load_CCF_options(CCF_options, sample_timepoints);

                    //Div wrapper for dragable div
                    var dragable_div_wrapper = d3.select(el).append('div')
                            .style('top', '0px')
                            .style('left', '0px')
                            .style('width', '25%')
                            .style('height', height + 'px')
                            .style('float', 'left')
                            .style('overflow', 'visible')
                            .style('padding', '0px')
                            .style('position', 'relative')
                            .attr('id', 'dragable_div_wrapper');

                    var new_height = d3.select('#dragable_div_wrapper').node().offsetHeight;
                    d3.select(el).style('height', new_height + 'px');


                    //Div to hold container svg
                    var container = dragable_div_wrapper.append('div')
                            .style('top', '0px')
                            .style('left', '0px')
                            .style('width', '100%')
                            .style('height', height + 'px')
                            .style('float', 'left')
                            .style('overflow-y', 'scroll')
                            .style('overflow-x', 'hidden')
                            .style('padding', '2px')
                            .style('position', 'relative')
                            .attr('id', 'container_div')
                            .on('scroll', function () {
                                d3.selectAll('#dragable_div').remove();
                            });

                    //Div to hold canvas svg
                    var canvas = d3.select(el).append('div')
                            .style('top', new_height + 'px')
                            .style('left', width * 0.27 + 'px')
                            .style('width', '73%')
                            .style('height', height + 'px')
                            .style('padding', '2px')
                            .style('float', 'right')
                            .attr('id', 'canvas_div');

                    //Will contain the index in the nested data of what fish the user is currently moused over
                    var moused_over;

                    //Canvas svg where fishplot will be plotted
                    var canvas_svg = canvas.append('svg')
                            .attr('width', '100%')
                            .attr('height', '100%')
                            .attr('id', 'canvas_svg')
                            .attr('index', 'canvas_svg')
                            .on('mouseover', function () {
                                if (dragging) {
                                    moused_over = d3.select(this).attr('index');
                                }
                            });

                    //Use jQuery because d3.select('#canvas_svg').node().clientWidth doesnt work on Firefox
                    var canvas_range_max_x = $('#canvas_svg').width();
                    var canvas_x_scale = d3.scale.linear()
                            .rangeRound([canvas_range_max_x*0.01, canvas_range_max_x*0.99], 0.25)
                            .domain(d3.extent(x_axis_labels, function(d){ return d;}));
                    var canvas_x_axis = d3.svg.axis().scale(canvas_x_scale).tickValues(tick_labels);

                    //Also use jQuery here because
                    var canvas_range_max_y = $('#canvas_svg').height() * 0.95;
                    var canvas_y_scale = d3.scale.linear().range([0, canvas_range_max_y]).domain([max_VAF_value+1, -1]);

                    function y_scale_domain_max(nested_data) {
                        var max_array = [];
                        for (var i = 0; i < nested_data.length; i++) {
                            var allele_alt_counts = [];
                            var timepoint_data = nested_data[i].values;
                            for (var j = 0; j < timepoint_data.length; j++) {
                                allele_alt_counts[j] = timepoint_data[j].alt_count;
                            }
                            max_array[i] = Math.max.apply(Math, allele_alt_counts);
                        }
                        return Math.max.apply(Math, max_array);
                    }

                    var y_max = y_scale_domain_max(mini_nested_data);

                    mini_nested_data = add_origin(mini_nested_data, ten_percent_below_zero);
                    canvas_nested_data = add_origin(canvas_nested_data, ten_percent_below_zero);


                    function generate_mini_fishplot_top_and_bottom(nested_data, y_max) {
                        var mid_point = y_max / 2;
                        for (var i = 0; i < nested_data.length; i++) {
                            var allele_freqs = nested_data[i].values;
                            for (var j = 0; j < allele_freqs.length; j++) {
                                var split = allele_freqs[j].alt_count / 2;
                                allele_freqs[j].top = mid_point + split;
                                allele_freqs[j].bottom = mid_point - split;
                            }
                        }
                    }

                    generate_mini_fishplot_top_and_bottom(mini_nested_data, y_max);
                    var mini_x_range_max = d3.select('#container_div').node().clientWidth;

                    var mini_x_scale = d3.scale.linear().rangeRound([0, mini_x_range_max], 0.5)
                            .domain(d3.extent(x_axis_labels, function(d){return d;}));
                    var mini_y_scale = d3.scale.linear().range([20, 140]).domain([y_max + 1, -1]);

                    var top_line_gen = d3.svg.line()
                            .interpolate('cardinal').tension(0.85)
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (mini_x_scale(d.Sample_Barcode) + mini_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return mini_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return mini_y_scale(d.top);
                            });

                    var canvas_top_line_gen = d3.svg.line()
                            .interpolate('cardinal').tension(0.85)
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (canvas_x_scale(d.Sample_Barcode) + canvas_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return canvas_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return canvas_y_scale(d.top);
                            });

                    var bottom_line_gen = d3.svg.line()
                            .interpolate('cardinal').tension(0.85)
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (mini_x_scale(d.Sample_Barcode) + mini_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return mini_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return mini_y_scale(d.bottom);
                            });

                    var canvas_bottom_line_gen = d3.svg.line()
                            .interpolate('cardinal').tension(0.85)
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (canvas_x_scale(d.Sample_Barcode) + canvas_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return canvas_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return canvas_y_scale(d.bottom);
                            });

                    var area_between_lines = d3.svg.area()
                            .interpolate('cardinal').tension(0.85)
                            .x(top_line_gen.x())
                            .y0(top_line_gen.y())
                            .y1(bottom_line_gen.y());

                    var canvas_area_between_lines = d3.svg.area()
                            .interpolate('cardinal').tension(0.85)
                            .x(canvas_top_line_gen.x())
                            .y0(canvas_top_line_gen.y())
                            .y1(canvas_bottom_line_gen.y());

                    //Keep track of fishplots on canvas & order they're in
                    //In case new plot added to canvas background and need to move/shift everything
                    var fishplot_svgs = [];

                    var mini_fishplot_data = JSON.parse(JSON.stringify(mini_nested_data));

                    pinch_data(mini_fishplot_data);
                    remove_unnecessary_values(mini_fishplot_data);


                    var container_div_height = 600;
                    var top;
                    var mini_fishplot_container_height = 160;
                    var mini_fishplots = container.selectAll('alleles')
                                .data(mini_fishplot_data)
                                .enter()
                                .append('div')
                                .style('top', function (d, i) {
                                    //150 will be height of divs holding mini fishplots
                                    if (i == 0) {
                                        top = 10;
                                    }
                                    else {
                                        top = top + mini_fishplot_container_height + 10;
                                        if (top + mini_fishplot_container_height > container_div_height) {
                                            container_div_height = top + mini_fishplot_container_height;
                                            d3.select('#container_div').attr('height', container_div_height)
                                        }
                                    }
                                    return top + 'px';
                                })
                                .style('left', '0px')
                                .style('width', '100%')
                                .style('height', mini_fishplot_container_height + 'px')
                                .style('position', 'absolute')
                                .style('cursor', 'default')
                                .style('background', '#FFF')
                                .style('opacity', 1)
                                .attr('index', function (d, i) {
                                    return i;
                                })
                                .attr('class', 'mini_fishplot_divs')
                                .attr('z-index', 5)
                                .attr('id', function (d, i) {
                                    return 'mini_fishplot_div' + i;
                                });


                    var plot_background = {};
                    plot_background.key = "plot";
                    plot_background.values = [];
                    plot_background.values.length = canvas_nested_data[0].values.length;
                    //Depends on what the domain is for the canvas... right now the max is 100 total for the fishplot(s)
                    plot_background.values.fill({alt_count: max_VAF_value});
                    plot_background.children = [];
                    plot_background.groups = {0: 0};
                    var groups = [];


                    var old_x_pos = 0;
                    var new_x_pos = 0;
                    var old_y_pos = 0;
                    var new_y_pos = 0;
                    var top_in_container, left_in_container;

                    for(var i = 0; i < mini_fishplot_data.length; i++){
                        d3.select('#mini_fishplot_div'+i).style('background-color', function(){
                            if((i+1)%2 != 0){
                                return '#d6d6d6';
                            }
                            else{
                                return '#eff0f2';
                            }
                        })
                    }
                    d3.select('#canvas_div').style('background-color', '#f2f3f4');
                    d3.select('#container_div').style('background-color', '#f2f3f4');

                    //Lay down an svg in the divs
                    var svgs = mini_fishplots.append('svg')
                            .attr('width', '100%')
                            .attr('height', '100%')
                            .attr('class', 'mini_fishplots')
                            .attr('opacity', 1)
                            .attr('id', function (d, i) {
                                return 'mini_fishplot_svg' + i;
                            });

                    var dragging = false;

                    //Indices of used fishplots where the one being dragged wont be able to fit
                    var cant_fit = [];

                    //Variables for dealing with context menu to remove fishplots/edit ploidy
                    var contextMenuShowing = false;
                    var contextMenuFor = '';
                    var contextMenuForPrevious = '';

                    //give leeway of 2px for minimum left position of mini fishplot
                    //Use jQuery because safari doesnt understand d3.select().node().left
                    var minimum_left_pos = parseInt($('#canvas_div').position().left) - 2;
                    minimum_left_pos = Math.floor(minimum_left_pos);

                    function should_update_vaf_scale(plot_background, nested_data, current_data, not_plotted) {
                        var vaf_dict = {};
                        for (var i = 0; i < sample_timepoints.length; i++) {
                            vaf_dict[sample_timepoints[i]] = [];
                        }
                        //Get total VAF plotted at each timepoint
                        for (var i = 0; i < plot_background.children.length; i++) {
                            var vaf_data = nested_data[plot_background.children[i]].values;
                            for (var j = 0; j < vaf_data.length; j++) {
                                vaf_dict[vaf_data[j].Sample_Barcode].push(vaf_data[j].alt_count);
                            }
                        }
                        //now add VAF from newly added fishplot
                        var max = 0;
                        if(not_plotted == true) {
                            for (var i = 0; i < current_data.values.length; i++) {
                                vaf_dict[current_data.values[i].Sample_Barcode].push(current_data.values[i].alt_count);
                                var sum = vaf_dict[current_data.values[i].Sample_Barcode].reduce(function (a, b) {
                                    return a + b;
                                }, 0);
                                if (sum > max) {
                                    max = sum;
                                }
                            }
                        }
                        if (not_plotted == false) {
                            for (var i = 0; i < sample_timepoints.length; i++) {
                                var sum = vaf_dict[sample_timepoints[i]].reduce(function (a, b) {
                                    return a + b;
                                }, 0);
                                if (sum > max) {
                                    max = sum;
                                }
                            }
                        }
                        if(max < 100){
                            max = 100;
                        }
                        return max;
                    }

                    function update_plot_background_values(plot_background, new_max) {
                        for (var i = 0; i < plot_background.values.length; i++) {
                            plot_background.values[i].alt_count = new_max;
                        }
                    }

                    //Make all mini fishplots opacity 1 on mouse-up of primary div
                    //Precaution for if user drags mouse too fast
                        d3.select(el).on('mousemove', function () {
                                    if (dragging == true) {
                                        var dragable_div = d3.select('#dragable_div');
                                        d3.event.preventDefault();

                                        if(navigator.userAgent.indexOf("Firefox") != -1 ){
                                            new_x_pos = d3.event.pageX;
                                            new_y_pos = d3.event.pageY;
                                        }
                                        else{
                                            new_x_pos = d3.event.x;
                                            new_y_pos = d3.event.y;
                                        }

                                        var x_difference = new_x_pos - old_x_pos;
                                        var y_difference = new_y_pos - old_y_pos;

                                        old_x_pos = new_x_pos;
                                        old_y_pos = new_y_pos;

                                        dragable_div.style('left', function () {
                                                    return parseInt(dragable_div.style('left')) + x_difference + 'px';
                                                })
                                                .style('top', function () {
                                                    return parseInt(dragable_div.style('top')) + y_difference + 'px';
                                                });
                                        dragable_div.style('pointer-events', 'none').style('cursor', 'pointer');

                                    }
                                    else {
                                        return;
                                    }
                                })
                                .on('mouseup', function () {
                                    old_x_pos = 0;
                                    old_y_pos = 0;
                                    dragging = false;
                                    var svg_index = d3.select('#dragable_div').attr('index');

                                    for (var i = 0; i < cant_fit.length; i++) {
                                        d3.select('#big_fish' + cant_fit[i])
                                                .attr('fill', canvas_nested_data[cant_fit[i]].color);
                                    }

                                    cant_fit = [];

                                    var mini_fishplot = d3.select('#dragable_div');
                                    var mini_fishplot_left = parseInt(mini_fishplot.style('left'));

                                    //If the mini fishplot is dragged over the canvas background
                                    //center the starting y value at the middle of the mini fishplot div
                                    var half_height = mini_fishplot.node().clientHeight / 2;
                                    var mini_fishplot_top = mini_fishplot.style('top');
                                    var start = parseInt(mini_fishplot_top) + half_height;

                                    start = canvas_y_scale.invert(start);

                                    if ((mini_fishplot_left + left_adjustment) > minimum_left_pos) {
                                        d3.select(el).style('cursor', 'default');

                                        if (moused_over == 'canvas_svg') {

                                            var nested_data = canvas_nested_data.slice(0);

                                            var data_index = mini_fishplot.attr('index');

                                            var data = nested_data[data_index];

                                            max_VAF_value = should_update_vaf_scale(plot_background, nested_data, data, true);
                                            canvas_y_scale.domain([max_VAF_value+1, -1]);
                                            if(max_VAF_value > plot_background.values[0].alt_count){
                                                update_plot_background_values(plot_background, max_VAF_value);
                                            }

                                            var fit = can_fit(nested_data, plot_background, data, num_of_timepoints);

                                            //If it can fit, plot it and re-adjust all other independent clonal evolutions
                                            if (fit) {

                                                svg_index = mini_fishplot.attr('index');

                                                d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                                d3.select('#mini_fishplot_div' + svg_index).style('opacity', 0.35);
                                                d3.select('#dragable_div').remove();

                                                data.start_point = start;
                                                data.group = groups.length;
                                                data.parent_index_of_this = 'plot';

                                                //Re-do top and bottom based on start position from mousedown
                                                for (var i = 0; i < num_of_timepoints; i++) {
                                                    data.values[i].top = data.start_point + (data.values[i].alt_count / 2);
                                                    data.values[i].bottom = data.start_point - (data.values[i].alt_count / 2);
                                                }

                                                groups.push(data.group);
                                                if (plot_background.groups[data.group.toString()] == undefined) {
                                                    plot_background.groups[data.group.toString()] = data_index;
                                                }

                                                plot_background.children.push(parseInt(data_index));

                                                plot_background.children.sort(function (a, b) {
                                                    return nested_data[a].start_point - nested_data[b].start_point;
                                                });

                                                fishplot_svgs.push(parseInt(data_index));
                                                scope.$apply(function () {
                                                    scope.$parent.plotted = fishplot_svgs;
                                                });

                                                canvas_nested_data[data_index] = JSON.parse(JSON.stringify(data));

                                                //Create shallow copy for values of each fishplot used
                                                //Prevents find_origin() function from permanently trimming allele values
                                                update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                                for (var i = 0; i < plot_background.children.length; i++) {
                                                    var parent = nested_data[plot_background.children[i]];
                                                    var start_point = parent.start_point;
                                                    nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, max_VAF_value, 'alt_count');
                                                }

                                                adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'alt_count', max_VAF_value);

                                                //Retain a complete nested data, that doesnt affect canvas_nested_data, to be used when
                                                //determining CCF solutions
                                                var complete_nested_data = canvas_nested_data.slice(0);

                                                nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                                //collision detection for children after adjusting the independent evolution positions
                                                nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'alt_count');

                                                //load pinches
                                                //Have to use fishplot svgs to select specific indices of nested_data
                                                //Otherwise, we prematurely clip off the origin of fishplots starting after
                                                //The first timepoint (i.e. Pretreatment in example file)
                                                for (var i = 0; i < fishplot_svgs.length; i++) {
                                                    var current_allele = nested_data[i];
                                                    for (var j = 0; j < current_allele.values.length; j++) {
                                                        //Initialize all pinches to false
                                                        //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                                        current_allele.values[j].pinch = false;
                                                    }
                                                    current_allele.values = find_origin(current_allele);
                                                }

                                                remove_unnecessary_values(nested_data);

                                                d3.selectAll('.big_fish').remove();


                                                for (var i = 0; i < nested_data.length; i++) {
                                                    var current_data = nested_data[i];

                                                    canvas_svg.append('path')
                                                            .attr('fill', 'none')
                                                            .attr('stroke-width', 5)
                                                            .attr("stroke", "transparent")
                                                            .attr('class', 'big_fish')
                                                            .style("stroke-linejoin", "round")
                                                            .attr('d', function () {
                                                                return canvas_top_line_gen(current_data.values);
                                                            });

                                                    canvas_svg.append('path')
                                                            .attr('fill', 'none')
                                                            .attr("stroke", "transparent")
                                                            .style("stroke-linejoin", "round")
                                                            .attr('class', 'big_fish')
                                                            .attr('stroke-width', 8)
                                                            .attr('d', function () {
                                                                return canvas_bottom_line_gen(current_data.values);
                                                            });

                                                    canvas_svg.append('path')
                                                            .datum(current_data.values)
                                                            .attr('fill', current_data.color)
                                                            .attr('opacity', 1)
                                                            .attr('class', 'big_fish dropdown-toggle')
                                                            .attr('d', canvas_area_between_lines)
                                                            .attr('index', current_data.index)
                                                            .attr('id', 'big_fish' + current_data.index)
                                                            .style('cursor', 'pointer')
                                                            .on('mouseenter', function (d) {
                                                                moused_over = parseInt(d3.select(this).attr('index'));
                                                            })
                                                            .on('mouseover', function(){
                                                                moused_over = parseInt(d3.select(this).attr('index'));
                                                            })
                                                            .on('mouseleave', function () {
                                                                d3.select(this).attr('opacity', 1);
                                                            })
                                                            .on('contextmenu', function () {
                                                                contextMenuFor = parseInt(d3.select(this).attr('index'));

                                                                //give the button an attribute to reference the fishplots they're dealing with
                                                                //now we can invoke a function on click
                                                                d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                                                d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                                                if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                                                    contextMenuShowing = false;
                                                                }
                                                                if (contextMenuShowing == false) {
                                                                    contextMenuForPrevious = contextMenuFor;
                                                                    d3.event.preventDefault();
                                                                    d3.select('#context-div').attr('cm-showing', 'true');
                                                                    contextMenuShowing = true;
                                                                    d3.select('#context-div').style('left', function () {
                                                                                var left = d3.event.pageX;
                                                                                return left + 'px';
                                                                            })
                                                                            .style('top', function () {
                                                                                //-75 pixels because of navbar padding
                                                                                var top = d3.event.pageY - 75;
                                                                                return top + 'px';
                                                                            })
                                                                            .style('z-index', 10)
                                                                            .style('opacity', 1);
                                                                }
                                                                else {
                                                                    d3.event.preventDefault();
                                                                    contextMenuShowing = false;
                                                                    d3.select('#context-div').attr('cm-showing', 'false');
                                                                    d3.select('#context-div').style('opacity', 0)
                                                                            .style('z-index', -1);
                                                                }
                                                            });
                                                }

                                            }
                                            else {
                                                setTimeout(function () {
                                                    var index = d3.select('#dragable_div').attr('index');
                                                    d3.select('#fishplot_area' + index).attr('opacity', 1);
                                                }, 500);
                                                d3.select('#dragable_div').transition()
                                                        .duration(500)
                                                        .style('top', top_in_container)
                                                        .style('left', left_in_container)
                                                        .remove();
                                            }
                                        }
                                        else {
                                            nested_data = canvas_nested_data.slice(0);

                                            var parent_of_this = moused_over;

                                            parent = nested_data[parent_of_this];

                                            data_index = mini_fishplot.attr('index');

                                            data = nested_data[data_index];

                                            data.start_point = start;
                                            data.group = parent.group;
                                            data.values[0].start_point = start;
                                            data.parent_index_of_this = parseInt(parent_of_this);
                                            data.ploidy = parent.ploidy;

                                            d3.select('#ploidy_text' + data_index).text(function () {
                                                return 'Ploidy: ' + data.ploidy;
                                            });


                                            //If it can git, make it a child of the current fishplot
                                            //And re-adjust everything that has already been plotted
                                            fit = can_fit(nested_data, parent, data, num_of_timepoints);

                                            if (fit) {

                                                svg_index = mini_fishplot.attr('index');
                                                d3.selectAll('.fishplot_areas').attr('opacity', 1);

                                                d3.select('#mini_fishplot_div' + svg_index).style('opacity', 0.35);
                                                d3.select('#dragable_div').remove();

                                                fishplot_svgs.push(parseInt(data_index));
                                                scope.$apply(function () {
                                                    scope.$parent.plotted = fishplot_svgs;
                                                });

                                                //Re-do top and bottom based on start position of parent
                                                for (var i = 0; i < num_of_timepoints; i++) {
                                                    data.values[i].top = data.start_point + (data.values[i].alt_count / 2);
                                                    data.values[i].bottom = data.start_point - (data.values[i].alt_count / 2);
                                                }

                                                //Add the current fish as a subclone
                                                parent.children.push(parseInt(data.index));
                                                parent.children.sort(function (a, b) {
                                                    return canvas_nested_data[a].start_point
                                                            - canvas_nested_data[b].start_point;
                                                });

                                                canvas_nested_data[data_index] = JSON.parse(JSON.stringify(data));

                                                //Create shallow copy for values of each fishplot used
                                                //Prevents find_origin function from permanently trimming allele values
                                                update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                                for (var i = 0; i < plot_background.children.length; i++) {
                                                    parent = nested_data[plot_background.children[i]];
                                                    start_point = parent.start_point;
                                                    nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, max_VAF_value, 'alt_count');
                                                }

                                                adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'alt_count', max_VAF_value);

                                                //Retain a complete nested data, that doesnt affect canvas_nested_data, to be used when
                                                //determining CCF solutions
                                                var complete_nested_data = canvas_nested_data.slice(0);

                                                nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                                //collision detection for children after adjusting the independent evolution positions
                                                nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'alt_count');

                                                set_new_start_point(canvas_nested_data, nested_data, fishplot_svgs, parent.children);

                                                for (var i = 0; i < nested_data.length; i++) {
                                                    current_allele = nested_data[i];
                                                    for (var j = 0; j < current_allele.values.length; j++) {
                                                        //Initialize all pinches to false
                                                        //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                                        current_allele.values[j].pinch = false;
                                                    }
                                                    current_allele.values = find_origin(current_allele);
                                                }

                                                remove_unnecessary_values(nested_data);


                                                d3.selectAll('.big_fish').remove();

                                                for (var i = 0; i < nested_data.length; i++) {
                                                    current_data = nested_data[i];

                                                    canvas_svg.append('path')
                                                            .attr('fill', 'none')
                                                            .attr('stroke-width', 5)
                                                            .attr("stroke", "transparent")
                                                            .attr('class', 'big_fish')
                                                            .style("stroke-linejoin", "round")
                                                            .attr('d', function () {
                                                                return canvas_top_line_gen(current_data.values);
                                                            });

                                                    canvas_svg.append('path')
                                                            .attr('fill', 'none')
                                                            .attr("stroke", "transparent")
                                                            .style("stroke-linejoin", "round")
                                                            .attr('class', 'big_fish')
                                                            .attr('stroke-width', 8)
                                                            .attr('d', function () {
                                                                return canvas_bottom_line_gen(current_data.values);
                                                            });

                                                    canvas_svg.append('path')
                                                            .datum(current_data.values)
                                                            .attr('fill', current_data.color)
                                                            .attr('opacity', 1)
                                                            .attr('class', 'big_fish dropdown-toggle')
                                                            .attr('d', canvas_area_between_lines)
                                                            .attr('index', current_data.index)
                                                            .attr('id', 'big_fish' + current_data.index)
                                                            .style('cursor', 'pointer')
                                                            .on('mouseenter', function (d) {
                                                                moused_over = parseInt(d3.select(this).attr('index'));
                                                            })
                                                            .on('mouseover', function(){
                                                                moused_over = parseInt(d3.select(this).attr('index'));
                                                            })
                                                            .on('mouseleave', function () {
                                                                d3.select(this).attr('opacity', 1);
                                                            })
                                                            .on('contextmenu', function () {
                                                                contextMenuFor = parseInt(d3.select(this).attr('index'));

                                                                //give the button an attribute to reference the fishplots they're dealing with
                                                                //now we can invoke a function on click
                                                                d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                                                d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                                                if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                                                    contextMenuShowing = false;
                                                                }
                                                                if (contextMenuShowing == false) {
                                                                    contextMenuForPrevious = contextMenuFor;
                                                                    d3.event.preventDefault();
                                                                    contextMenuShowing = true;
                                                                    d3.select('#context-div').attr('cm-showing', 'true');
                                                                    d3.select('#context-div').style('left', function () {
                                                                                var left = d3.event.pageX;
                                                                                return left + 'px';
                                                                            })
                                                                            .style('top', function () {
                                                                                //-75 pixels because of navbar padding
                                                                                var top = d3.event.pageY - 75;
                                                                                return top + 'px';
                                                                            })
                                                                            .style('z-index', 10)
                                                                            .style('opacity', 1);
                                                                }
                                                                else {
                                                                    d3.event.preventDefault();
                                                                    contextMenuShowing = false;
                                                                    d3.select('#context-div').attr('cm-showing', 'false');
                                                                    d3.select('#context-div').style('opacity', 0)
                                                                            .style('z-index', -1);
                                                                }
                                                            });
                                                }
                                            }
                                            else {
                                                setTimeout(function () {
                                                    var index = d3.select('#dragable_div').attr('index');
                                                    d3.select('#fishplot_area' + index).attr('opacity', 1);
                                                }, 500);

                                                d3.select('#dragable_div').transition()
                                                        .duration(500)
                                                        .style('top', top_in_container)
                                                        .style('left', left_in_container)
                                                        .remove();
                                            }
                                        }
                                    }
                                    else {
                                        setTimeout(function () {
                                            var index = d3.select('#dragable_div').attr('index');
                                            d3.select('#fishplot_area' + index).attr('opacity', 1);
                                        }, 500);

                                        d3.select('#dragable_div').transition()
                                                .duration(500)
                                                .style('top', top_in_container)
                                                .style('left', left_in_container)
                                                .remove();

                                    }
                                    return;
                                });

                    //dirty fish to preventing blank mini fishplots
                    d3.select('body')
                            .on('mouseup', function () {
                                for (var i = 0; i < cant_fit.length; i++) {
                                    d3.select('#big_fish' + cant_fit[i])
                                            .attr('fill', canvas_nested_data[cant_fit[i]].color);
                                }
                                setTimeout(function () {
                                    d3.select('#dragable_div').remove();
                                    d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                }, 500);
                            });

                    d3.select(el).on('click', function(){
                        contextMenuShowing = false;
                        d3.select('#context-div').attr('cm-showing', 'false');
                        d3.select('#context-div').style('opacity', 0)
                                .style('z-index', -1);
                    });

                    //Save the current configuration of the fishplots
                    var save_fishplot_div_height = 30;
                    var save_fishplot_div_top = d3.select(el).node().clientHeight;
                    var save_fishplot_top_padding = 0.10; //pad the top by 10 percent

                    var save_fishplot_div_wrapper = d3.select('#figure6-wrapper')
                            .append('div')
                            .attr('id', 'save_fishplot_div_wrapper')
                            .style('top', save_fishplot_div_top + 'px')
                            .style('height', save_fishplot_div_height + 'px')
                            .style('width', '100%')
                            .style('float', 'left')
                            .style('padding-top', function () {
                                return (d3.select(this).node().clientHeight * save_fishplot_top_padding) + 'px';
                            });

                    var save_fishplot_div = save_fishplot_div_wrapper.append('div')
                            .attr('id', 'save_fishplot_div')
                            .style('top', '0px')
                            .style('left', '0px')
                            .style('width', '100%')
                            .style('height', '100%')
                            .style('float', 'right');

                    var save_fishplot_button = save_fishplot_div.append('button')
                            .attr('class', 'btn btn-default btn-sm')
                            .attr('id', 'save_fishplot_button')
                            .html('Save Fishplot')
                            .on('click', function(){
                                $("#save_fishplot_modal").modal('show');
                            });

                    //update the save_fishplot_div to move button to the right
                    d3.select('#save_fishplot_div').style('left', function () {
                                var button_width = d3.select('#save_fishplot_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#save_fishplot_button').style('padding-left')) * 2;
                                button_width = button_width + parseInt(d3.select('#save_fishplot_button').style('padding-right')) * 2;
                                var canvas_left = d3.select('#canvas_div').node().offsetLeft;
                                var canvas_width = d3.select('#canvas_div').node().offsetWidth;
                                var canvas_right = canvas_left + canvas_width;
                                var new_div_left = canvas_right - button_width;
                                return new_div_left + 'px';
                            })
                            .style('width', function () {
                                var button_width = d3.select('#save_fishplot_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#save_fishplot_button').style('padding-left'));
                                button_width = button_width + parseInt(d3.select('#save_fishplot_button').style('padding-right'));
                                var margin = parseInt(d3.select('#save_fishplot_button').style('margin'));
                                if(Number.isInteger(margin) == true) {
                                    button_width = button_width + margin;
                                }

                                return button_width + 'px';
                            });

                    function name_exists(name, names_array){
                        if(names_array.indexOf(name) == -1){
                            return false
                        }
                        else {
                            return true;
                        }
                    }

                    //Function to save the fishplot
                    d3.select('#save_as_fishplot_button')
                            .on('click', function () {
                                var name = d3.select('#save_fishplot_as').node().value;
                                var subject_id = scope.$parent.subject_id;
                                var params_dict = {
                                    subject_id: subject_id,
                                    name: name,
                                    used_data_indices: fishplot_svgs,
                                    data: canvas_nested_data
                                };


                                if(fishplot_svgs.length < 1){
                                    d3.select('#dialog-header')
                                            .style('color', 'red');
                                    d3.select('#dialog-header').html('Error!');

                                    d3.select('#dialog-body').html('');
                                    d3.select('#dialog-body')
                                            .append('p')
                                            .html(function () {
                                                return 'The fishplot <b>' + name + '</b> did not save. Nothing has been plotted.';
                                            });

                                    $('#saved-fishplot-dialog-box').modal('show');
                                    return;
                                }

                                var exists = name_exists(name, scope.$parent.saved_fishplot_names);

                                if(exists == true){
                                    d3.select('#dialog-header')
                                            .style('color', 'red');
                                    d3.select('#dialog-header').html('Error!');

                                    d3.select('#dialog-body').html('');
                                    d3.select('#dialog-body')
                                            .append('p')
                                            .html(function () {
                                                return 'The fishplot <b>' + name + '</b> already exists. Please try another name.';
                                            });

                                    $('#saved-fishplot-dialog-box').modal('show');
                                    return;
                                }

                                if(fishplot_svgs.length > 0 && exists == false) {
                                    $http({
                                        url: '../data/save_fishplot/',
                                        method: 'POST',
                                        data: params_dict
                                    }).success(function () {
                                                d3.select('#dialog-header')
                                                        .style('#ffffff');
                                                d3.select('#dialog-header').html('Save Successful');

                                                d3.select('#dialog-body').html('');
                                                d3.select('#dialog-body')
                                                        .append('p')
                                                        .html(function () {
                                                            return 'The fishplot <b>' + name + '</b> was saved successfully.';
                                                        });

                                                //update parent scope that holds the array of already used names
                                                scope.$parent.saved_fishplot_names.push(name);

                                                $('#saved-fishplot-dialog-box').modal('show');
                                            })
                                            .error(function () {
                                                d3.select('#dialog-header')
                                                        .style('color', 'red');
                                                d3.select('#dialog-header').html('Error!');

                                                d3.select('#dialog-body').html('');
                                                d3.select('#dialog-body')
                                                        .append('p')
                                                        .html(function () {
                                                            return 'The fishplot <b>', +name + '</b> did not save.';
                                                        });

                                                $('#saved-fishplot-dialog-box').modal('show');
                                            });
                                }

                            });

                    //Most of the code below pertains to the mini fishplot div information

                    //Cog wheel glyph icon
                    svgs.append('svg:image')
                            .attr('x', mini_x_range_max*0.01)
                            .attr('y', mini_fishplot_container_height*0.85)
                            .attr('width',  mini_fishplot_container_height*0.15)
                            .attr('height', mini_fishplot_container_height*0.15)
                            .attr('id', 'cog_wheel')
                            .attr('cursor', 'pointer')
                            .attr('xlink:href', 'https://cdn1.iconfinder.com/data/icons/trycons/32/settings-512.png')
                            .on('click', function(d, i){
                                //return if the fishplot of this allele has already been plotted
                                if(fishplot_svgs.indexOf(i) != -1){
                                    return;
                                }
                                d3.select('#dragable_div').remove();
                                var ploidy_num = d3.select('#ploidy_text' + i).node().innerHTML.split(' ')[1];
                                d3.select('#ploidy_input').node().value = ploidy_num;
                                d3.select('#ploidy_input').attr('fishplot_index', i);

                                $("#exampleModal").modal('show');

                            });

                    svgs.append('svg:image')
                            .attr('x', mini_x_range_max*0.10)
                            .attr('y', mini_fishplot_container_height*0.85)
                            .attr('width', mini_fishplot_container_height*0.15)
                            .attr('height', mini_fishplot_container_height*0.14)
                            .attr('id', 'infolight')
                            .attr('cursor', 'pointer')
                            .attr('index', function(d, i){
                                return i;
                            })
                            .attr('xlink:href',
                                    'https://cdn0.iconfinder.com/data/icons/seo-web-15/130/seo-social-web-network-internet_186-128.png')
                            .on('click', function(d, i){
                                d3.select('#gene-info-table').remove();
                                d3.select('#gene-info-modal-header-title').html('');
                                d3.select('#gene-info-modal-header-title').html(d.values[0].allele + ' ' + 'Gene Information');

                                var info = ['chromosome', 'position', 'type', 'cDNA', 'ref_seq', 'reference', 'alternative',
                                    'patients with gene'];
                                var table_data = [];
                                for(var i = 0; i < info.length; i++){
                                    table_data.push({
                                        name: info[i],
                                        value: d[info[i]]
                                    });
                                }


                                var table = d3.select('#gene-info-modal-body').append('table')
                                        .attr('id', 'gene-info-table')
                                        .attr('class', 'table');

                                var thead = table.append('thead').append('tr');
                                thead.append('th').html('Parameter');
                                thead.append('th').html('Value');

                                var tbody = table.append('tbody').attr('id', 'tbody-gene-info-table');

                                var rows = tbody.selectAll('gene-info')
                                        .data(table_data)
                                        .enter()
                                        .append('tr');

                                rows.append('td')
                                        .html(function(d){
                                           return d.name;
                                        });

                                rows.append('td')
                                        .html(function(d){
                                            return d.value;
                                        });

                                 $('#gene-info-modal').modal('show');

                            });

                    //Mini fishplot divs in scroll container
                    svgs.append('path')
                            .attr('id', function (d, i) {
                                        return 'fishplot_area' + i
                            })
                            .attr('fill', 'none')
                            .attr('stroke-width', 5)
                            .attr("stroke", "transparent")
                            .style("stroke-linejoin", "round")
                            .attr('d', function (d) {
                                return top_line_gen(d.values);
                            });

                    svgs.append('path')
                            .attr('id', function (d, i) {
                                        return 'fishplot_area' + i
                            })
                            .attr('fill', 'none')
                            .attr("stroke", "transparent")
                            .style("stroke-linejoin", "round")
                            .attr('stroke-width', 8)
                            .attr('d', function (d) {
                                return bottom_line_gen(d.values);
                            });

                    //difference between edge of mini fishplot div, and where fishplot fill starts
                    var left_adjustment = 0;


                    svgs.append('path')
                            .attr('id', function(d, i){
                                return 'fishplot_area'+i;
                            })
                            .attr('opacity', 1)
                            .attr('fill', function (d) {
                                return d.color;
                            })
                            .datum(function (d) {
                                return d.values;
                            })
                            .attr('d', area_between_lines)
                            .attr('class', 'fishplot_areas')
                            .attr('cursor', 'pointer')
                            .on('mousedown', function (d, i) {
                                d3.event.preventDefault();
                                d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                var div_id = '#mini_fishplot_div' + i;
                                var svg_id = '#mini_fishplot_svg' + i;
                                var mini_fishplot = d3.select(svg_id);

                                //get svg info for clone
                                var dragable_div_content = mini_fishplot.node().outerHTML;

                                //Calculate top based on the top of the mini fishplot div and how far user scrolled
                                top_in_container = parseInt(d3.select(div_id).style('top')) - d3.select('#container_div').node().scrollTop;
                                top_in_container = top_in_container + 'px';
                                left_in_container = d3.select(div_id).style('left');
                                var width = d3.select(div_id).style('width');
                                var height = d3.select(div_id).style('height');

                                //remove any clones that are already layed down, if any at all
                                //Some may be left behind if user moves mouse rapdily
                                d3.selectAll('#dragable_div').remove();

                                if(fishplot_svgs.indexOf(i) != -1){
                                    return;
                                }

                                for(var j=0; j<fishplot_svgs.length; j++) {
                                    var plotted_data = canvas_nested_data[fishplot_svgs[j]];
                                    var data = canvas_nested_data[i];
                                    var fit = can_fit(canvas_nested_data, plotted_data, data, num_of_timepoints);
                                    if(!fit){
                                        cant_fit.push(fishplot_svgs[j]);
                                        d3.select('#big_fish'+ plotted_data.index)
                                                .attr('fill', '#262626');
                                    }
                                }

                                var dragable_div = dragable_div_wrapper.append('div')
                                        .style('top', top_in_container)
                                        .style('left', left_in_container)
                                        .style('width', width)
                                        .style('height', height)
                                        .style('position', 'absolute')
                                        .style('cursor', 'pointer')
                                        .html(dragable_div_content)
                                        .attr('index', i)
                                        .attr('z-index', 10)
                                        .attr('id', 'dragable_div');

                                d3.select('#dragable_div').selectAll('.info_text').remove();
                                d3.select('#dragable_div').selectAll('.info_lines').remove();

                                //remove cog wheel
                                d3.select('#dragable_div').select('#cog_wheel').remove();
                                d3.select('#dragable_div').select('#infolight').remove();

                                var bounding = d3.select('#fishplot_area' + i).node().getBoundingClientRect();
                                left_adjustment = bounding.left - parseInt(left_in_container);

                                  if(navigator.userAgent.indexOf("Firefox") != -1 ){
                                            old_x_pos = d3.event.pageX;
                                            old_y_pos = d3.event.pageY;
                                        }
                                        else{
                                            old_x_pos = d3.event.x;
                                            old_y_pos = d3.event.y;
                                        }

                                dragging = true;
                                d3.select(this).attr('opacity', 0);

                                d3.select('#dragable_div').style('pointer-events', 'none')
                                        //give mouseup remove functionality
                                        .on('mouseup', function(){
                                           d3.select(this).remove();
                                        });
                                d3.select(el).style('cursor', 'pointer');

                            });


                    //Ploidy and Chrs Affected table configuration
                    svgs.append('text')
                            .attr('x', function(d, i){
                                //use jQuery again because d3.select().node().clientWidth doesnt work
                                var center = $('#mini_fishplot_svg'+i).width()/2;
                                return center + 'px';
                            })
                            .attr('y', '155px')//if it were a formula this would be 15.5/16 using container height = 160
                            .text(function(d){
                               return d.key;
                            })
                            .attr('font-size', '15px')
                            .attr('text-anchor', 'middle')
                            .attr('class', 'noselect info_text');

                    svgs.append('text')
                            .attr('x', function(d, i){
                                //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                var center = $('#mini_fishplot_svg'+i).width()/3;
                                center = center * 0.5; //cut in half, then cut in half again
                                return center + 'px';
                            })
                            .attr('y', '15px')
                            .text(function(){
                                return 'Chrs Affected: ' + 'N/A';
                            })
                            .attr('font-size', '12px')
                            .attr('text-anchor', 'middle')
                            .attr('id', function(d, i){
                                return 'chrs_aff_text'+i;
                            })
                            .attr('class', 'noselect info_text');

                    svgs.append('text')
                            .attr('x', function(d, i){
                                //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                var center = $('#mini_fishplot_svg'+i).width()/3;
                                center = center * 1.5; //cut in half, then cut in half again
                                return center + 'px';
                            })
                            .attr('y', '15px')
                            .text(function(d){
                                return 'Chr: ' + d.chromosome;
                            })
                            .attr('font-size', '12px')
                            .attr('text-anchor', 'middle')
                            .attr('id', function(d, i){
                                return 'chr'+i;
                            })
                            .attr('class', 'noselect info_text');

                    svgs.append('text')
                            .attr('font-size', '12px')
                            .attr('text-anchor', 'middle')
                            .attr('id', function(d, i){
                                return 'ploidy_text'+i;
                            })
                            .attr('class', 'noselect info_text')
                            .attr('x', function(d, i){
                                //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                var center = $('#mini_fishplot_svg'+i).width()/3;
                                center = center * 2.5; //cut in half, then cut in half again
                                return center + 'px';
                            })
                            .attr('y', '15px')
                            .text(function(d){
                                if(d.chromosome == 'X' || d.chromosome == 'Y'){
                                    return 'Ploidy: ' + 1;
                                }
                                return 'Ploidy: ' + 2; //Will put variable for Ploidy eventually
                            });

                    //update the ploidy after the user saves the changes
                    d3.select('#save_button')
                            .on('click', function(){
                                var index =  d3.select('#ploidy_input').attr('fishplot_index');
                                var value = d3.select('#ploidy_input').node().valueAsNumber;
                                canvas_nested_data[index].ploidy = value;
                            });

                    //The code commented out below is for boxing in the chromosome/CN/ploidy text

                    {% comment %}svgs.append('line')
                            .attr('x1', '0px')
                            .attr('x2', function(d, i){
                                return d3.select('#mini_fishplot_svg'+i).node().clientWidth;
                            })
                            .attr('y1', '20px')
                            .attr('y2', '20px')
                            .attr('fill', 'none')
                            .attr('stroke', '#000000')
                            .attr('class', 'info_lines');

                    svgs.append('line')
                            .attr('x1', function(d, i){
                                return d3.select('#mini_fishplot_svg'+i).node().clientWidth/3;
                            })
                            .attr('x2', function(d, i){
                                return d3.select('#mini_fishplot_svg'+i).node().clientWidth/3;
                            })
                            .attr('y1', '0px')
                            .attr('y2', '20px')
                            .attr('stroke', '#000000')
                            .attr('class', 'info_lines');

                    svgs.append('line')
                            .attr('x1', function(d, i){
                                return (d3.select('#mini_fishplot_svg'+i).node().clientWidth/3)*2;
                            })
                            .attr('x2', function(d, i){
                                return (d3.select('#mini_fishplot_svg'+i).node().clientWidth/3)*2;
                            })
                            .attr('y1', '0px')
                            .attr('y2', '20px')
                            .attr('stroke', '#000000')
                            .attr('class', 'info_lines');{% endcomment %}


                    //Function for removing fishplot svgs from plot
                    //Removes the data from the fishplot_svgs array, which prevents them from being plotted
                    function remove_fishplot_relationships(current_fish, fishplot_svgs, canvas_nested_data) {
                        var children = current_fish.children;
                        var index = current_fish.index;

                        if (current_fish.parent_index_of_this != 'plot') {
                            var parent_index = current_fish.parent_index_of_this;
                            for(var i = 0; i < current_fish.values.length; i++){
                                delete current_fish.values[i].ccf;
                            }
                            var parent = canvas_nested_data[parent_index];
                            var child_index = parent.children.indexOf(index);
                            if (child_index > -1) {
                                parent.children.splice(child_index, 1);
                            }
                            parent.children.sort(function (a, b) {
                                return canvas_nested_data[a].start_point
                                        - canvas_nested_data[b].start_point;
                            });
                        }
                        if (children.length > 0) {
                            for (var i = 0; i < children.length; i++) {
                                index = canvas_nested_data[children[i]].index;
                                d3.select('#mini_fishplot_div' + index).style('opacity', 1);
                                var index_in_fishplot_svgs = fishplot_svgs.indexOf(index);
                                if (index_in_fishplot_svgs > -1) {
                                    fishplot_svgs.splice(index_in_fishplot_svgs, 1);
                                }
                                if(canvas_nested_data[children[i]].children.length > 0) {
                                    remove_fishplot_relationships(canvas_nested_data[children[i]], fishplot_svgs, canvas_nested_data);
                                }
                            }
                        }
                        current_fish.children = [];
                    }

                    var rmv_fishplot_btn = d3.select('#rmv-fishplot-btn').on('click', function(){
                        d3.select('#context-div').style('opacity', 0).attr('cm-showing', 'false');
                        var index = parseInt(d3.select(this).attr('fish-index'));
                        var current_fish = canvas_nested_data[index];

                        if(current_fish.parent_index_of_this == 'plot'){
                            var group_index = parseInt(current_fish.group);
                            group_index = groups.indexOf(group_index);
                            if(group_index > -1) {
                                groups.splice(group_index, 1);
                            }

                            var plot_background_group = current_fish.group.toString();
                            delete plot_background.groups[plot_background_group];

                            var child_index = plot_background.children.indexOf(index);
                            if(child_index > -1) {
                                plot_background.children.splice(child_index, 1);
                            }
                            var nested_data = canvas_nested_data.slice(0);
                            max_VAF_value = should_update_vaf_scale(plot_background, nested_data, current_fish, true);
                            canvas_y_scale.domain([max_VAF_value+1, -1]);
                            if(max_VAF_value > plot_background.values[0].alt_count){
                                update_plot_background_values(plot_background, max_VAF_value);
                            }
                        }

                        d3.select('#mini_fishplot_div' + index).style('opacity', 1);
                        var index_in_fishplot_svgs = fishplot_svgs.indexOf(index);
                        if (index_in_fishplot_svgs > -1) {
                            fishplot_svgs.splice(index_in_fishplot_svgs, 1);
                        }

                        remove_fishplot_relationships(current_fish, fishplot_svgs, canvas_nested_data);
                        scope.$apply(function () {
                            scope.$parent.plotted = fishplot_svgs;
                        });

                        nested_data = canvas_nested_data.slice(0);

                        //Create shallow copy for values of each fishplot used
                        //Prevents find_origin function from permanently trimming allele values
                        update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                        for (var i = 0; i < plot_background.children.length; i++) {
                            var parent = nested_data[plot_background.children[i]];
                            var start_point = parent.start_point;
                            nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, max_VAF_value, 'alt_count');
                        }

                        adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'alt_count', max_VAF_value);

                        //Retain a complete nested data, that doesnt affect canvas_nested_data, to be used when
                        //determining CCF solutions
                        var complete_nested_data = canvas_nested_data.slice(0);

                        nested_data = reconstruct_data(nested_data, fishplot_svgs);

                        //collision detection for children after adjusting the independent evolution positions
                        nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'alt_count');

                        //load pinches
                        //Have to use fishplot svgs to select specific indices of nested_data
                        //Otherwise, we prematurely clip off the origin of fishplots starting after
                        //The first timepoint (i.e. Pretreatment in example file)
                        for (var i = 0; i < fishplot_svgs.length; i++) {
                            var current_allele = nested_data[i];
                            for (var j = 0; j < current_allele.values.length; j++) {
                                //Initialize all pinches to false
                                //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                current_allele.values[j].pinch = false;
                            }
                            current_allele.values = find_origin(current_allele);
                        }

                        remove_unnecessary_values(nested_data);

                        d3.selectAll('.big_fish').remove();


                        for (var i = 0; i < nested_data.length; i++) {
                            var current_data = nested_data[i];

                            canvas_svg.append('path')
                                    .attr('fill', 'none')
                                    .attr('stroke-width', 5)
                                    .attr("stroke", "transparent")
                                    .attr('class', 'big_fish')
                                    .style("stroke-linejoin", "round")
                                    .attr('d', function () {
                                        return canvas_top_line_gen(current_data.values);
                                    });

                            canvas_svg.append('path')
                                    .attr('fill', 'none')
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('class', 'big_fish')
                                    .attr('stroke-width', 8)
                                    .attr('d', function () {
                                        return canvas_bottom_line_gen(current_data.values);
                                    });

                            canvas_svg.append('path')
                                    .datum(current_data.values)
                                    .attr('fill', current_data.color)
                                    .attr('opacity', 1)
                                    .attr('class', 'big_fish dropdown-toggle')
                                    .attr('d', canvas_area_between_lines)
                                    .attr('index', current_data.index)
                                    .attr('id', 'big_fish' + current_data.index)
                                    .style('cursor', 'pointer')
                                    .on('mouseenter', function (d) {
                                        moused_over = parseInt(d3.select(this).attr('index'));
                                    })
                                    .on('mouseover', function(){
                                        moused_over = parseInt(d3.select(this).attr('index'));
                                    })
                                    .on('mouseleave', function () {
                                        d3.select(this).attr('opacity', 1);
                                    })
                                    .on('contextmenu', function () {
                                        contextMenuFor = parseInt(d3.select(this).attr('index'));

                                        //give the button an attribute to reference the fishplots they're dealing with
                                        //now we can invoke a function on click
                                        d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                        d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                        if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                            contextMenuShowing = false;
                                        }
                                        if (contextMenuShowing == false) {
                                            contextMenuForPrevious = contextMenuFor;
                                            d3.event.preventDefault();
                                            d3.select('#context-div').attr('cm-showing', 'true');
                                            contextMenuShowing = true;
                                            d3.select('#context-div').style('left', function () {
                                                        var left = d3.event.pageX;
                                                        return left + 'px';
                                                    })
                                                    .style('top', function () {
                                                        //-75 pixels because of navbar padding
                                                        var top = d3.event.pageY - 75;
                                                        return top + 'px';
                                                    })
                                                    .style('z-index', 10)
                                                    .style('opacity', 1);
                                        }
                                        else {
                                            d3.event.preventDefault();
                                            contextMenuShowing = false;
                                            d3.select('#context-div').attr('cm-showing', 'false');
                                            d3.select('#context-div').style('opacity', 0)
                                                    .style('z-index', -1);
                                        }
                                    });
                        }

                        CCF_options = {};
                        load_CCF_options(CCF_options, sample_timepoints);


                    });

                    function alleles_in_CCF_options(keys) {
                        var alleles = [];
                        for (var i = 0; i < keys.length; i++) {
                            if (keys[i].includes('_chrs')) {
                                continue;
                            }
                            else {
                                alleles.push(keys[i]);
                            }
                        }
                        return alleles;
                    }


                    d3.select('#save-CCF-button')
                            .on('click', function () {
                                if (d3.select('#selected-tr').node() != null && d3.select('#selected-tr').attr('is-selected') != 0) {
                                    var data = d3.select('#selected-tr').node()['__data__'];
                                    var keys = Object.keys(data);
                                    var alleles = alleles_in_CCF_options(keys);
                                    update_variant_info(data, alleles, canvas_nested_data);
                                }
                            });

                    d3.select('#save-CCF-button-reprompt')
                            .attr('last-prompt', false)
                            .on('click', function () {
                                if (d3.select('#selected-tr').node() != null && d3.select('#selected-tr').attr('is-selected') != 0) {
                                    var data = d3.select('#selected-tr').node()['__data__'];
                                    var keys = Object.keys(data);
                                    var alleles = alleles_in_CCF_options(keys);
                                    update_variant_info(data, alleles, canvas_nested_data);
                                    var index = parseInt(d3.select(this).attr('index'));
                                    var last_prompt = d3.select(this).attr('last-prompt');
                                    if(last_prompt == 'false' || last_prompt ==false) {
                                        var index = index + 1;
                                    }
                                    var complete_nested_data = canvas_nested_data.slice(0);
                                    var type = d3.select(this).attr('type');
                                    d3.select(this).attr('from-button', true);

                                    reprompt(sample_timepoints, tick_labels, canvas_nested_data, ten_percent_below_zero,
                                            complete_nested_data, plot_background, allele_color_reference, fishplot_svgs, index,
                                            canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                                            contextMenuShowing, contextMenuForPrevious, type, canvas_svg, num_of_timepoints, max_VAF_value);
                                }
                            });

                    var load_fishplot_div = d3.select('#save_fishplot_div_wrapper').append('div')
                            .attr('id', 'load_fishplot_div')
                            .style('top', '0px')
                            .style('height', '100%')
                            .style('float', 'right');

                    load_fishplot_div.append('button')
                            .attr('id', 'load_fishplot_button')
                            .attr('class', 'btn btn-default btn-sm')
                            .html('Load fishplot')
                            .on('click', function(){
                                var subject_id = scope.$parent.subject_id;

                                d3.select('#get-fishplot-modal-body').html('');

                                $http.get('../api/v1/saved_fishplot_subject_ids/').success(function(data){
                                    data = $filter('filter')(data, {'subject_id': subject_id})[0];

                                    d3.select('#get-fishplot-modal-body').html('');
                                    d3.select('#get_fishplot_button').html('Choose');

                                    if(data != undefined) {
                                        //save data to figure6 scope, so we can access it once the user chooses it
                                        data = data.saved_as;
                                        scope.loaded_data = data;

                                        //get all of the options (names they were saved as), and put in a select dropdown
                                        var select = d3.select('#get-fishplot-modal-body').append('select')
                                                .attr('id', 'select-list')
                                                .attr('class', 'form-control');

                                        var placeholder = select.append('option')
                                                .append('attr', 'selected')
                                                .append('attr', 'disabled')
                                                .html('Select a fishplot');

                                        var options = select.selectAll('saved_names')
                                                .data(data)
                                                .enter()
                                                .append('option')
                                                .html(function (d) {
                                                    return d.name;
                                                });

                                        $('#get_fishplot_modal').modal('show');
                                    }
                                    else{
                                        d3.select('#get_fishplot_button').html('Okay');
                                        d3.select('#get-fishplot-modal-body')
                                                .append('p')
                                                .html('There are no recorded fishplots for this patient.');

                                        $('#get_fishplot_modal').modal('show');
                                    }
                                });
                            });

                            d3.select('#get_fishplot_button')
                            .on('click', function(){
                                var name = $('#select-list').val();
                                var subject_fishplots = scope.loaded_data;
                                var fishplot_data = null;
                                for(var i = 0; i < subject_fishplots.length; i++){
                                    if(subject_fishplots[i].name == name){
                                        fishplot_data = subject_fishplots[i];
                                        if(fishplot_data.data[0].parent_index_of_this != "plot"){
                                            fishplot_data.data = fishplot_data.data.reverse();
                                            if(fishplot_data.data[0].timepoint_data[0].Sample_Barcode > 0 || fishplot_data.data[0].timepoint_data[0].Sample_Barcode != 'origin'){
                                                for(var j = 0; j < fishplot_data.data.length; j++){
                                                    fishplot_data.data[j].timepoint_data.reverse();
                                                }
                                            }

                                        }
                                    }
                                }
                                if(fishplot_data == null){
                                    return;
                                }
                                fishplot_svgs = [];
                                groups = [];
                                plot_background.groups = {};
                                plot_background.children = [];
                                d3.selectAll('.mini_fishplot_divs').style('opacity', 1);

                                for(var i = 0; i < fishplot_data.data.length; i++){
                                    fishplot_svgs.unshift(parseInt(fishplot_data.data[i].index));
                                    d3.select('#mini_fishplot_div' + fishplot_data.data[i].index).style('opacity', 0.35);
                                    var current_fish = canvas_nested_data[fishplot_data.data[i].index];
                                    var mini_current_fish = mini_nested_data[fishplot_data.data[i].index];
                                    current_fish.children = [];
                                    current_fish.group = fishplot_data.data[i].group;
                                    current_fish.ploidy = fishplot_data.data[i].ploidy;
                                    mini_current_fish.ploidy = fishplot_data.data[i].ploidy;
                                    current_fish.start_point = fishplot_data.data[i].start_point;
                                    current_fish.chrs_affected = fishplot_data.data[i].chrs_affected;
                                    mini_current_fish.chrs_affected = fishplot_data.data[i].chrs_affected;

                                    //Re-do top and bottom based on start position from mousedown
                                    for (var j = 0; j < current_fish.values.length; j++) {
                                        current_fish.values[j].alt_count = fishplot_data.data[i].timepoint_data[j].alt_count;
                                        mini_current_fish.values[j].alt_count = fishplot_data.data[i].timepoint_data[j].alt_count;
                                        current_fish.values[j].top = fishplot_data.data[i].timepoint_data[j].top;
                                        current_fish.values[j].bottom = fishplot_data.data[i].timepoint_data[j].bottom;
                                    }
                                    if(fishplot_data.data[i].parent_index_of_this != 'plot'){
                                        current_fish.parent_index_of_this = parseInt(fishplot_data.data[i].parent_index_of_this);
                                        canvas_nested_data[parseInt(fishplot_data.data[i].parent_index_of_this)].children.push(fishplot_data.data[i].index);
                                    }
                                    if(fishplot_data.data[i].parent_index_of_this == 'plot' || fishplot_data.data[i].parent_index_of_this == 'none'){
                                        groups.push(fishplot_data.data[i].group);
                                        plot_background.groups[fishplot_data.data[i].group.toString()] = fishplot_data.data[i].index;
                                        plot_background.children.push(fishplot_data.data[i].index);
                                        current_fish.parent_index_of_this = "plot";
                                    }
                                    canvas_nested_data[fishplot_data.data[i].index] = JSON.parse(JSON.stringify(current_fish));

                                }

                                fishplot_svgs.reverse();
                                scope.$apply(function() {
                                                scope.$parent.plotted = fishplot_svgs;
                                                scope.$parent.updated_editor_info = mini_nested_data;
                                                scope.$parent.loaded_fishplot_data = canvas_nested_data;
                                            });

                                var temp_nested_data = JSON.parse(JSON.stringify(canvas_nested_data));
                                var nested_data = nested_data = JSON.parse(JSON.stringify(canvas_nested_data));

                                max_VAF_value = should_update_vaf_scale(plot_background, temp_nested_data, data, false);
                                canvas_y_scale.domain([max_VAF_value+1, -1]);
                                if (max_VAF_value > plot_background.values[0].alt_count) {
                                    update_plot_background_values(plot_background, max_VAF_value);
                                }

                                plot_background.children.sort(function (a, b) {
                                    return nested_data[a].start_point - nested_data[b].start_point;
                                });

                                //Create shallow copy for values of each fishplot used
                                //Prevents find_origin function from permanently trimming allele values
                                update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                for (var i = 0; i < plot_background.children.length; i++) {
                                    var parent = nested_data[plot_background.children[i]];
                                    var start_point = parent.start_point;
                                    nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, max_VAF_value, 'alt_count');
                                }

                                adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'alt_count', max_VAF_value);
{##}
                                set_new_start_point(canvas_nested_data, nested_data, fishplot_svgs, parent.children);

                                //Retain a complete nested data, that doesnt affect canvas_nested_data, to be used when
                                //determining CCF solutions
                                var complete_nested_data = canvas_nested_data.slice(0);

                                nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                //collision detection for children after adjusting the independent evolution positions
                                nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'alt_count');

                                //load pinches
                                //Have to use fishplot svgs to select specific indices of nested_data
                                //Otherwise, we prematurely clip off the origin of fishplots starting after
                                //The first timepoint (i.e. Pretreatment in example file)
                                for (var i = 0; i < fishplot_svgs.length; i++) {
                                    var current_allele = nested_data[i];
                                    for (var j = 0; j < current_allele.values.length; j++) {
                                        //Initialize all pinches to false
                                        //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                        current_allele.values[j].pinch = false;
                                    }
                                    current_allele.values = find_origin(current_allele);
                                }

                                remove_unnecessary_values(nested_data);

                                d3.selectAll('.big_fish').remove();

                                for (var i = 0; i < nested_data.length; i++) {
                                    var current_data = nested_data[i];

                                    canvas_svg.append('path')
                                            .attr('fill', 'none')
                                            .attr('stroke-width', 5)
                                            .attr("stroke", "transparent")
                                            .attr('class', 'big_fish')
                                            .style("stroke-linejoin", "round")
                                            .attr('d', function () {
                                                return canvas_top_line_gen(current_data.values);
                                            });

                                    canvas_svg.append('path')
                                            .attr('fill', 'none')
                                            .attr("stroke", "transparent")
                                            .style("stroke-linejoin", "round")
                                            .attr('class', 'big_fish')
                                            .attr('stroke-width', 8)
                                            .attr('d', function () {
                                                return canvas_bottom_line_gen(current_data.values);
                                            });

                                    canvas_svg.append('path')
                                            .datum(current_data.values)
                                            .attr('fill', current_data.color)
                                            .attr('opacity', 1)
                                            .attr('class', 'big_fish dropdown-toggle')
                                            .attr('d', canvas_area_between_lines)
                                            .attr('index', current_data.index)
                                            .attr('id', 'big_fish' + current_data.index)
                                            .style('cursor', 'pointer')
                                            .on('mouseenter', function (d) {
                                                moused_over = parseInt(d3.select(this).attr('index'));
                                            })
                                            .on('mouseover', function(){
                                                moused_over = parseInt(d3.select(this).attr('index'));
                                            })
                                            .on('mouseleave', function () {
                                                d3.select(this).attr('opacity', 1);
                                            })
                                            .on('contextmenu', function () {
                                                contextMenuFor = parseInt(d3.select(this).attr('index'));

                                                //give the button an attribute to reference the fishplots they're dealing with
                                                //now we can invoke a function on click
                                                d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                                d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                                if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                                    contextMenuShowing = false;
                                                }
                                                if (contextMenuShowing == false) {
                                                    contextMenuForPrevious = contextMenuFor;
                                                    d3.event.preventDefault();
                                                    d3.select('#context-div').attr('cm-showing', 'true');
                                                    contextMenuShowing = true;
                                                    d3.select('#context-div').style('left', function () {
                                                                var left = d3.event.pageX;
                                                                return left + 'px';
                                                            })
                                                            .style('top', function () {
                                                                //-75 pixels because of navbar padding
                                                                var top = d3.event.pageY - 75;
                                                                return top + 'px';
                                                            })
                                                            .style('z-index', 10)
                                                            .style('opacity', 1);
                                                }
                                                else {
                                                    d3.event.preventDefault();
                                                    contextMenuShowing = false;
                                                    d3.select('#context-div').attr('cm-showing', 'false');
                                                    d3.select('#context-div').style('opacity', 0)
                                                            .style('z-index', -1);
                                                }
                                            });
                                }
                            });

                    //update the save_fishplot_div to move button to the right
                    d3.select('#load_fishplot_div').style('left', function () {
                                var button_width = d3.select('#load_fishplot_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#load_fishplot_button').style('padding-left')) * 2;
                                button_width = button_width + parseInt(d3.select('#load_fishplot_button').style('padding-right')) * 2;

                                var save_fishplot_div_left = parseInt(d3.select('#save_fishplot_div').style('left'));
                                var new_div_left = save_fishplot_div_left - 85; //pad 85px
                                new_div_left = new_div_left - button_width;

                                return new_div_left + 'px';
                            })
                            .style('width', function () {
                                var button_width = d3.select('#load_fishplot_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#load_fishplot_button').style('padding-left'));
                                button_width = button_width + parseInt(d3.select('#load_fishplot_button').style('padding-right'));
                                var margin = parseInt(d3.select('#load_fishplot_button').style('margin'));
                                if(Number.isInteger(margin) == true) {
                                    button_width = button_width + margin;
                                }
                                return button_width + 'px';
                            });

                    var convert_to_ccf_div = d3.select('#save_fishplot_div_wrapper').append('div')
                            .attr('id', 'convert_to_ccf_div')
                            .style('top', '0px')
                            .style('height', '100%')
                            .style('float', 'right');

                    var plot_options_div_group = convert_to_ccf_div.append('div')
                            .attr('class', 'btn-group dropup')
                            .style('width', '100px');

                    var plot_options_button = plot_options_div_group.append('button')
                            .attr('id', 'plot_options_button')
                            .attr('class', 'btn btn-default btn-sm dropdown-toggle')
                            .attr('data-toggle', 'dropdown')
                            .html('Plot options');

                    var button_group = plot_options_div_group.append('ul')
                            .attr('class', 'dropdown-menu');

                    var convert_to_ccf_button = button_group.append('li')
                            .append('a')
                            .style('cursor', 'pointer')
                            .html('CCF (Total Sample)')
                            .on('click', function () {
                                var can_plot = can_plot_CCF(canvas_nested_data, fishplot_svgs);
                                if (can_plot == false) {
                                    var complete_nested_data = canvas_nested_data.slice(0);
                                    d3.select('#modal_table').remove();
                                    d3.select('#save-CCF-button-reprompt').attr('type', 'ccf');

                                    reprompt(sample_timepoints, tick_labels, canvas_nested_data, ten_percent_below_zero,
                                            complete_nested_data, plot_background, allele_color_reference, fishplot_svgs, 0,
                                            canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                                            contextMenuShowing, contextMenuForPrevious, 'ccf', canvas_svg, num_of_timepoints, 100);
                                }

                                if (can_plot) {
                                    canvas_svg.html('');
                                    canvas_y_scale.domain([101, -1]);
                                    var purity = get_purity_dict(tick_labels);
                                    set_up_ccf_boundries(canvas_nested_data, fishplot_svgs, 'ccf');

                                    var nested_data = canvas_nested_data.slice(0);

                                    //Create shallow copy for values of each fishplot used
                                    //Prevents find_origin function from permanently trimming allele values
                                    update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                    for (var i = 0; i < plot_background.children.length; i++) {
                                        var parent = nested_data[plot_background.children[i]];
                                        var start_point = parent.start_point;
                                        nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100, 'ccf');
                                    }

                                    adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'ccf', 100);

                                    nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                    //collision detection for children after adjusting the independent evolution positions
                                    nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'ccf');

                                    //load pinches
                                    //Have to use fishplot svgs to select specific indices of nested_data
                                    //Otherwise, we prematurely clip off the origin of fishplots starting after
                                    //The first timepoint (i.e. Pretreatment in example file)
                                    for (var i = 0; i < fishplot_svgs.length; i++) {
                                        var current_allele = nested_data[i];
                                        for (var j = 0; j < current_allele.values.length; j++) {
                                            //Initialize all pinches to false
                                            //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                            current_allele.values[j].pinch = false;
                                        }
                                        current_allele.values = find_origin(current_allele);
                                    }

                                    remove_unnecessary_values(nested_data);

                                    d3.selectAll('.big_fish').remove();


                                    for (var i = 0; i < nested_data.length; i++) {
                                        var current_data = nested_data[i];

                                        canvas_svg.append('path')
                                                .attr('fill', 'none')
                                                .attr('stroke-width', 5)
                                                .attr("stroke", "transparent")
                                                .attr('class', 'big_fish')
                                                .style("stroke-linejoin", "round")
                                                .attr('d', function () {
                                                    return canvas_top_line_gen(current_data.values);
                                                });

                                        canvas_svg.append('path')
                                                .attr('fill', 'none')
                                                .attr("stroke", "transparent")
                                                .style("stroke-linejoin", "round")
                                                .attr('class', 'big_fish')
                                                .attr('stroke-width', 8)
                                                .attr('d', function () {
                                                    return canvas_bottom_line_gen(current_data.values);
                                                });

                                        canvas_svg.append('path')
                                                .datum(current_data.values)
                                                .attr('fill', current_data.color)
                                                .attr('opacity', 1)
                                                .attr('class', 'big_fish dropdown-toggle')
                                                .attr('d', canvas_area_between_lines)
                                                .attr('index', current_data.index)
                                                .attr('id', 'big_fish' + current_data.index)
                                                .style('cursor', 'pointer')
                                                .on('mouseenter', function (d) {
                                                    moused_over = parseInt(d3.select(this).attr('index'));
                                                })
                                                .on('mouseover', function(){
                                                    moused_over = parseInt(d3.select(this).attr('index'));
                                                })
                                                .on('mouseleave', function () {
                                                    d3.select(this).attr('opacity', 1);
                                                })
                                                .on('contextmenu', function () {
                                                    contextMenuFor = parseInt(d3.select(this).attr('index'));

                                                    //give the button an attribute to reference the fishplots they're dealing with
                                                    //now we can invoke a function on click
                                                    d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                                    d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                                    if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                                        contextMenuShowing = false;
                                                    }
                                                    if (contextMenuShowing == false) {
                                                        contextMenuForPrevious = contextMenuFor;
                                                        d3.event.preventDefault();
                                                        d3.select('#context-div').attr('cm-showing', 'true');
                                                        contextMenuShowing = true;
                                                        d3.select('#context-div').style('left', function () {
                                                                    var left = d3.event.pageX;
                                                                    return left + 'px';
                                                                })
                                                                .style('top', function () {
                                                                    //-75 pixels because of navbar padding
                                                                    var top = d3.event.pageY - 75;
                                                                    return top + 'px';
                                                                })
                                                                .style('z-index', 10)
                                                                .style('opacity', 1);
                                                    }
                                                    else {
                                                        d3.event.preventDefault();
                                                        contextMenuShowing = false;
                                                        d3.select('#context-div').attr('cm-showing', 'false');
                                                        d3.select('#context-div').style('opacity', 0)
                                                                .style('z-index', -1);
                                                    }
                                                });
                                    }

                                }

                            });

                    var convert_only_CCF = button_group.append('li')
                            .append('a')
                            .style('cursor', 'pointer')
                            .html('CCF (Cancer Cells Only)')
                            .on('click', function(){
                                var purity = get_purity_dict(tick_labels);
                                relative_to_cancer_cells(canvas_nested_data, fishplot_svgs, purity, tick_labels);

                                var can_plot = can_plot_CCF(canvas_nested_data, fishplot_svgs);
                                if (can_plot == false) {
                                    var complete_nested_data = canvas_nested_data.slice(0);
                                    d3.select('#modal_table').remove();

                                    d3.select('#save-CCF-button-reprompt').attr('type', 'only_cancer_ccf');
                                    reprompt(sample_timepoints, tick_labels, canvas_nested_data, ten_percent_below_zero,
                                            complete_nested_data, plot_background, allele_color_reference, fishplot_svgs, 0,
                                            canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                                            contextMenuShowing, contextMenuForPrevious, 'only_cancer_ccf', canvas_svg, num_of_timepoints, 100);
                                }
                                if (can_plot) {
                                    canvas_svg.html('');
                                    canvas_y_scale.domain([101, -1]);
                                    var purity = get_purity_dict(tick_labels);
                                    set_up_ccf_boundries(canvas_nested_data, fishplot_svgs, 'only_cancer_ccf');

                                    var nested_data = canvas_nested_data.slice(0);

                                    //Create shallow copy for values of each fishplot used
                                    //Prevents find_origin function from permanently trimming allele values
                                    update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                    for (var i = 0; i < plot_background.children.length; i++) {
                                        var parent = nested_data[plot_background.children[i]];
                                        var start_point = parent.start_point;
                                        nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100, 'only_cancer_ccf');
                                    }

                                    adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'only_cancer_ccf', 100);

                                    nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                    //collision detection for children after adjusting the independent evolution positions
                                    nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'only_cancer_ccf');

                                    //load pinches
                                    //Have to use fishplot svgs to select specific indices of nested_data
                                    //Otherwise, we prematurely clip off the origin of fishplots starting after
                                    //The first timepoint (i.e. Pretreatment in example file)
                                    for (var i = 0; i < fishplot_svgs.length; i++) {
                                        var current_allele = nested_data[i];
                                        for (var j = 0; j < current_allele.values.length; j++) {
                                            //Initialize all pinches to false
                                            //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                            current_allele.values[j].pinch = false;
                                        }
                                        current_allele.values = find_origin(current_allele);
                                    }

                                    remove_unnecessary_values(nested_data);

                                    d3.selectAll('.big_fish').remove();


                                    for (var i = 0; i < nested_data.length; i++) {
                                        var current_data = nested_data[i];

                                        canvas_svg.append('path')
                                                .attr('fill', 'none')
                                                .attr('stroke-width', 5)
                                                .attr("stroke", "transparent")
                                                .attr('class', 'big_fish')
                                                .style("stroke-linejoin", "round")
                                                .attr('d', function () {
                                                    return canvas_top_line_gen(current_data.values);
                                                });

                                        canvas_svg.append('path')
                                                .attr('fill', 'none')
                                                .attr("stroke", "transparent")
                                                .style("stroke-linejoin", "round")
                                                .attr('class', 'big_fish')
                                                .attr('stroke-width', 8)
                                                .attr('d', function () {
                                                    return canvas_bottom_line_gen(current_data.values);
                                                });

                                        canvas_svg.append('path')
                                                .datum(current_data.values)
                                                .attr('fill', current_data.color)
                                                .attr('opacity', 1)
                                                .attr('class', 'big_fish dropdown-toggle')
                                                .attr('d', canvas_area_between_lines)
                                                .attr('index', current_data.index)
                                                .attr('id', 'big_fish' + current_data.index)
                                                .style('cursor', 'pointer')
                                                .on('mouseenter', function (d) {
                                                    moused_over = parseInt(d3.select(this).attr('index'));
                                                })
                                                .on('mouseover', function(){
                                                    moused_over = parseInt(d3.select(this).attr('index'));
                                                })
                                                .on('mouseleave', function () {
                                                    d3.select(this).attr('opacity', 1);
                                                })
                                                .on('contextmenu', function () {
                                                    contextMenuFor = parseInt(d3.select(this).attr('index'));

                                                    //give the button an attribute to reference the fishplots they're dealing with
                                                    //now we can invoke a function on click
                                                    d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                                    d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                                    if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                                        contextMenuShowing = false;
                                                    }
                                                    if (contextMenuShowing == false) {
                                                        contextMenuForPrevious = contextMenuFor;
                                                        d3.event.preventDefault();
                                                        d3.select('#context-div').attr('cm-showing', 'true');
                                                        contextMenuShowing = true;
                                                        d3.select('#context-div').style('left', function () {
                                                                    var left = d3.event.pageX;
                                                                    return left + 'px';
                                                                })
                                                                .style('top', function () {
                                                                    //-75 pixels because of navbar padding
                                                                    var top = d3.event.pageY - 75;
                                                                    return top + 'px';
                                                                })
                                                                .style('z-index', 10)
                                                                .style('opacity', 1);
                                                    }
                                                    else {
                                                        d3.event.preventDefault();
                                                        contextMenuShowing = false;
                                                        d3.select('#context-div').attr('cm-showing', 'false');
                                                        d3.select('#context-div').style('opacity', 0)
                                                                .style('z-index', -1);
                                                    }
                                                });
                                    }

                                }
                            });

                    var reset_CCF = button_group.append('li')
                            .append('a')
                            .style('cursor', 'pointer')
                            .html('Reset CCF')
                            .on('click', function(){
                                for(var i = 0; i < canvas_nested_data.length; i++){
                                    var allele_values = canvas_nested_data[i].values;
                                    for(var j = 0; j < allele_values.length; j++){
                                        allele_values[j].ccf = undefined;
                                    }
                                }

                                fishplot_plot(canvas_svg, tick_labels, canvas_nested_data, fishplot_svgs, plot_background, num_of_timepoints,
                                        canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor, contextMenuShowing,
                                        contextMenuForPrevious, 'alt_count', allele_color_reference, max_VAF_value)
                            });

                    var back_to_VAF = button_group.append('li')
                            .append('a')
                            .style('cursor', 'pointer')
                            .html('VAF')
                            .on('click', function(){

                                 var nested_data = canvas_nested_data.slice(0);

                                    //Create shallow copy for values of each fishplot used
                                    //Prevents find_origin function from permanently trimming allele values
                                    update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                    for (var i = 0; i < plot_background.children.length; i++) {
                                        var parent = nested_data[plot_background.children[i]];
                                        var start_point = parent.start_point;
                                        nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, max_VAF_value, 'alt_count');
                                    }

                                    adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints, 'alt_count', max_VAF_value);

                                    nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                    //collision detection for children after adjusting the independent evolution positions
                                    nested_data = adjust_children_positioning(nested_data, num_of_timepoints, 'alt_count');

                                    //load pinches
                                    //Have to use fishplot svgs to select specific indices of nested_data
                                    //Otherwise, we prematurely clip off the origin of fishplots starting after
                                    //The first timepoint (i.e. Pretreatment in example file)
                                    for (var i = 0; i < fishplot_svgs.length; i++) {
                                        var current_allele = nested_data[i];
                                        for (var j = 0; j < current_allele.values.length; j++) {
                                            //Initialize all pinches to false
                                            //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                            current_allele.values[j].pinch = false;
                                        }
                                        current_allele.values = find_origin(current_allele);
                                    }

                                    remove_unnecessary_values(nested_data);

                                    d3.selectAll('.big_fish').remove();


                                    for (var i = 0; i < nested_data.length; i++) {
                                        var current_data = nested_data[i];

                                        canvas_svg.append('path')
                                                .attr('fill', 'none')
                                                .attr('stroke-width', 5)
                                                .attr("stroke", "transparent")
                                                .attr('class', 'big_fish')
                                                .style("stroke-linejoin", "round")
                                                .attr('d', function () {
                                                    return canvas_top_line_gen(current_data.values);
                                                });

                                        canvas_svg.append('path')
                                                .attr('fill', 'none')
                                                .attr("stroke", "transparent")
                                                .style("stroke-linejoin", "round")
                                                .attr('class', 'big_fish')
                                                .attr('stroke-width', 8)
                                                .attr('d', function () {
                                                    return canvas_bottom_line_gen(current_data.values);
                                                });

                                        canvas_svg.append('path')
                                                .datum(current_data.values)
                                                .attr('fill', current_data.color)
                                                .attr('opacity', 1)
                                                .attr('class', 'big_fish dropdown-toggle')
                                                .attr('d', canvas_area_between_lines)
                                                .attr('index', current_data.index)
                                                .attr('id', 'big_fish' + current_data.index)
                                                .style('cursor', 'pointer')
                                                .on('mouseenter', function (d) {
                                                    moused_over = parseInt(d3.select(this).attr('index'));
                                                })
                                                .on('mouseover', function(){
                                                    moused_over = parseInt(d3.select(this).attr('index'));
                                                })
                                                .on('mouseleave', function () {
                                                    d3.select(this).attr('opacity', 1);
                                                })
                                                .on('contextmenu', function () {
                                                    contextMenuFor = parseInt(d3.select(this).attr('index'));

                                                    //give the button an attribute to reference the fishplots they're dealing with
                                                    //now we can invoke a function on click
                                                    d3.select('#edit-ploidy-btn').attr('fish-index', contextMenuFor);
                                                    d3.select('#rmv-fishplot-btn').attr('fish-index', contextMenuFor);

                                                    if (contextMenuFor != contextMenuForPrevious || d3.select('#context-div').attr('cm-showing') == 'false') {
                                                        contextMenuShowing = false;
                                                    }
                                                    if (contextMenuShowing == false) {
                                                        contextMenuForPrevious = contextMenuFor;
                                                        d3.event.preventDefault();
                                                        d3.select('#context-div').attr('cm-showing', 'true');
                                                        contextMenuShowing = true;
                                                        d3.select('#context-div').style('left', function () {
                                                                    var left = d3.event.pageX;
                                                                    return left + 'px';
                                                                })
                                                                .style('top', function () {
                                                                    //-75 pixels because of navbar padding
                                                                    var top = d3.event.pageY - 75;
                                                                    return top + 'px';
                                                                })
                                                                .style('z-index', 10)
                                                                .style('opacity', 1);
                                                    }
                                                    else {
                                                        d3.event.preventDefault();
                                                        contextMenuShowing = false;
                                                        d3.select('#context-div').attr('cm-showing', 'false');
                                                        d3.select('#context-div').style('opacity', 0)
                                                                .style('z-index', -1);
                                                    }
                                                });
                                    }

                            });

                    var reset_plot_button = button_group.append('li')
                            .append('a')
                            .style('cursor', 'pointer')
                            .html('Clear plot')
                            .on('click', function () {
                                var clones = [];
                                for(var i = 0; i < plot_background.children.length; i++){
                                    clones.push(canvas_nested_data[plot_background.children[i]]);
                                }
                                for(var i = 0; i < clones.length; i++) {
                                    var current_fish = clones[i];
                                    var index = current_fish.index;
                                    if (current_fish.parent_index_of_this == 'plot') {
                                        var group_index = parseInt(current_fish.group);
                                        group_index = groups.indexOf(group_index);
                                        if (group_index > -1) {
                                            groups.splice(group_index, 1);
                                        }

                                        var plot_background_group = current_fish.group.toString();
                                        delete plot_background.groups[plot_background_group];

                                        var child_index = plot_background.children.indexOf(index);
                                        if (child_index > -1) {
                                            plot_background.children.splice(child_index, 1);
                                        }
                                    }

                                    d3.select('#mini_fishplot_div' + index).style('opacity', 1);
                                    var index_in_fishplot_svgs = fishplot_svgs.indexOf(index);
                                    if (index_in_fishplot_svgs > -1) {
                                        fishplot_svgs.splice(index_in_fishplot_svgs, 1);
                                    }
                                    remove_fishplot_relationships(current_fish, fishplot_svgs, canvas_nested_data);

                                    plot_background.children.shift();

                                    scope.$apply(function () {
                                        scope.$parent.plotted = fishplot_svgs;
                                    });
                                }
                                d3.selectAll('.big_fish').remove();
                                d3.selectAll('.mini_fishplot_divs').style('opacity', 1);
                            });

                    d3.select('#convert_to_ccf_div').style('left', function () {
                        var button_width = d3.select('#plot_options_button').node().offsetWidth;
                        button_width = button_width + parseInt(d3.select('#plot_options_button').style('padding-left')) * 2;
                        button_width = button_width + parseInt(d3.select('#plot_options_button').style('padding-right')) * 2;

                        var load_fishplot_div_left = parseInt(d3.select('#load_fishplot_div').style('left'));
                        var load_fishplot_div_width = parseInt(d3.select('#load_fishplot_div').style('width'));
                                var new_div_left = load_fishplot_div_left - 85; //pad 85px
                                new_div_left = new_div_left - button_width;
                                return new_div_left + 'px';
                            })
                            .style('width', function () {
                                var button_width = d3.select('#plot_options_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#plot_options_button').style('padding-left'));
                                button_width = button_width + parseInt(d3.select('#plot_options_button').style('padding-right'));
                                var margin = parseInt(d3.select('#plot_options_button').style('margin'));
                                if(Number.isInteger(margin) == true) {
                                    button_width = button_width + margin;
                                }
                                return button_width + 'px';
                            });

                    var edit_purity_div = d3.select('#save_fishplot_div_wrapper').append('div')
                            .attr('id', 'edit_purity_div')
                            .style('top', '0px')
                            .style('height', '100%')
                            .style('float', 'right');

                    var edit_purity_button = edit_purity_div.append('button')
                            .attr('class', 'btn btn-default btn-sm')
                            .attr('id', 'edit_purity_button')
                            .html('Edit Purity')
                            .on('click', function(){
                                $("#purityModal").modal('show');
                            });

                    var labels = d3.select('#purityForm')
                            .selectAll('inputs')
                            .data(tick_labels)
                            .enter()
                            .append('div')
                            .append('label')
                            .attr('class', 'control-label')
                            .attr('for', function(d, i){
                                return 'day' + d.toString() + '_input';
                            })
                            .html(function(d){
                                return 'Day ' + d.toString() + ': ';
                            })
                            .append('input')
                            .style('width', '150px')
                            .attr('type','number')
                            .attr('min', '0')
                            .attr('max', '100')
                            .attr('class', 'form-control')
                            .attr('id', function(d, i){
                                return 'day' + d.toString() + '_input';
                            })
                            .attr('value', 90);

                    d3.select('#save_purity_button')
                            .on('click', function () {
                                 var purity_dict = {};
                                    for (var i = 0; i < tick_labels.length; i++) {

                                        var purity_value = parseInt(d3.select('#day' + tick_labels[i].toString() + '_input').node().value);
                                        if(purity_value > 100){
                                            purity_value = 100;
                                        }
                                        if(purity_value < 0){
                                            purity_value = 0;
                                        }
                                        purity_dict[tick_labels[i].toString()] = purity_value;
                                    }

                                scope.$apply(function(){
                                    scope.$parent.purity_data = purity_dict;
                                });

                                if (plot_background.children.length > 1) {

                                    d3.select('#modal_table').remove();

                                    var complete_nested_data = canvas_nested_data.slice(0);
                                    d3.select('#modal_table').remove();
                                    d3.select('#save-CCF-button-reprompt').attr('type', 'ccf');

                                    canvas_y_scale.domain([101, -1]);

                                    reprompt(sample_timepoints, tick_labels, canvas_nested_data, ten_percent_below_zero,
                                            complete_nested_data, plot_background, allele_color_reference, fishplot_svgs, 0,
                                            canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor,
                                            contextMenuShowing, contextMenuForPrevious, 'ccf', canvas_svg, num_of_timepoints, 100);
                                }

                            });

                    //update the save_fishplot_div to move button to the right
                    d3.select('#edit_purity_div').style('left', function () {
                                var button_width = d3.select('#edit_purity_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#edit_purity_button').style('padding-left')) * 2;
                                button_width = button_width + parseInt(d3.select('#edit_purity_button').style('padding-right')) * 2;

                                var save_fishplot_div_left = parseInt(d3.select('#convert_to_ccf_div').style('left'));
                                var new_div_left = save_fishplot_div_left - 75; //pad 75px
                                new_div_left = new_div_left - button_width;
                                return new_div_left + 'px';
                            })
                            .style('width', function () {
                                var button_width = d3.select('#edit_purity_button').node().offsetWidth;
                                button_width = button_width + parseInt(d3.select('#edit_purity_button').style('padding-left'));
                                button_width = button_width + parseInt(d3.select('#edit_purity_button').style('padding-right'));
                                var margin = parseInt(d3.select('#edit_purity_button').style('margin'));
                                if(Number.isInteger(margin) == true) {
                                    button_width = button_width + margin;
                                }
                                return button_width + 'px';
                            });

                    scope.$watch('values', function (new_values) {
                        //if 3 parameters sent through, it came from fishplot table
                        if(new_values.length == 3) {
                            var allele = new_values[0];
                            var timepoint = new_values[1];
                            if (!isNaN(parseInt(timepoint))) {
                                timepoint = parseInt(timepoint);
                            }
                            var vaf = new_values[2];

                            var index = allele_index(canvas_nested_data, allele);
                            from_table_update_nested_data(canvas_nested_data, mini_nested_data, allele, timepoint, vaf);
                        }

                        //else it's updated mini fishplot data from loading saved fishplot
                        if(new_values.length == 1){
                            mini_nested_data = new_values;
                        }

                        var temp_y_max = y_scale_domain_max(mini_nested_data);
                        if (temp_y_max > y_max) {
                            y_max = temp_y_max;
                            mini_y_scale.domain([y_max + 1, -1]);
                            generate_mini_fishplot_top_and_bottom(mini_nested_data, y_max);

                            mini_fishplot_data = JSON.parse(JSON.stringify(mini_nested_data));
                            pinch_data(mini_fishplot_data);
                            remove_unnecessary_values(mini_fishplot_data);

                            d3.selectAll('.fishplot_areas').remove();

                            //Mini fishplot divs in scroll container
                            svgs.append('path')
                                    .attr('id', function (d, i) {
                                        return 'fishplot_area' + i
                                    })
                                    .attr('class', 'fishplot_areas')
                                    .attr('fill', 'none')
                                    .attr('stroke-width', 5)
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('d', function (d, i) {
                                        return top_line_gen(mini_fishplot_data[i].values);
                                    });

                            svgs.append('path')
                                    .attr('id', function (d, i) {
                                        return 'fishplot_area' + i
                                    })
                                    .attr('class', 'fishplot_areas')
                                    .attr('fill', 'none')
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('stroke-width', 8)
                                    .attr('d', function (d, i) {
                                        return bottom_line_gen(mini_fishplot_data[i].values);
                                    });

                            //difference between edge of mini fishplot div, and where fishplot fill starts
                            var left_adjustment = 0;


                            svgs.append('path')
                                    .attr('id', function (d, i) {
                                        return 'fishplot_area' + i
                                    })
                                    .attr('opacity', 1)
                                    .attr('fill', function (d) {
                                        return d.color;
                                    })
                                    .datum(function (d, i) {
                                        return mini_fishplot_data[i].values;
                                    })
                                    .attr('d', area_between_lines)
                                    .attr('cursor', 'pointer')
                                    .attr('class', 'fishplot_areas')
                                    .on('mousedown', function (d, i) {
                                        d3.event.preventDefault();
                                        d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                        var div_id = '#mini_fishplot_div' + i;
                                        var svg_id = '#mini_fishplot_svg' + i;
                                        var mini_fishplot = d3.select(svg_id);

                                        //get svg info for clone
                                        var dragable_div_content = mini_fishplot.node().outerHTML;

                                        //Calculate top based on the top of the mini fishplot div and how far user scrolled
                                        top_in_container = parseInt(d3.select(div_id).style('top')) - d3.select('#container_div').node().scrollTop;
                                        top_in_container = top_in_container + 'px';
                                        left_in_container = d3.select(div_id).style('left');
                                        var width = d3.select(div_id).style('width');
                                        var height = d3.select(div_id).style('height');

                                        //remove any clones that are already layed down, if any at all
                                        //Some may be left behind if user moves mouse rapdily
                                        d3.selectAll('#dragable_div').remove();

                                        if (fishplot_svgs.indexOf(i) != -1) {
                                            return;
                                        }

                                        for (var j = 0; j < fishplot_svgs.length; j++) {
                                            var plotted_data = canvas_nested_data[fishplot_svgs[j]];
                                            var data = canvas_nested_data[i];
                                            var fit = can_fit(canvas_nested_data, plotted_data, data, num_of_timepoints);
                                            if (!fit) {
                                                cant_fit.push(fishplot_svgs[j]);
                                                d3.select('#big_fish' + plotted_data.index)
                                                        .attr('fill', '#262626');
                                            }
                                        }

                                        var dragable_div = dragable_div_wrapper.append('div')
                                                .style('top', top_in_container)
                                                .style('left', left_in_container)
                                                .style('width', width)
                                                .style('height', height)
                                                .style('position', 'absolute')
                                                .style('cursor', 'pointer')
                                                .html(dragable_div_content)
                                                .attr('index', i)
                                                .attr('z-index', 10)
                                                .attr('id', 'dragable_div');

                                        d3.select('#dragable_div').selectAll('.info_text').remove();
                                        d3.select('#dragable_div').selectAll('.info_lines').remove();

                                        //remove cog wheel
                                        d3.select('#dragable_div').select('#cog_wheel').remove();
                                        d3.select('#dragable_div').select('#infolight').remove();

                                        var bounding = d3.select('#fishplot_area' + i).node().getBoundingClientRect();
                                        left_adjustment = bounding.left - parseInt(left_in_container);

                                          if(navigator.userAgent.indexOf("Firefox") != -1 ){
                                            old_x_pos = d3.event.pageX;
                                            old_y_pos = d3.event.pageY;
                                        }
                                        else{
                                            old_x_pos = d3.event.x;
                                            old_y_pos = d3.event.y;
                                        }

                                        dragging = true;
                                        d3.select(this).attr('opacity', 0);

                                        d3.select('#dragable_div').style('pointer-events', 'none')
                                                //give mouseup remove functionality
                                                .on('mouseup', function () {
                                                    d3.select(this).remove();
                                                });
                                        d3.select(el).style('cursor', 'pointer');

                                    });

                        }
                        else {
                            var temp_svg = d3.select('#mini_fishplot_svg'+index);
                            d3.selectAll('#fishplot_area' + index).remove();

                            mini_fishplot_data = JSON.parse(JSON.stringify(mini_nested_data));
                            pinch_data(mini_fishplot_data);
                            remove_unnecessary_values(mini_fishplot_data);
                            var temp_nested_data = mini_fishplot_data[index];
                            generate_mini_fishplot_top_and_bottom([temp_nested_data], y_max);

                            temp_svg.append('path')
                                    .attr('id', 'fishplot_area' + index)
                                    .attr('class', 'fishplot_areas')
                                    .attr('fill', 'none')
                                    .attr('stroke-width', 5)
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('d', top_line_gen(temp_nested_data.values));

                            temp_svg.append('path')
                                    .attr('id', 'fishplot_area' + index)
                                    .attr('class', 'fishplot_areas')
                                    .attr('fill', 'none')
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('stroke-width', 8)
                                    .attr('d', bottom_line_gen(temp_nested_data.values));

                            //difference between edge of mini fishplot div, and where fishplot fill starts
                            var left_adjustment = 0;


                            temp_svg.append('path')
                                    .attr('id', 'fishplot_area' + index)
                                    .attr('opacity', 1)
                                    .attr('fill', temp_nested_data.color)
                                    .datum(function () {
                                        return temp_nested_data.values;
                                    })
                                    .attr('d', area_between_lines)
                                    .attr('cursor', 'pointer')
                                    .attr('class', 'fishplot_areas')
                                    .on('mousedown', function () {
                                        d3.event.preventDefault();
                                        var i = index;
                                        d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                        var div_id = '#mini_fishplot_div' + i;
                                        var svg_id = '#mini_fishplot_svg' + i;
                                        var mini_fishplot = d3.select(svg_id);

                                        //get svg info for clone
                                        var dragable_div_content = mini_fishplot.node().outerHTML;

                                        //Calculate top based on the top of the mini fishplot div and how far user scrolled
                                        top_in_container = parseInt(d3.select(div_id).style('top')) - d3.select('#container_div').node().scrollTop;
                                        top_in_container = top_in_container + 'px';
                                        left_in_container = d3.select(div_id).style('left');
                                        var width = d3.select(div_id).style('width');
                                        var height = d3.select(div_id).style('height');

                                        //remove any clones that are already layed down, if any at all
                                        //Some may be left behind if user moves mouse rapdily
                                        d3.selectAll('#dragable_div').remove();

                                        if (fishplot_svgs.indexOf(i) != -1) {
                                            return;
                                        }

                                        for (var j = 0; j < fishplot_svgs.length; j++) {
                                            var plotted_data = canvas_nested_data[fishplot_svgs[j]];
                                            var data = canvas_nested_data[i];
                                            var fit = can_fit(canvas_nested_data, plotted_data, data, num_of_timepoints);
                                            if (!fit) {
                                                cant_fit.push(fishplot_svgs[j]);
                                                d3.select('#big_fish' + plotted_data.index)
                                                        .attr('fill', '#262626');
                                            }
                                        }

                                        var dragable_div = dragable_div_wrapper.append('div')
                                                .style('top', top_in_container)
                                                .style('left', left_in_container)
                                                .style('width', width)
                                                .style('height', height)
                                                .style('position', 'absolute')
                                                .style('cursor', 'pointer')
                                                .html(dragable_div_content)
                                                .attr('index', i)
                                                .attr('z-index', 10)
                                                .attr('id', 'dragable_div');

                                        d3.select('#dragable_div').selectAll('.info_text').remove();
                                        d3.select('#dragable_div').selectAll('.info_lines').remove();

                                        //remove cog wheel
                                        d3.select('#dragable_div').select('#cog_wheel').remove();
                                        d3.select('#dragable_div').select('#infolight').remove();

                                        var bounding = d3.select('#fishplot_area' + i).node().getBoundingClientRect();
                                        left_adjustment = bounding.left - parseInt(left_in_container);

                                        if (navigator.userAgent.indexOf("Firefox") != -1) {
                                            old_x_pos = d3.event.pageX;
                                            old_y_pos = d3.event.pageY;
                                        }
                                        else {
                                            old_x_pos = d3.event.x;
                                            old_y_pos = d3.event.y;
                                        }

                                        dragging = true;
                                        d3.select(this).attr('opacity', 0);

                                        d3.select('#dragable_div').style('pointer-events', 'none')
                                                //give mouseup remove functionality
                                                .on('mouseup', function () {
                                                    d3.select(this).remove();
                                                });
                                        d3.select(el).style('cursor', 'pointer');

                                    });

                        }

                    });

                    function allele_index(nested_data, allele){
                        for(var i = 0; i < nested_data.length; i++){
                            if(nested_data[i].key == allele){
                                return i;
                            }
                        }
                    }

                    function from_table_update_nested_data(canvas_nested_data, mini_nested_data, allele, timepoint, vaf) {
                        for(var i = 0; i < canvas_nested_data.length; i++){
                            if(canvas_nested_data[i].key == allele){
                                var canvas_data = canvas_nested_data[i];
                                var mini_data = mini_nested_data[i];
                                for(var j = 0; j < canvas_data.values.length; j++){
                                    if(canvas_data.values[j].Sample_Barcode == timepoint){
                                        canvas_data.values[j].alt_count = vaf;
                                        mini_data.values[j].alt_count = vaf;
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                    }

                    canvas_svg.append("svg:g")
                            .attr("class", "axis noselect")
                            .attr('id', 'editor_x_axis')
                            .attr("transform", "translate(0," + canvas_range_max_y + ")")
                            .call(canvas_x_axis);

                    function resize_mini_fishplots(new_width) {
                        d3.selectAll('.mini_fishplots').remove();

                        mini_x_range_max = 0.25 * new_width;
                        y_max = y_scale_domain_max(mini_nested_data);
                        generate_mini_fishplot_top_and_bottom(mini_nested_data, y_max);

                        mini_fishplot_data = JSON.parse(JSON.stringify(mini_nested_data));
                        pinch_data(mini_fishplot_data);
                        remove_unnecessary_values(mini_fishplot_data);

                        mini_x_scale = d3.scale.linear().rangeRound([0, mini_x_range_max], 0.5)
                        mini_x_scale = d3.scale.linear().rangeRound([0, mini_x_range_max], 0.5)
                                .domain(d3.extent(x_axis_labels, function (d) {
                                    return d;
                                }));

                        mini_y_scale = d3.scale.linear().range([20, 140]).domain([y_max + 1, -1]);

                        for (var i = 0; i < mini_nested_data.length; i++) {
                            var div = d3.select('#mini_fishplot_div' + i);
                            div.style('width', 0.25 * new_width);
                            div.append('svg')
                                    .attr('width', '100%')
                                    .attr('height', '100%')
                                    .attr('class', 'mini_fishplots')
                                    .attr('opacity', 1)
                                    .attr('id', function () {
                                        return 'mini_fishplot_svg' + i;
                                    });

                            d3.select('#mini_fishplot_svg' + i).append('svg:image')
                                    .attr('x', mini_x_range_max * 0.01)
                                    .attr('y', mini_fishplot_container_height * 0.85)
                                    .attr('width', mini_fishplot_container_height * 0.15)
                                    .attr('height', mini_fishplot_container_height * 0.15)
                                    .attr('id', 'cog_wheel')
                                    .attr('cursor', 'pointer')
                                    .attr('index', function () {
                                        return i;
                                    })
                                    .attr('xlink:href', 'https://cdn1.iconfinder.com/data/icons/trycons/32/settings-512.png')
                                    .on('click', function () {
                                        var index = d3.select(this).attr('index');
                                        //return if the fishplot of this allele has already been plotted
                                        if (fishplot_svgs.indexOf(index) != -1) {
                                            return;
                                        }
                                        d3.select('#dragable_div').remove();
                                        var ploidy_num = d3.select('#ploidy_text' + index).node().innerHTML.split(' ')[1];
                                        d3.select('#ploidy_input').node().value = ploidy_num;
                                        d3.select('#ploidy_input').attr('fishplot_index', index);

                                        $("#exampleModal").modal('show');

                                    });

                            d3.select('#mini_fishplot_svg' + i).append('svg:image')
                                    .attr('x', mini_x_range_max * 0.10)
                                    .attr('y', mini_fishplot_container_height * 0.85)
                                    .attr('width', mini_fishplot_container_height * 0.15)
                                    .attr('height', mini_fishplot_container_height * 0.14)
                                    .attr('id', 'infolight')
                                    .attr('cursor', 'pointer')
                                    .attr('index', function () {
                                        return i;
                                    })
                                    .attr('xlink:href',
                                            'https://cdn0.iconfinder.com/data/icons/seo-web-15/130/seo-social-web-network-internet_186-128.png')
                                    .on('click', function () {
                                        var index = d3.select(this).attr('index');
                                        d3.select('#gene-info-table').remove();
                                        d3.select('#gene-info-modal-header-title').html('');
                                        d3.select('#gene-info-modal-header-title').html(mini_nested_data[index].values[0].allele + ' ' + 'Gene Information');

                                        var info = ['chromosome', 'position', 'type', 'cDNA', 'ref_seq', 'reference', 'alternative',
                                            'patients with gene'];
                                        var table_data = [];
                                        for (var j = 0; j < info.length; j++) {
                                            table_data.push({
                                                name: info[j],
                                                value: mini_nested_data[index][info[j]]
                                            });
                                        }


                                        var table = d3.select('#gene-info-modal-body').append('table')
                                                .attr('id', 'gene-info-table')
                                                .attr('class', 'table');

                                        var thead = table.append('thead').append('tr');
                                        thead.append('th').html('Parameter');
                                        thead.append('th').html('Value');

                                        var tbody = table.append('tbody').attr('id', 'tbody-gene-info-table');

                                        var rows = tbody.selectAll('gene-info')
                                                .data(table_data)
                                                .enter()
                                                .append('tr');

                                        rows.append('td')
                                                .html(function (d) {
                                                    return d.name;
                                                });

                                        rows.append('td')
                                                .html(function (d) {
                                                    return d.value;
                                                });

                                        $('#gene-info-modal').modal('show');

                                    });

                            d3.select('#mini_fishplot_svg' + i).append('path')
                                    .attr('id', function () {
                                        return 'fishplot_area' + i
                                    })
                                    .attr('fill', 'none')
                                    .attr('stroke-width', 5)
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('d', function () {
                                        return top_line_gen(mini_fishplot_data[i].values);
                                    });

                            d3.select('#mini_fishplot_svg' + i).append('path')
                                    .attr('id', function () {
                                        return 'fishplot_area' + i
                                    })
                                    .attr('fill', 'none')
                                    .attr("stroke", "transparent")
                                    .style("stroke-linejoin", "round")
                                    .attr('stroke-width', 8)
                                    .attr('d', function () {
                                        return bottom_line_gen(mini_fishplot_data[i].values);
                                    });

                            d3.select('#mini_fishplot_svg' + i).append('path')
                                    .attr('id', function () {
                                        return 'fishplot_area' + i;
                                    })
                                    .attr('opacity', 1)
                                    .attr('fill', function () {
                                        return mini_fishplot_data[i].color;
                                    })
                                    .datum(function () {
                                        return mini_fishplot_data[i].values;
                                    })
                                    .attr('d', area_between_lines)
                                    .attr('cursor', 'pointer')
                                    .attr('class', 'fishplot_areas')
                                    .attr('index', function () {
                                        return i;
                                    })
                                    .on('mousedown', function () {
                                        d3.event.preventDefault();
                                        var index = d3.select(this).attr('index');
                                        d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                        var div_id = '#mini_fishplot_div' + index;
                                        var svg_id = '#mini_fishplot_svg' + index;
                                        var mini_fishplot = d3.select(svg_id);

                                        //get svg info for clone
                                        var dragable_div_content = mini_fishplot.node().outerHTML;

                                        //Calculate top based on the top of the mini fishplot div and how far user scrolled
                                        top_in_container = parseInt(d3.select(div_id).style('top')) - d3.select('#container_div').node().scrollTop;
                                        top_in_container = top_in_container + 'px';
                                        left_in_container = d3.select(div_id).style('left');
                                        var width = d3.select(div_id).style('width');
                                        var height = d3.select(div_id).style('height');

                                        //remove any clones that are already layed down, if any at all
                                        //Some may be left behind if user moves mouse rapdily
                                        d3.selectAll('#dragable_div').remove();

                                        if (fishplot_svgs.indexOf(index) != -1) {
                                            return;
                                        }

                                        for (var j = 0; j < fishplot_svgs.length; j++) {
                                            var plotted_data = canvas_nested_data[fishplot_svgs[j]];
                                            var data = canvas_nested_data[index];
                                            var fit = can_fit(canvas_nested_data, plotted_data, data, num_of_timepoints);
                                            if (!fit) {
                                                cant_fit.push(fishplot_svgs[j]);
                                                d3.select('#big_fish' + plotted_data.index)
                                                        .attr('fill', '#262626');
                                            }
                                        }

                                        var dragable_div = dragable_div_wrapper.append('div')
                                                .style('top', top_in_container)
                                                .style('left', left_in_container)
                                                .style('width', width)
                                                .style('height', height)
                                                .style('position', 'absolute')
                                                .style('cursor', 'pointer')
                                                .html(dragable_div_content)
                                                .attr('index', index)
                                                .attr('z-index', 10)
                                                .attr('id', 'dragable_div');

                                        d3.select('#dragable_div').selectAll('.info_text').remove();
                                        d3.select('#dragable_div').selectAll('.info_lines').remove();

                                        //remove cog wheel
                                        d3.select('#dragable_div').select('#cog_wheel').remove();
                                        d3.select('#dragable_div').select('#infolight').remove();

                                        var bounding = d3.select('#fishplot_area' + index).node().getBoundingClientRect();
                                        left_adjustment = bounding.left - parseInt(left_in_container);

                                        if (navigator.userAgent.indexOf("Firefox") != -1) {
                                            old_x_pos = d3.event.pageX;
                                            old_y_pos = d3.event.pageY;
                                        }
                                        else {
                                            old_x_pos = d3.event.x;
                                            old_y_pos = d3.event.y;
                                        }

                                        dragging = true;
                                        d3.select(this).attr('opacity', 0);

                                        d3.select('#dragable_div').style('pointer-events', 'none')
                                                //give mouseup remove functionality
                                                .on('mouseup', function () {
                                                    d3.select(this).remove();
                                                });
                                        d3.select(el).style('cursor', 'pointer');

                                    });

                            //Ploidy and Chrs Affected table configuration
                            d3.select('#mini_fishplot_svg' + i).append('text')
                                    .attr('x', function () {
                                        //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                        var center = $('#mini_fishplot_svg'+i).width()/2;
                                        return center + 'px';
                                    })
                                    .attr('y', '155px')//if it were a formula this would be 15.5/16 using container height = 160
                                    .text(function () {
                                        return mini_nested_data[i].key;
                                    })
                                    .attr('font-size', '15px')
                                    .attr('text-anchor', 'middle')
                                    .attr('class', 'noselect info_text');

                            d3.select('#mini_fishplot_svg' + i).append('text')
                                    .attr('x', function () {
                                        //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                        var center = $('#mini_fishplot_svg'+i).width()/3;
                                        center = center * 0.5; //cut in half, then cut in half again
                                        return center + 'px';
                                    })
                                    .attr('y', '15px')
                                    .text(function () {
                                        return 'Chrs Affected: ' + 'N/A';
                                    })
                                    .attr('font-size', '12px')
                                    .attr('text-anchor', 'middle')
                                    .attr('id', function () {
                                        return 'chrs_aff_text' + i;
                                    })
                                    .attr('class', 'noselect info_text');

                            d3.select('#mini_fishplot_svg' + i).append('text')
                                    .attr('x', function () {
                                        //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                        var center = $('#mini_fishplot_svg'+i).width()/3;
                                        center = center * 1.5; //cut in half, then cut in half again
                                        return center + 'px';
                                    })
                                    .attr('y', '15px')
                                    .text(function () {
                                        return 'Chr: ' + mini_nested_data[i].chromosome;
                                    })
                                    .attr('font-size', '12px')
                                    .attr('text-anchor', 'middle')
                                    .attr('id', function () {
                                        return 'chr' + i;
                                    })
                                    .attr('class', 'noselect info_text');

                            d3.select('#mini_fishplot_svg' + i).append('text')
                                    .attr('font-size', '12px')
                                    .attr('text-anchor', 'middle')
                                    .attr('id', function () {
                                        return 'ploidy_text' + i;
                                    })
                                    .attr('class', 'noselect info_text')
                                    .attr('x', function () {
                                        //use jQuery again because d3.select().node().clientWidth doesnt work in Firefox
                                        var center = $('#mini_fishplot_svg'+i).width()/3;
                                        center = center * 2.5; //cut in half, then cut in half again
                                        return center + 'px';
                                    })
                                    .attr('y', '15px')
                                    .text(function () {
                                        if (mini_nested_data[i].chromosome == 'X' || mini_nested_data[i].chromosome == 'Y') {
                                            return 'Ploidy: ' + 1;
                                        }
                                        return 'Ploidy: ' + 2; //Will put variable for Ploidy eventually
                                    });

                            {% comment %}d3.select('#mini_fishplot_svg' + i).append('line')
                                    .attr('x1', '0px')
                                    .attr('x2', function () {
                                        return d3.select('#mini_fishplot_svg' + i).node().clientWidth;
                                    })
                                    .attr('y1', '20px')
                                    .attr('y2', '20px')
                                    .attr('fill', 'none')
                                    .attr('stroke', '#000000')
                                    .attr('class', 'info_lines');

                            d3.select('#mini_fishplot_svg' + i).append('line')
                                    .attr('x1', function () {
                                        return d3.select('#mini_fishplot_svg' + i).node().clientWidth / 3;
                                    })
                                    .attr('x2', function () {
                                        return d3.select('#mini_fishplot_svg' + i).node().clientWidth / 3;
                                    })
                                    .attr('y1', '0px')
                                    .attr('y2', '20px')
                                    .attr('stroke', '#000000')
                                    .attr('class', 'info_lines');

                            d3.select('#mini_fishplot_svg' + i).append('line')
                                    .attr('x1', function () {
                                        return (d3.select('#mini_fishplot_svg' + i).node().clientWidth / 3) * 2;
                                    })
                                    .attr('x2', function () {
                                        return (d3.select('#mini_fishplot_svg' + i).node().clientWidth / 3) * 2;
                                    })
                                    .attr('y1', '0px')
                                    .attr('y2', '20px')
                                    .attr('stroke', '#000000')
                                    .attr('class', 'info_lines');{% endcomment %}

                        }
                    }

                    $window.addEventListener('resize', resize_canvas);

                    function resize_canvas() {
                        d3.select('#canvas_div').selectAll('svg').remove();
                        var new_width = d3.select(el).node().clientWidth;

                        canvas_svg = canvas.append('svg')
                                .attr('width', parseInt(new_width * 0.73))
                                .attr('height', '100%')
                                .attr('id', 'canvas_svg')
                                .attr('index', 'canvas_svg')
                                .on('mouseover', function () {
                                    if (dragging) {
                                        moused_over = d3.select(this).attr('index');
                                    }
                                });

                        canvas_range_max_x = $('#canvas_svg').width();
                        canvas_x_scale = d3.scale.linear()
                                .rangeRound([canvas_range_max_x * 0.01, canvas_range_max_x * 0.99], 0.25)
                                .domain(d3.extent(x_axis_labels, function (d) {
                                    return d;
                                }));
                        canvas_x_axis = d3.svg.axis().scale(canvas_x_scale).tickValues(tick_labels);

                        canvas_range_max_y = $('#canvas_svg').height() * 0.95;
                        canvas_y_scale = d3.scale.linear().range([0, canvas_range_max_y]).domain([max_VAF_value, -1]);

                        minimum_left_pos = parseInt(new_width * 0.27) - 2;
                        minimum_left_pos = Math.floor(minimum_left_pos);


                        //Right now type is alt_count... will need to account for resize when CCF plotted
                        fishplot_plot(canvas_svg, tick_labels, canvas_nested_data, fishplot_svgs, plot_background, num_of_timepoints,
                                canvas_top_line_gen, canvas_bottom_line_gen, canvas_area_between_lines, moused_over, contextMenuFor, contextMenuShowing,
                                contextMenuForPrevious, 'alt_count', allele_color_reference, max_VAF_value);

                        resize_mini_fishplots(new_width);

                        canvas_svg.append("svg:g")
                            .attr("class", "axis noselect")
                            .attr('id', 'editor_x_axis')
                            .attr("transform", "translate(0," + canvas_range_max_y + ")")
                            .call(canvas_x_axis);
                    }

                }


                scope.$watch('data', function(updated_data){
                    create_fishplot_editor(updated_data, el, height, width);
                });
            }
        }]);

        $(function () {
            $('[data-toggle="popover"]').popover()
        });

        tevApp.directive('editorTable', function () {
            return {
                restrict: 'A',
                scope: {
                    data: '=',
                    colors: '=',
                    plotted: '=',
                    loadeddata: '='
                },
                link: link
            };

            function link(scope, element) {
                var el = element[0];
                var height = el.clientHeight;
                var width = el.clientWidth;
                var data = scope.data;
                var info = scope.values;

                var color_ref = scope.colors;
                var plotted = scope.plotted;

                var timepoints = [];

                scope.$watch('colors', function(new_colors){
                    color_ref = new_colors;
                });

                scope.$watch('plotted', function(updated_data){
                    plotted = updated_data;
                });

                scope.$watch('data', function(updated_data){
                    d3.selectAll('table').remove();
                    d3.selectAll('h2').remove();
                    data = updated_data;
                    var nested_data = d3.nest().key(function (d) {
                        return d.allele;
                    }).entries(data);

                    nested_data = sort_nested_alleles(nested_data);

                    timepoints = uniqueAxisLabels(data, 'Sample_Barcode');
                    timepoints = timepoints.sort(function(a, b){
                       return a-b;
                    });

                    var num_of_timepoints = timepoints.length;

                    var fishplot_data = [];

                    nested_data.forEach(function (d, i) {
                        var allele_data = {};
                        allele_data['allele'] = d.key;
                        allele_data['freqs'] = [];
                        var freqs = d.values;
                        for (var j = 0; j < freqs.length; j++) {
                            allele_data['freqs'].push(freqs[j].alt_count);
                        }
                        fishplot_data.push(allele_data);
                    });

                    add_conserved_alt_count(nested_data);


                    //Sorting data by what can fit in what
                    var sort_array = [];
                    for (var i = 0; i < fishplot_data.length; i++) {
                        //Have to rank when ordering, because a subclone that develops later
                        //cannot be parent of clone that derived earlier, even if it has a higher variant allele freq
                        var ranking_adjustment = Math.pow(10, num_of_timepoints);
                        var allele_freqs = fishplot_data[i].freqs;
                        for (var j = 0; j < allele_freqs.length; j++) {
                            if (allele_freqs[j] != 0) {
                                var rank = ranking_adjustment * allele_freqs[j];
                                sort_array.push({
                                    allele: fishplot_data[i].allele,
                                    rank: rank
                                });
                                break;
                            }
                            ranking_adjustment = ranking_adjustment / 10;
                        }
                    }

                    sort_array.sort(function (a, b) {
                        return b.rank - a.rank;
                    });

                    nested_data = order_by_rank(nested_data, sort_array);

                    //Any initial attributes on alleles will be applied within this for loop
                    for (var i = 0; i < nested_data.length; i++) {
                        nested_data[i].color = color_ref[nested_data[i].key];
                    }

                    d3.select(el).append('h2').style('text-align', 'center').html('VAF of Alleles at Each Timepoint');

                    var table = d3.select(el).append('table').attr('class', 'table table-bordered')
                            .attr('id', 'editor-table')
                            .attr('data-toggle', 'table')
                            .style('table-layout', 'fixed');

                    var header1 = table.append('thead').append('tr');
                    header1.append('th').html(' ');
                    header1.append('th').style('align', 'center').attr('colspan', timepoints.length).html('Timepoints');

                    var tbody = table.append('tbody').attr('id', 'tbody-editor-table').append('tr');
                    tbody.append('td').attr('align', 'center').html('<b> Alleles </b>');

                    for(var i = 0; i < timepoints.length; i++){
                        if(Number.isInteger(timepoints[i]) == true){
                            var timepoint = 'Day ' + timepoints[i];
                        }
                        else{
                            timepoint = timepoints[i];
                        }
                        tbody.append('td').attr('align', 'center').html('<b>' + timepoint + '</b>');
                    }

                    for(var i = 0; i < nested_data.length; i++){
                        var table_data = d3.select('#tbody-editor-table').append('tr').attr('id', 'tr'+i);
                        d3.select('#tr'+i).append('td')
                                .attr('bgcolor', nested_data[i].color)
                                .style('text-align', 'center')
                                .html(nested_data[i].key);
                        for (var j = 0; j < timepoints.length; j++) {
                            d3.select('#tr' + i).append('td')
                                    .style('text-align', 'center')
                                    .attr('value', nested_data[i].values[j].alt_count)
                                    .attr('conserved_val', nested_data[i].values[j].conserved_alt_count)
                                    .attr('timepoint', timepoints[j])
                                    .attr('allele', nested_data[i].key)
                                    .attr('index', i)
                                    .html(function(){
                                        if(nested_data[i].values[j].alt_count == nested_data[i].values[j].conserved_alt_count) {
                                            return (nested_data[i].values[j].alt_count + '%');
                                        }
                                        else{
                                            var conserved_alt_count = nested_data[i].values[j].conserved_alt_count;
                                            var html = '%' + ' '
                                                    + '<a data-toggle="popover" data-trigger="click" ' +
                                                    'title="This VAF has been altered"'
                                                    + 'data-content="The original VAF was ' + conserved_alt_count
                                                    + '">*</a>';
                                            return (nested_data[i].values[j].alt_count + html);
                                        }

                                    })
                                    .on('dblclick', function () {
                                        var index = parseInt(d3.select(this).attr('index'));
                                        if(plotted.indexOf(index) != -1){

                                            return;
                                        }

                                        var allele = d3.select(this).attr('allele');
                                        var alt_count = d3.select(this).attr('value');
                                        var conserved_alt_count = d3.select(this).attr('conserved_val');
                                        var current_td = d3.select(this);
                                        current_td.html(' ');
                                        var form = current_td.append('form');
                                        form.append('input')
                                                .attr('type', 'number')
                                                .attr('min', '0')
                                                .attr('max', '100')
                                                .attr('value', alt_count)
                                                .on('keydown', function () {
                                                    if (d3.event.keyCode == 13) {
                                                        d3.event.preventDefault();
                                                        if (!isNaN(parseInt(d3.select(this).node().value))) {
                                                            var new_vaf = parseInt(d3.select(this).node().value);
                                                            if (new_vaf > 100) {
                                                                new_vaf = 100;
                                                            }
                                                            if (new_vaf < 0) {
                                                                new_vaf = 0;
                                                            }
                                                            current_td.innerHTML = '';
                                                            var percentage = '%';
                                                            if(new_vaf != conserved_alt_count){
                                                                percentage = percentage + ' '
                                                                + '<a data-toggle="popover" data-trigger="click" ' +
                                                                        'title="This VAF has been altered"'
                                                                        + 'data-content="The original VAF was ' + conserved_alt_count
                                                                + '">*</a>';
                                                            }
                                                            current_td.attr('value', new_vaf).html(new_vaf + percentage);
                                                            var updated_info = [current_td.attr('allele'),
                                                                current_td.attr('timepoint'),
                                                                new_vaf];
                                                            //update with parent scope with info on the allele, timepoint,
                                                            //and new VAF
                                                            //updated_editor_info will be used to communicate between the table
                                                            //and the fishplot editor
                                                            scope.$apply(function () {
                                                                scope.$parent.updated_editor_info = updated_info;
                                                            });
                                                        }
                                                    }
                                                });
                                        form.append('label').html('%');
                                    });
                        }
                    }

                });

                scope.$watch('loadeddata', function(loaded_data){
                    var nested_data = JSON.parse(JSON.stringify(loaded_data));

                    //check if origin already added. If so, remove it
                    for(var i = 0; i < nested_data.length; i++){
                        var timepoint_data = nested_data[i].values;
                        if(timepoint_data[0].Sample_Barcode < 0 || timepoint_data[0].Sample_Barcode == 'origin'){
                            timepoint_data.shift();
                        }
                    }

                    d3.select('#tbody-editor-table').remove();
                    var tbody = d3.select('#editor-table').append('tbody').attr('id', 'tbody-editor-table').append('tr');
                    tbody.append('td').attr('align', 'center').html('<b> Alleles </b>');

                    for(var i = 0; i < timepoints.length; i++){
                        if(Number.isInteger(timepoints[i]) == true){
                            var timepoint = 'Day ' + timepoints[i];
                        }
                        else{
                            timepoint = timepoints[i];
                        }
                        tbody.append('td').attr('align', 'center').html('<b>' + timepoint + '</b>');
                    }

                    for(var i = 0; i < nested_data.length; i++){
                        var table_data = d3.select('#tbody-editor-table').append('tr').attr('id', 'tr'+i);
                        d3.select('#tr'+i).append('td')
                                .attr('bgcolor', nested_data[i].color)
                                .style('text-align', 'center')
                                .html(nested_data[i].key);
                        for (var j = 0; j < timepoints.length; j++) {
                            d3.select('#tr' + i).append('td')
                                    .style('text-align', 'center')
                                    .attr('value', nested_data[i].values[j].alt_count)
                                    .attr('conserved_val', nested_data[i].values[j].conserved_alt_count)
                                    .attr('timepoint', timepoints[j])
                                    .attr('allele', nested_data[i].key)
                                    .attr('index', i)
                                    .html(function(){
                                        if(nested_data[i].values[j].alt_count == nested_data[i].values[j].conserved_alt_count) {
                                            return (nested_data[i].values[j].alt_count + '%');
                                        }
                                        else{
                                            var conserved_alt_count = nested_data[i].values[j].conserved_alt_count;
                                            var html = '%' + ' '
                                                    + '<a data-toggle="popover" data-trigger="click" ' +
                                                    'title="This VAF has been altered"'
                                                    + 'data-content="The original VAF was ' + conserved_alt_count
                                                    + '">*</a>';
                                            return (nested_data[i].values[j].alt_count + html);
                                        }

                                    })
                                    .on('dblclick', function () {
                                        var index = parseInt(d3.select(this).attr('index'));
                                        if(plotted.indexOf(index) != -1){

                                            return;
                                        }

                                        var allele = d3.select(this).attr('allele');
                                        var alt_count = d3.select(this).attr('value');
                                        var conserved_alt_count = d3.select(this).attr('conserved_val');
                                        var current_td = d3.select(this);
                                        current_td.html(' ');
                                        var form = current_td.append('form');
                                        form.append('input')
                                                .attr('type', 'number')
                                                .attr('min', '0')
                                                .attr('max', '100')
                                                .attr('value', alt_count)
                                                .on('keydown', function () {
                                                    if (d3.event.keyCode == 13) {
                                                        d3.event.preventDefault();
                                                        if (!isNaN(parseInt(d3.select(this).node().value))) {
                                                            var new_vaf = parseInt(d3.select(this).node().value);
                                                            if (new_vaf > 100) {
                                                                new_vaf = 100;
                                                            }
                                                            if (new_vaf < 0) {
                                                                new_vaf = 0;
                                                            }
                                                            current_td.innerHTML = '';
                                                            var percentage = '%';
                                                            if(new_vaf != conserved_alt_count){
                                                                percentage = percentage + ' '
                                                                + '<a data-toggle="popover" data-trigger="click" ' +
                                                                        'title="This VAF has been altered"'
                                                                        + 'data-content="The original VAF was ' + conserved_alt_count
                                                                + '">*</a>';
                                                            }
                                                            current_td.attr('value', new_vaf).html(new_vaf + percentage);
                                                            var updated_info = [current_td.attr('allele'),
                                                                current_td.attr('timepoint'),
                                                                new_vaf];
                                                            //update with parent scope with info on the allele, timepoint,
                                                            //and new VAF
                                                            //updated_editor_info will be used to communicate between the table
                                                            //and the fishplot editor
                                                            scope.$apply(function () {
                                                                scope.$parent.updated_editor_info = updated_info;
                                                            });
                                                        }
                                                    }
                                                });
                                        form.append('label').html('%');
                                    });
                        }
                    }
                });
            }

        });

        tevApp.directive('purityLinePlot',['$window', function($window){

            return {
                restrict: 'A',
                scope: {
                    data: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                function makePurityLinePlot(updated_data, el, height, width) {
                    d3.select(el).selectAll('div').remove();
                    data = updated_data;

                    var timepoints = Object.keys(data);
                    timepoints = timepoints.map(Number);
                    if(timepoints.length == 0){
                        return;
                    }
                    if(timepoints.length == 1){
                        d3.select(el).remove();
                        return;
                    }

                    //Div to hold purity line plot svg... placed over editor div
                    var canvas = d3.select(el).append('div')
                            .style('top', 0 + 'px')
                            .style('left', width * 0.27 + 'px')
                            .style('width', '73%')
                            .style('height', height + 'px')
                            // .style('border-top', '1px solid black')
                            // .style('border-left', '1px solid black')
                            // .style('border-right', '1px solid black')
                            .style('padding', '2px')
                            .style('float', 'right')
                            .attr('id', 'purity-lineplot-wrapper');

                    //Canvas svg where fishplot will be plotted
                    var canvas_svg = canvas.append('svg')
                            .attr('width', '100%')
                            .attr('height', '100%')
                            .attr('id', 'line-plot-canvas');

                    var x_axis_labels = JSON.parse(JSON.stringify(timepoints));
                    var x_max = Math.max.apply(null, x_axis_labels);

                    var ten_percent_below_zero = 0.1 * x_max;
                    ten_percent_below_zero = parseInt(0 - ten_percent_below_zero);
                    x_axis_labels.unshift(ten_percent_below_zero);

                    var ten_percent_above_max = 0.1 * x_max;
                    ten_percent_above_max = x_max + ten_percent_above_max;
                    x_axis_labels.push(ten_percent_above_max);

                    //use jQuery here because d3.select('#line-plot-canvas).node().clientWidth doesnt work in Firefox
                    var canvas_range_max_x = $('#line-plot-canvas').width();

                    var x_scale = d3.scale.linear().domain(d3.extent(x_axis_labels, function (d) {
                                return d;
                            }))
                            .rangeRound([canvas_range_max_x * 0.01, canvas_range_max_x * 0.99], 0.25);

                    var manual_padding = height * 0.075;

                    var y_scale = d3.scale.linear().domain([100, 0]).range([(0 + manual_padding), (height - manual_padding)]);
                    var y_axis = d3.svg.axis().scale(y_scale).tickValues([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
                            .orient('left');

                    var line_gen = d3.svg.line().x(function (d) {
                                return x_scale(d.timepoint);
                            })
                            .y(function (d) {
                                return y_scale(d.purity);
                            });

                    var purity_data = [];

                    for (var i = 0; i < timepoints.length; i++) {
                        purity_data.push({
                            timepoint: timepoints[i],
                            purity: data[timepoints[i]]
                        });
                    }

                    canvas_svg.append('path')
                            .attr('d', line_gen(purity_data))
                            .attr('fill', 'none')
                            .attr("stroke", "#1e90ff")
                            .style("stroke-linejoin", "round")
                            .attr('stroke-width', 1);

                    var points = canvas_svg.selectAll('points')
                            .data(purity_data)
                            .enter()
                            .append('circle')
                            .attr('cx', function (d) {
                                return x_scale(d.timepoint);
                            })
                            .attr('cy', function (d) {
                                return y_scale(d.purity);
                            })
                            .attr('r', 3)
                            .attr('fill', '#1e90ff');

                    canvas_svg.append('text')
                            .attr('x', function () {
                                return 0;
                            })
                            .attr('y', function () {
                                return 0;
                            })
                            .html('Purity')
                            .attr('text-anchor', 'middle')
                            .attr('transform', 'translate(20, 75)rotate(270)');

                    canvas_svg.append("svg:g")
                            .attr('class', 'axis purity-line-ticks')
                            .attr("transform", "translate(" + 6 + "0)")
                            .call(y_axis);

                }

                scope.$watch('data', function(updated_data){
                    makePurityLinePlot(updated_data, el, height, width);
                    $window.addEventListener('resize', purity_resize);
                    function purity_resize() {
                        var new_height = d3.select(el).node().clientHeight;
                        var new_width = d3.select(el).node().clientWidth;
                        makePurityLinePlot(updated_data, el, new_height, new_width);
                    };
                });

            }

        }]);

        $('.closeall').ready(function(){
            $('.panel-collapse.in')
            .collapse('hide');
        });


    })();

    function change_icon(icon_number){
        var icon_id = '#expand'+icon_number;
        var is_expanded = d3.select(icon_id).attr('expanded');
        if(is_expanded == 'false'){
            d3.select(icon_id).attr('class', 'fa fa-minus');
            d3.select(icon_id).attr('expanded', 'true');
            return;
        }
        if(is_expanded == 'true'){
            d3.select(icon_id).attr('class', 'fa fa-plus');
            d3.select(icon_id).attr('expanded', 'false');
            return;
        }

    }

    function update_clonal_information_text(){
        var fishplot_index = d3.select('#ploidy_input').attr('fishplot_index');

        d3.select('#ploidy_text'+fishplot_index)
                .text(function(){
                   return 'Ploidy: ' + d3.select('#ploidy_input').node().valueAsNumber;
                });
    }

    function fetch_ploidy() {
        d3.select('#context-div').style('opacity', 0).attr('cm-showing', 'false');
        var index = parseInt(d3.select('#edit-ploidy-btn').attr('fish-index'));
        var ploidy_num = d3.select('#ploidy_text' + index).node().innerHTML.split(' ')[1];
        d3.select('#ploidy_input').node().value = ploidy_num;
        d3.select('#ploidy_input').attr('fishplot_index', index);

        $("#exampleModal").modal('show');
    }

</script>
<body ng-controller = "tevDataController" style="margin-left: 2.5%; margin-right: 2.5%; margin-bottom: 2.5%">
<!--
Dont need to provide alleles to figure 1 because all that's changing is the colors
-->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a id="subject_brand" class="navbar-brand" href=""></a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a data-toggle="tab" href="#editor-div">Fishplot Editor</a>
                </li>
                <li>
                    <a data-toggle="tab" href="#summary-divs">Variant Allele Summary</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="../../data/">Return to Data</a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<div class="tab-content">
    <div id="editor-div" class="tab-pane fade in active">
        <div class="row">
            <div id="editor-wrapper" class="col-lg-12 col-md-12 col-sm-12">
                <div id="collapsable-row" class="row">
                    <div class="panel-group allclose" id="accordion" role="tablist" aria-multiselectable="true">
                        <div class="panel panel-default">
                            <div id="heading1" class="panel-heading panel-heading-custom" role="tab" id="headingOne" style="background: #222222;">
                                <h4 class="panel-title">
                                    <a id="expand-btn-1" role="button" onclick="change_icon(1)" data-toggle="collapse"
                                       href="#collapseOne"
                                       aria-expanded="true" aria-controls="collapseOne"
                                       style="color: #ffffff;">
                                        <i id="expand1" expanded=false class="fa fa-plus" aria-hidden="true"></i> VAF Over Time
                                    </a>
                                </h4>
                            </div>
                            <div id="collapseOne" class="panel-collapse collapse in" role="tabpanel"
                                 aria-labelledby="headingOne">
                                <div class="panel-body">
                                    <div id="figure1" figure1-plot data="clustered_alleleified_data" colors="color_ref"
                                         style="height: 600px; width: 100%; float:left;">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="panel panel-default">
                            <div id="heading2" class="panel-heading panel-heading-custom" role="tab" id="headingTwo" style="background: #222222;">
                                <h4 class="panel-title">
                                    <a id="expand-btn-2" onclick="change_icon(2)" class="collapsed" role="button" data-toggle="collapse"
                                       href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"
                                        style="color: #ffffff;">
                                        <i id="expand2" expanded=false class="fa fa-plus" aria-hidden="true"></i> VAF Editor Table
                                    </a>
                                </h4>
                            </div>
                            <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel"
                                 aria-labelledby="headingTwo">
                                <div class="panel-body">
                                    <div id="figure7" editor-table data="alleleified_data" colors="color_ref"
                                         plotted="plotted"
                                         loadeddata="loaded_fishplot_data"
                                         style="width: 100%; float: left;">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="purity-row" class="row">
                    <div id="purity-line-div" purity-line-plot data="purity_data" class="col-sm-12 col-md-12 col-lg-12"
                         style="height: 150px; float: left;">
                    </div>
                </div>

                <div id="editor-row" class="row" >
                <div id="figure6-wrapper" style="overflow: visible;">
                <div id="figure6" fishplot-editor data="alleleified_data" values="updated_editor_info" colors="color_ref"
                     chromosomes="chromosome_dict" positions="position_dict" types="type_dict" cdnas="cDNA_dict" refseqs="ref_seq_dict"
                     references="reference_dict" alternatives="alternative_dict" patientswithgene="patient_gene_dict"
                     style="width: 100%; height: 600px; float: left; overflow: hidden;">
                </div>
                </div>
            </div>

            <div id="context-div" cm-showing="false" class="btn-group-vertical" style="z-index: -1; opacity: 0; position: absolute;">
                <button id="rmv-fishplot-btn" type="button" class="btn btn-default">Remove fishplot(s)</button>
                <button id="edit-ploidy-btn" type="button" class="btn btn-default" onclick="fetch_ploidy()">Edit ploidy</button>
            </div>

            <!--
            Modal for editing ploidy
            -->
            <div class="modal fade bd-example-modal-sm" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"
                 aria-hidden="true">
                <div class="modal-dialog modal-sm" role="document">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="color: #ffffff;">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            <h4 class="modal-title" id="exampleModalLabel">Edit Clonal Information</h4>
                        </div>
                        <div class="modal-body">
                            <form>

                                <label for="ploidy_input" class="form-control-label">Ploidy:</label>
                                <input class="form-control" id="ploidy_input" type="number" min="0" max="100"/>


                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal" id="save_button"
                                    onclick="update_clonal_information_text()">Save
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!--
            Modal for editing purity at timepoints
            -->

            <div class="modal fade bs-example-modal-sm" id="purityModal" tabindex="-1" role="dialog" aria-labelledby="mySmallModalLabel"
                 aria-hidden="true">
                <div class="modal-dialog modal-sm" role="document">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="color: #ffffff;">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            <h4 class="modal-title" id="purityModalHeader">Edit Purity Information</h4>
                        </div>
                        <div class="modal-body">
                            <form id="purityForm" >

                                <!--
                                Will edit the form in d3 based on the timepoints
                                -->

                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal"
                                    id="save_purity_button">
                                Save
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!--
            Modal for selecting the CCF
            -->

            <div class="modal fade" id="CCF_modal" tabindex="10" role="dialog" aria-labelledby="exampleModalLabel"
                 aria-hidden="true" style="overflow: auto;">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="color: #ffffff;">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            <h4 class="modal-title" id="exampleModalLabel">Choose CCF Distribution</h4>
                        </div>
                        <div id="CCF_modal_body" class="modal-body" popped-up="0">
                            <!--
                            Using D3 in the fishplot editor div, a table will be filled in here
                            -->
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal" id="save-CCF-button">Choose
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!--
            Modal for selecting the CCF during reprompt
            -->

            <div class="modal fade" id="CCF_modal_reprompt" tabindex="10" role="dialog" aria-labelledby="exampleModalLabel"
                 aria-hidden="true" style="overflow: auto;">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="color: #ffffff;">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            <h4 class="modal-title" id="exampleModalLabel">Choose CCF Distribution</h4>
                        </div>
                        <div id="CCF_modal_body_reprompt" class="modal-body">
                            <!--
                            Using D3 in the fishplot editor div, a table will be filled in here
                            -->
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal" id="save-CCF-button-reprompt">Choose
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!--
            Modal to prompt "save as:" for fishplot editor
            -->

            <div class="modal fade" id="save_fishplot_modal" tabindex="-1" role="dialog"
                 aria-labelledby="exampleModalLabel"
                 aria-hidden="true">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="color: #ffffff;">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            <h4 class="modal-title" id="exampleModalLabel">Save Your Fishplot</h4>
                        </div>
                        <div class="modal-body">
                            <form>

                                <label for="save_fishplot_as" class="form-control-label">Save as: </label>
                                <input class="form-control" id="save_fishplot_as" type="text"/>

                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal"
                                    id="save_as_fishplot_button">Save
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!--
            Modal to select and load saved fishplots
            -->

            <div class="modal fade" id="get_fishplot_modal" tabindex="-1" role="dialog"
                 aria-labelledby="exampleModalLabel" aria-hidden="true">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="color: #ffffff;">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            <h4 class="modal-title" id="exampleModalLabel">Select Saved Fishplot</h4>
                        </div>
                        <div id="get-fishplot-modal-body" class="modal-body">

                            <!--
                            Where the saved fishplot selection dropdown will be added via D3
                            -->

                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal"
                                    id="get_fishplot_button">Choose
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!--
            Modal to notify the user wheither or not the fishplot was saved successfully
            -->

            <div class="modal fade" id="saved-fishplot-dialog-box" role="dialog">
                <div class="modal-dialog modal-md">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse" >
                            <button type="button" class="close" data-dismiss="modal" style="color: #ffffff;">&times;</button>
                            <h4 id="dialog-header" class="modal-title" style="color: #ffffff;"></h4>
                        </div>
                        <div id="dialog-body" class="modal-body">

                            <!--
                            Will fill this in with a custom message pertaining to the name the user saved the fishplot under
                            -->

                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default btn-sm" data-dismiss="modal">OK</button>
                        </div>
                    </div>
                </div>
            </div>

             <!--
            Modal for information on variant/gene
            -->

            <div class="modal fade" id="gene-info-modal" role="dialog">
                <div class="modal-dialog modal-md">
                    <div class="modal-content">
                        <div class="modal-header modal-header-inverse">
                            <button type="button" class="close" data-dismiss="modal" style="color: #ffffff;">&times;</button>
                            <h4 id="gene-info-modal-header-title" class="modal-title" style="color: #ffffff; text-align:center;"></h4>
                        </div>
                        <div id="gene-info-modal-body" class="modal-body">

                            <!--
                            Will fill this in with information regarding gene
                            -->

                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default btn-sm" data-dismiss="modal">OK</button>
                        </div>
                    </div>
                </div>
            </div>


        </div>
    </div>
</div>


    <div id="summary-divs" class="tab-pane">
        <div class="panel panel-primary">
            <div id="summary-stats-panel-heading" class="panel-heading" style="background: #222222; display: block; border-color: #222222;">
                <h4 style="text-align: center; margin: 0px;">Summary Statistics</h4>
            </div>
            <div class="panel-body" style="padding: 0px;">
                <div class="row col-lg-12">
                    <div class="col-lg-6 col-md-6 col-sm-12">
                        <div id="figure1" figure1-plot data="clustered_alleleified_data" colors="color_ref"
                             class="col-lg-11 col-md-11 col-sm-11" style="height: 650px; float:left;">
                        </div>
                    </div>

                    <div class="col-lg-6 col-md-6 col-sm=12" style="float: right;">
                        <div id="figure2" figure2-plot data="[clustered_alleleified_data, alleles]" colors="color_ref"
                             class="col-lg-11 col-md-11 col-sm-11" style="height: 650px; float: right;">
                        </div>
                    </div>
                </div>


                <div class="row col-lg-12">
                    <div class="col-lg-6">
                        <div id="figure3" figure3-plot data="[dendro_data, dendro_y_data, alleleified_data, color_ref]"
                             class="col-lg-11"
                             style="height: 600px; float: left;">
                        </div>
                    </div>

                    <div class="col-lg-6">
                        <div id="figure4" figure4-plot data="fishbone_data" colors="color_ref" class="col-lg-12"
                             style="height: 600px; float: right; padding: 0px;">
                        </div>
                    </div>
                </div>


                <div class="row">
                    <div class="col-lg-12 col-md-12 col-sm-12">
                        <div id="figure5" figure5-plot data="linked_alleleified_data" colors="color_ref"
                             style="width: 100%; height: 600px; float: left;">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

</body>
</html>