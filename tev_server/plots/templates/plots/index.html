<!DOCTYPE html>
<html lang="en" ng-app = "tevApp">
<head>
    <meta charset="UTF-8">
    <title>TEV</title>
</head>
<style>
    .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 1.5px;
    }

    .node {
        font: 10px sans-serif;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 1.5px;
    }

    div.tooltip {
        position: absolute;
        text-align: center;
        width: 120px;
        height: 40px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
    }

</style>

<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.js"></script>
<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<script>
    function uniqueAxisLabels(data, key) {
        var unique = {};
        var distinct = [];
        data.forEach(function (x) {
            if (!unique[x[key]]) {
                distinct.push(x[key]);
                unique[x[key]] = true;
            }
        });

        return distinct;
    }

    function order_by_rank(data, rank_data){
        var reordered_data = [];
        for(var i = 0; i < data.length; i++){
            var current_allele = data.findIndex(x => x.key == rank_data[i].allele);
            current_allele = data[current_allele];
            reordered_data[i] = current_allele;
        }
        return reordered_data;
    }

    Array.prototype.diff = function(a) {
    return this.filter(function(i) {return a.indexOf(i) < 0;});
    };

    function find_origin(current_allele, plot_background, nestedData, yScale){
        var parent = nestedData[current_allele.parent_index_of_this];
        var allele_data = current_allele.values;
        var zeros = [];
        //Find out if origin is the only timepoint that has an alternative allele frequency of zero
        for(var i = 0; i < allele_data.length; i++){
            if(allele_data[i].alt_count == 0){
                zeros.push(i);
            }
            else {
                break;
            }
        }
        //If it is not the actuall origin
        if(zeros.length > 1){
{#            var previous_timepoint = allele_data[zeros.length-1].Sample_Barcode;#}
{#            var previous_top = allele_data[zeros.length-1].top;#}
{#            var previous_bottom = allele_data[zeros.length-1].bottom;#}

            allele_data.splice(0, zeros.length-1);
{#            var start_point = allele_data[0].start_point;#}
{#            var pinched_timepoint = {};#}
{#            if(parent != "plot") {#}
{#                if(allele_data[0] != undefined) {#}
{#                    start_point = allele_data[0].top + allele_data[0].bottom;#}
{#                    start_point = start_point/2;#}
{#                }#}
{#            }#}
{#            pinched_timepoint.allele = allele_data[0].allele;#}
{#            pinched_timepoint.Sample_Barcode = allele_data[0].Sample_Barcode;#}
{#            pinched_timepoint.previous_timepoint = previous_timepoint;#}
{#            pinched_timepoint.alt_count = 0;#}
{#            pinched_timepoint.pinch = true;#}
{#            pinched_timepoint.start_point = start_point;#}
{#            pinched_timepoint.previous_top = previous_top;#}
{#            pinched_timepoint.top = start_point;#}
{#            pinched_timepoint.bottom = start_point;#}
{#            pinched_timepoint.previous_bottom = previous_bottom;#}
{#            allele_data.unshift(pinched_timepoint);#}
        }
        return allele_data;
    }


    (function() {
        //Application name: tevApp
        //Dependencies: None
        var tevApp = angular.module('tevApp', []);

        //To distinguish between any Django references in the HTML
        tevApp.config(function($interpolateProvider) {
            $interpolateProvider.startSymbol('{$');
            $interpolateProvider.endSymbol('$}');
        });

        tevApp.factory('alleleify', function(){
            return {
                alleleify: function(data, gene_data){
                    var allele_data = [];

                    //Loop through to get all uuid
                    //So we only have to access, instead of loop through for every amino acid change
                    var gene_uuids = [];
                    for(var i = 0; i < gene_data.length; i++){
                        gene_uuids.push(gene_data[i].uuid);
                    }

                    for(var i = 0; i < data.length; i++){
                        var timepoint = data[i].timepoint;
                        var alleles = data[i].VariantAlleles;
                        for(var j = 0; j < alleles.length; j++){
                            var allele = gene_data[gene_uuids.indexOf(alleles[j].gene)].hugo_symbol
                                    + '-'
                                    + alleles[j].AA_original
                                    + alleles[j].AA_position.toString()
                                    + alleles[j].AA_variant;
                            var alt_count = alleles[j].alternative_freq;
                            allele_data.push({
                                allele: allele,
                                Sample_Barcode: timepoint,
                                alt_count: alt_count
                            });
                        }
                    }
                    return allele_data;
                }
            };
        });

        tevApp.factory('get_alleles', function(){
           return {
               get_alleles: function(alleleified_data){
                   var alleles = [];
                   for(var i = 0; i < alleleified_data.length; i++){
                       if(alleles.indexOf(alleleified_data[i].allele) == -1){
                           alleles.push(alleleified_data[i].allele);
                       }
                   }
                   return alleles;
               }
           };
        });



        //Controller name: TevDataController
        //Services: scope, http
        tevApp.controller('tevDataController', ['$scope', '$http', '$filter', 'alleleify', '$q', 'get_alleles',
            function($scope, $http, $filter, allelify, $q, get_alleles){
            //Initialize the scopes data to empty (will render blank plots until we've fetched data)
                $scope.tevData = [];
                $scope.alleleified_data = [];
                $scope.linked_alleleified_data = [];
                $scope.dendro_data = [];
                $scope.dendro_y_data = [];
                $scope.fishbone_data = [];
                //Created this variable because if alleleified_data is changed by dendrogram grouping,
                // it would keep calling itself
                $scope.clustered_alleleified_data = [];
                $scope.alleles = [];


                var source_uuid = '{{ source }}';
                var dendro_data = {{ d3_dendro_data|safe }};
                var dendro_y_data = {{ dendro_y_data }};

            //Get the data from the API
                var source_data = $http.get('http://127.0.0.1:8000/api/v1/sources/');
                var gene_data = $http.get('http://127.0.0.1:8000/api/v1/genes/');

                $q.all([source_data, gene_data]).then(function(results_array){
                    var gene_data = results_array[1].data;
                    var tevData = results_array[0].data;
                    tevData = $filter('filter')(tevData, {'uuid': source_uuid})[0];
                    $scope.tevData = tevData.Samples;

                    var alleleified_data = allelify.alleleify($scope.tevData, gene_data);
                    $scope.alleleified_data = alleleified_data;
                    $scope.alleles = get_alleles.get_alleles(alleleified_data);

                    //Send through this data, when the data from the API has been recieved
                    $scope.dendro_data = dendro_data;
                    $scope.dendro_y_data = dendro_y_data;
                });
        }]);

        //Directive that contains d3 code to render allele frequency change over timepoints
        //Plot type: Line plot
        tevApp.directive('figure1Plot', ['$compile',function($compile){
            return {
               scope: {
                   data: '='
               },
               restrict: 'A',
               link: link
           };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;
                var strokeColors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
                                    "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    d3.select(el).select('div').remove();
                    data = updatedData;

                    var canvas = d3.select(el).append("svg")
                        .attr("height", height)
                        .attr("width", width);

                    var div_tooltip = d3.select(el).append("div")
                            .attr("class", "tooltip")
                            .style("opacity", 0);

                    var yScale = d3.scale.linear().range([40, 500]).domain([1, 0]);
                    var yAxis = d3.svg.axis().scale(yScale).orient("left");

                    var axisLabels = uniqueAxisLabels(data, 'Sample_Barcode');

                    var xScale = d3.scale.ordinal().rangePoints([40, 500], 0.5).domain(axisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    var lineGen = d3.svg.line()
                            .x(function(d){
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                                return yScale(d.alt_count/100);
                            });

                    var nestedData = d3.nest()
                            .key(function(d){
                               return d.allele;
                            })
                            .entries(data);

                    var lineSvg = canvas.append("g");
                    var pointSvg = canvas.append("g");

                    var index;

                    nestedData.forEach(function(d, i){

                        lineSvg.append("path")
                                .attr("fill", "none")
                                .attr("stroke", strokeColors[i])
                                .attr("stroke-width", 2)
                                .attr("d", lineGen(d.values));

                        pointSvg.selectAll("timepoints")
                                .data(d.values)
                                .enter()
                                .append("rect")
                                .attr("x", function(d){
                                    return (xScale(d.Sample_Barcode)-5);
                                })
                                .attr("y", function(d){
                                    return (yScale(d.alt_count/100) - 5);
                                })
                                .attr("width", 12)
                                .attr("height", 12)
                                .attr("fill", strokeColors[i])
                                .on("mouseover", function(d){
                                    div_tooltip.style("opacity", 0.9)
                                    .html('<b>' +d.Sample_Barcode + '</b>'+ '<br/>' + '<br/>'
                                            + d.allele + ': ' + '<b>' + d.alt_count + '</b>')
                                            .style("top", (d3.event.pageY-40) + "px")
                                            .style("left", (d3.event.pageX + 40) + "px");
                                })
                                .on("mouseout", function(){
                                    div_tooltip.transition()
                                            .duration(300)
                                            .style('opacity', 0);
                                });

                    });

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + 500 + ")")
                        .call(xAxis);

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);

                }, true);
            }
        }]);

        //Directive that contains d3 code to render distribution of allele frequency at timepoints
        //Plot type: Box plots
        tevApp.directive('figure2Plot', ['$compile', function($compile){
            return{
                restrict: 'A',
                link: link,
                scope: {
                    data: '='
                }
            };

            function link(scope, element){
                var data = scope.data[0];
                var alleles = scope.data[1];
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;
                var fillColors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
                                    "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];


                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    d3.select(el).select('div').remove();

                    data = updatedData[0];
                    alleles = updatedData[1];

                    var canvas = d3.select(el).append("svg")
                        .attr("height", height)
                        .attr("width", width);

                    var information = ['90th:', 'Q3:', 'median:', 'Q1:', '10th:'];
                    var informationSvg = canvas.append("g");

                    informationSvg.selectAll("information_text")
                            .data(information)
                            .enter()
                            .append('text')
                            .attr('x', 520)
                            .attr('y', function(d, i){
                                return 60 + (25*i);
                            })
                            .style('font', '12px sans-serif')
                            .style('text-anchor', 'left')
                            .text(function(d){return d;});

                    var axisLabels = uniqueAxisLabels(data, 'cluster');

                    var yScale = d3.scale.linear().range([40, 500]).domain([1, 0]);
                    var yAxis = d3.svg.axis().scale(yScale).orient("left");
                    
                    var xScale = d3.scale.ordinal().rangePoints([40, 500], 0.5).domain(axisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    if(alleles.length == axisLabels.length){
                        axisLabels = uniqueAxisLabels(data, 'allele');
                        var nestedData = d3.nest().key(function(d){return d.allele}).entries(data);
                        xScale = d3.scale.ordinal().rangePoints([40, 500], 0.5).domain(axisLabels);
                        xAxis = d3.svg.axis().scale(xScale);
                    }
                    else{
                        nestedData = d3.nest().key(function(d){return d.cluster}).entries(data);
                        xAxis.tickFormat(function(d){return "cluster " + d;})
                    }

                    var boxData = [];
                    nestedData.forEach(function(d, i){
                        var quartileData = [];
                        for(var j = 0; j < d.values.length; j++){
                            quartileData[j] = d.values[j].alt_count/100;
                        }
                        quartileData.sort(function(a,b) { return a - b;});

                        boxData[i] = {
                            x: d.key,
                            y: d3.quantile(quartileData, 0.75),
                            Q3: d3.quantile(quartileData, 0.75).toFixed(2),
                            Q1: d3.quantile(quartileData, 0.25).toFixed(2),
                            median: d3.median(quartileData).toFixed(2),
                            pNinety: d3.quantile(quartileData, 0.90).toFixed(2),
                            pTen: d3.quantile(quartileData, 0.10).toFixed(2),
                            color: fillColors[i]

                        };
                    });

                    //Start of d3 box plot
                    canvas.selectAll('boxes')
                            .data(boxData)
                            .enter()
                            .append('rect')
                            .attr('x', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('y', function(d){
                                return yScale(d.Q3);
                            })
                            .attr('width', 20)
                            .attr('height', function(d){
                                return (yScale(d.Q1) - yScale(d.Q3));
                            })
                            .attr('fill', function(d){
                               return d.color;
                            })
                            .on('mouseover', function(d){
                                var box_information = [d.pNinety, d.Q3, d.median, d.Q1, d.pTen];
                                informationSvg.selectAll('information_text')
                                        .data(box_information)
                                        .enter()
                                        .append('text')
                                        .attr('x', 520+50)
                                        .attr('y', function(d, i){
                                            return 60 + (25*i);
                                        })
                                        .attr('class', 'box_data')
                                        .style('font', '12px sans-serif')
                                        .style('text-anchor', 'left')
                                        .text(function(d){
                                           return d;
                                        });
                            })
                            .on('mouseout', function(d){
                                d3.selectAll('.box_data').remove();
                            });

                    canvas.selectAll('medianLines')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.median);
                            })
                            .attr('y2', function(d){
                                return yScale(d.median);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('upperVerticalBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x);
                            })
                            .attr('x2', function(d){
                                return xScale(d.x);
                            })
                            .attr('y1', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('y2', function(d){
                                return yScale(d.Q3);
                            })
                            .attr('fill', 'none')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1);


                    canvas.selectAll('lowerVerticalBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x);
                            })
                            .attr('x2', function(d){
                                return xScale(d.x);
                            })
                            .attr('y1', function(d){
                                return yScale(d.Q1);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('pNinetyBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('pTenBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + 500 + ")")
                        .call(xAxis)
                            .selectAll("text")
                            .style('text-anchor', 'end')
                            .attr('transform', 'rotate(-65)');

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);
                }, true);
            }
        }]);

        tevApp.directive('figure3Plot', function(){

            return {
               restrict: 'A',
               scope: {
                   data: '='
               },
               link: link
            };

            function link(scope, element){
                var data = scope.data[0];
                var dendro_y_positions = scope.data[1];
                var alleleified_data = scope.data[2];
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var fillColors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
                    "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];

                var cluster = d3.layout.cluster()
                        .size([420, 420]);

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();

                    var canvas = d3.select(el).append('svg')
                            .attr('height', height)
                            .attr('width', width);

                    var sliderSvg = canvas.append('g');

                    canvas = canvas.append('g')
                            .attr('transform', 'translate(0, 75)');

                    data = updatedData[0];
                    dendro_y_positions = updatedData[1];
                    alleleified_data = updatedData[2];

                    var nodes = cluster.nodes(data);
                    var links = cluster.links(nodes);

                    //Update dendrogram position based on python clustering position
                    nodes.forEach(function(d, i){
                        d.y = dendro_y_positions[i];
                        d.id = i;
                    });

                    //Initialize the fishplot data
                    var linked_alleleified_data = cut_data(0, alleleified_data, nodes);
                    scope.$parent.linked_alleleified_data = linked_alleleified_data[0];
                    scope.$parent.clustered_alleleified_data = linked_alleleified_data[1];

                    function cut_data(max_path_y, alleleified_data, nodes){
                        var new_data = [];
                        for(var i = 0; i < nodes.length; i++){
                            if(nodes[i].y <= max_path_y){
                                new_data.push(nodes[i]);
                            }
                        }
                        var upper_level_data = [];
                        var used_nodes = [];
                        for(var i = 0; i < new_data.length; i++){
                            var allele_level_data = [];
                            var current_data = new_data[i];
                            if(current_data.name != " " && used_nodes.indexOf(current_data.id) == -1){
                                used_nodes.push(current_data.id);
                                allele_level_data.push(current_data.name);
                                upper_level_data.push(allele_level_data);
                            }
                            else if(current_data.name == " " && used_nodes.indexOf(current_data.id) == -1){
                                get_all_children(current_data, used_nodes, allele_level_data);
                                upper_level_data.push(allele_level_data);
                            }
                        }
                        var updated_linked_alleleified_data = convert_to_allelified(alleleified_data, upper_level_data);
                        var new_alleleified_data = update_alleleified_data(alleleified_data, upper_level_data);
                        return [updated_linked_alleleified_data, new_alleleified_data];
                    }
                     function update_alleleified_data(alleleified_data, upper_level_data){
                         for(var i = 0; i < upper_level_data.length; i++){
                             var allele_list = upper_level_data[i];
                             for(var j = 0; j < alleleified_data.length; j++){
                                 for(var k = 0; k < allele_list.length; k++){
                                     if(alleleified_data[j].allele == allele_list[k]){
                                         alleleified_data[j].cluster = i+1;
                                     }
                                 }
                             }
                         }
                         return alleleified_data;
                     }

                    function convert_to_allelified(alleleified_data, upper_level_data){
                        var new_linked_alleleified_data = [];
                        var allele;
                        for(var i = 0; i < upper_level_data.length; i++){
                            var allele_list = upper_level_data[i];
                            var parent_allele = upper_level_data[i][0];
                            if(allele_list.length > 1){
                            var new_allele_name = allele_list.join(" \n ");
                                }
                            else{
                                new_allele_name = allele_list[0];
                            }
                            for(var j = 0; j < alleleified_data.length; j++){
                                //Now generate data grouping the alleles for the fishbone and fishplot
                                if(alleleified_data[j].allele == parent_allele){
                                    allele = JSON.parse(JSON.stringify(alleleified_data[j]));
                                    allele.allele = new_allele_name;
                                    new_linked_alleleified_data.push(allele);
                                }
                            }
                        }
                        return new_linked_alleleified_data;
                    }

                    function get_all_children(current_data, used_nodes, allele_level_data){
                        if(current_data.children != undefined) {
                            for (var i = 0; i < current_data.children.length; i++) {
                                if(current_data.children[i].name == " "){
                                    used_nodes.push(current_data.children[i].id);
                                    get_all_children(current_data.children[i], used_nodes, allele_level_data);
                                }
                                else {
                                    if(used_nodes.indexOf(current_data.children[i].id) == -1) {
                                        used_nodes.push(current_data.children[i].id);
                                        allele_level_data.push(current_data.children[i].name);
                                    }
                                }
                            }
                        }
                    }

                    var drag = d3.behavior.drag()
                                .on('drag', function () {
                                    var slider = d3.select(this);
                                    var max_path_y = yScale.invert(30);
                                    if (d3.event.x < 30) {
                                        slider.attr('cx', 30);
                                        d3.select('#cutoff_line').attr('x1', 30).attr('x2', 30);
                                        max_path_y = yScale.invert(30);
                                    }
                                    else if (d3.event.x > 450) {
                                        slider.attr('cx', 450);
                                        d3.select('#cutoff_line').attr('x1', 450).attr('x2', 450);
                                        max_path_y = yScale.invert(450);
                                    }
                                    else {
                                        slider.attr('cx', d3.event.x);
                                        var cutoff = d3.select('#cutoff_line').attr('x1', d3.event.x).attr('x2', d3.event.x);
                                        max_path_y = yScale.invert(d3.event.x);
                                    }
                                    var linked_alleleified_data = cut_data(max_path_y, alleleified_data, nodes);
                                    scope.$apply(function(){
                                        scope.$parent.linked_alleleified_data = linked_alleleified_data[0];
                                        scope.$parent.clustered_alleleified_data = linked_alleleified_data[1];
                                    });
                                });

                    sliderSvg.append('line')
                            .attr('x1', 30)
                            .attr('x2', 450)
                            .attr('y1', 50)
                            .attr('y2', 50)
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1.5)
                            .attr('fill', 'none');

                    sliderSvg.append('circle')
                            .attr('r', 7)
                            .attr('cy', 50)
                            .attr('cx', 450)
                            .attr('id', 'slider_circle')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 0.5)
                            .attr('fill', '#EEEEEE')
                            .style('cursor', 'pointer')
                            .call(drag);

                    var y_max = Math.max.apply(null, dendro_y_positions);
                    var yScale = d3.scale.linear().domain([y_max, 0]).range([30, 450]);
                    var yAxis = d3.svg.axis().scale(yScale).orient('top');

                    var link = canvas.selectAll('.link')
                            .data(links)
                            .enter()
                            .append('path')
                            .attr('class', 'link')
                            .attr('d', function elbow(d, i) {
                                return "M" + yScale(d.source.y) + "," + d.source.x
                                        + "V" + d.target.x + "H" + yScale(d.target.y);
                            })
                            .attr('fill', 'none')
                            .attr('stroke', "#ccc")
                            .attr('stroke-width', 1.5)
                            .attr('transform', 'translate(0,40)');

                    var node = canvas.selectAll('.node')
                            .data(nodes)
                            .enter()
                            .append('g')
                            .attr('class', 'node')
                            .attr('transform', function(d){return "translate("+ yScale(d.y) + "," + (d.x + 40) + ")";});

                    node.append('circle')
                            .attr('r', function(d){
                                if(d.name == " "){
                                    return 0;
                                }
                                return 4.5;
                            });

                    canvas.append('line')
                            .attr('x1', function(){
                                var x = d3.select('#slider_circle').attr('cx');
                                return x;
                            })
                            .attr('x2', function(){
                                var x = d3.select('#slider_circle').attr('cx');
                                return x;
                            })
                            .attr('y1', 30)
                            .attr('y2', 450)
                            .attr('id', 'cutoff_line')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    node.append("text")
                            .attr("dx", function(d) { return d.children ? -8 : 8; })
                            .attr("dy", 3)
                            .attr("text-anchor", function(d) { return d.children ? "end" : "start"; })
                            .text(function(d) { return d.name; });

                    canvas.append("svg:g")
                            .attr("class", "axis")
                            .attr('transform', 'translate(0, 25)')
                            .call(yAxis);

                }, true);
            }

        });

        tevApp.directive('figure4Plot', function(){
            return {
                restrict: 'A',
                scope: {
                    data: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el =  element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var cluster = d3.layout.cluster()
                        .size([420, 420]);

                scope.$watch('data', function(updatedData){

                    d3.select(el).select('svg').remove();

                    data = updatedData;

                    function add_children(child, parent, data) {
                        var childData = {name: child.key, children: []};
                        parent.children.push(childData);

                        for(var i = 0; i < child.children.length; i++){
                            var newChild = data[child.children[i]];
                            add_children(newChild, childData, data);
                        }
                    }

                    var fishbone_data = {};
                    fishbone_data.name = data[0].key;
                    fishbone_data.children = [];

                    for(var i = 0; i < data[0].children.length; i++){
                        var child = data[0].children[i];
                        child = data[child];
                        add_children(child, fishbone_data, data);
                    }

                    var cluster = d3.layout.cluster()
                            .size([375, 375]);

                    var diagonal = d3.svg.diagonal()
                           .projection(function(d) { return [d.y, d.x]; });

                    var svg = d3.select(el).append("svg")
                            .attr("height", height)
                            .attr("width", width)
                            .append("g")
                            .attr("transform", "translate(100,75)");

                    var nodes = cluster.nodes(fishbone_data),
                            links = cluster.links(nodes);

                    var link = svg.selectAll(".link")
                            .data(links)
                            .enter().append("path")
                            .attr("class", "link")
                            .attr("d", diagonal);

                    var node = svg.selectAll(".node")
                            .data(nodes)
                            .enter().append("g")
                            .attr("class", "node")
                            .attr("transform", function (d) {
                                return "translate(" + d.y + "," + d.x + ")";
                            });

                    node.append("circle")
                            .attr("r", 4.5);

                    node.append("text")
                            .attr("dx", function (d) {
                                return d.children ? -8 : 8;
                            })
                            .attr("dy", 10)
                            .style("text-anchor", function (d) {
                                return d.children ? "end" : "start";
                            })
                            .text(function (d) {
                                return d.name;
                            });
                });

            }

        });

        tevApp.directive('figure5Plot', function(){

            return {
                restrict: 'A',
                scope: {
                    data: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var fillColors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
                                    "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    data = updatedData;

                    var canvas = d3.select(el).append('svg')
                        .attr('width', width)
                        .attr('height', height);

                    var xAxisLabels = uniqueAxisLabels(data, 'Sample_Barcode');
                    var num_of_timepoints = xAxisLabels.length;

                    xAxisLabels.unshift('origin');

                    var xScale = d3.scale.ordinal().rangePoints([40, 500], 0.5).domain(xAxisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    var yScale = d3.scale.linear().range([40, 500], 0.5).domain([101, -1]);
                    var yAxis = d3.svg.axis().scale(yScale).orient('left').ticks(0);

                    var nestedData = d3.nest().key(function(d){return d.allele}).entries(data);

                    //Dirty way of adding origin (tail fin of fish plot)
                    /*******************************************************************************/
                    /*Important to unshift, because order of making line matters for x values!!!!!*/
                    /*******************************************************************************/
                    for(var i = 0; i < nestedData.length; i++){
                        nestedData[i].values.unshift({
                           Sample_Barcode: 'origin',
                            alt_count: 0,
                            allele: nestedData[i].key
                        });
                    }

                    //Set up data for comparisons
                    var fishplot_data = [];

                    nestedData.forEach(function(d, i){
                        var allele_data = {};
                        allele_data['allele'] = d.key;
                        allele_data['freqs'] = [];
                        var freqs = d.values;
                        for(var j = 0; j < freqs.length; j++){
                            allele_data['freqs'].push(freqs[j].alt_count);
                        }
                        fishplot_data.push(allele_data);
                    });

                    var sort_array = [];
                    for(var i = 0; i < fishplot_data.length; i++){
                        //Have to rank when ordering, because a subclone that develops later
                        //cannot be parent of clone that derived earlier, even if it has a higher variant allele freq
                        var ranking_adjustment = Math.pow(10, num_of_timepoints);
                        var allele_freqs = fishplot_data[i].freqs;
                        for(var j = 1; j < allele_freqs.length; j++){
                            if(allele_freqs[j] != 0){
                                var rank = ranking_adjustment * allele_freqs[j];
                                sort_array.push({
                                    allele: fishplot_data[i].allele,
                                    rank: rank
                                });
                                break;
                            }
                            ranking_adjustment = ranking_adjustment/10;
                        }
                    }

                    sort_array.sort(function(a, b){
                       return b.rank - a.rank;
                    });

                    //Order data based on rank
                    nestedData = order_by_rank(nestedData, sort_array);

                    var plot_background = {};
                    plot_background.key = "plot";
                    plot_background.values = [];
                    plot_background.values.length = nestedData[0].values.length;
                    plot_background.values.fill({alt_count: 100});
                    plot_background.children = [0];
                    plot_background.groups = {0: 0};

                    //Initialize first parent group
                    nestedData[0].group = 0;
                    nestedData[0].start_point = 50;
                    nestedData[0].parent_index_of_this = "plot";
                    nestedData[0].children = [];
                    nestedData[0].id = 0;


                    for(var i = 1; i < nestedData.length; i++) {
                        var current_allele_data = nestedData[i];
                        var former_allele_data = nestedData[i-1];
                        current_allele_data.group = former_allele_data.group;
                        current_allele_data.start_point = former_allele_data.start_point;
                        current_allele_data.parent_index_of_this = i-1;
                        current_allele_data.children = [];
                        current_allele_data.id = i;


                        //check if it can fit inside its parent
                        var append_as_child = 'yes';
                        var parent_of_child_index = i;
                        for(var j = 1; j < current_allele_data.values.length; j++){
                            if(current_allele_data.values[j].alt_count > former_allele_data.values[j].alt_count) {
                                append_as_child = 'no';
                                break;
                            }
                        }
                        if(append_as_child == 'yes'){
                            former_allele_data.children.push(parent_of_child_index);
                        }
                        else {
                            var done = 0;
                            var children_used = [];
                            while (done != 1){
                                var next_up = former_allele_data.parent_index_of_this;
                                current_allele_data.parent_index_of_this = next_up;
                                if(next_up == "plot"){
                                    children_used.push(former_allele_data.id);
                                    var children = plot_background.children.diff(children_used);
                                    if(children.length == 0) {
                                        var parent_allele = plot_background;
                                    }
                                    else {
                                        var next_group = nestedData[children[0]].group;
                                        //find the last allele that was a child of the new group
                                        for(var l = i; l >= 0; l--){
                                            if(nestedData[l].group == next_group){
                                                parent_allele = nestedData[l];
                                                var new_group_dummy_data = {};
                                                new_group_dummy_data.group = next_group;
                                                new_group_dummy_data.parent_index_of_this = parent_allele.id;
                                                new_group_dummy_data.values = [];
                                                new_group_dummy_data.values.length = parent_allele.values.length;
                                                new_group_dummy_data.values.fill({alt_count: 0});
                                                former_allele_data = new_group_dummy_data;
                                                current_allele_data.parent_index_of_this = parent_allele.id;
                                                break;
                                            }
                                        }
                                    }
                                }
                                else{
                                    var parent_allele = nestedData[next_up];
                                }
                                //Check if it can fit inside parent_allele alongside parent_allele's children
                                //Array that holds total freq of children alleles at timepoint
                                var total_children_freq = [];
                                total_children_freq.length = parent_allele.values.length;
                                total_children_freq.fill(0);
                                for(var j = 0; j < parent_allele.children.length; j++){
                                    var child_allele = parent_allele.children[j];
                                    child_allele = nestedData[child_allele];
                                    for(var k = 0; k < total_children_freq.length; k++){
                                        total_children_freq[k] = child_allele.values[k].alt_count + total_children_freq[k];
                                    }
                                }
                                //Now add the current_allele values to the children total and see if they fit inside of parent
                                var check_if_fits = 1;
                                for(var j = 0; j < total_children_freq.length; j++){
                                    if((total_children_freq[j] + current_allele_data.values[j].alt_count) > parent_allele.values[j].alt_count){
                                        former_allele_data = parent_allele;
                                        check_if_fits = 0;
                                    }
                                }
                                if(check_if_fits == 1){
                                    parent_allele.children.push(i);
                                    if(parent_allele.key == "plot"){
                                        current_allele_data.group = (parent_allele.children.length - 1);
                                        plot_background.groups[current_allele_data.group.toString()] = i;
                                        var start_point_space = 100/parent_allele.children.length;
                                        var base_start_point = start_point_space/2;
                                        for(var g = 0; g < i+1; g++){
                                            var start = base_start_point + (nestedData[g].group * start_point_space);
                                            nestedData[g].start_point = start;
                                        }
                                    }
                                    else{
                                        current_allele_data.group = parent_allele.group;
                                        current_allele_data.start_point = parent_allele.start_point;
                                        }
                                    done = 1;
                                }
                            }
                        }
                    }

                    scope.$parent.fishbone_data = nestedData;

                    //Is one < 0 or > 100?
                    function parent_border_collision_detection(parent, start_point, min, max) {
                            for (var j = 0; j < parent.values.length; j++) {
                                if ((start_point - parent.values[j].alt_count / 2) < min) {
                                    parent.values[j].bottom = min;
                                    parent.values[j].top = parent.values[j].alt_count;
                                }
                                else if ((start_point + parent.values[j].alt_count / 2) > max) {
                                    parent.values[j].top = max;
                                    parent.values[j].bottom = max - parent.values[j].alt_count;
                                }
                                else {
                                    parent.values[j].top = (start_point + parent.values[j].alt_count / 2);
                                    parent.values[j].bottom = (start_point - parent.values[j].alt_count / 2);
                                }
                            }
                        return parent;
                        }

                    //Find where the lines of the border should be, adjusting so that no line goes below 0
                    //and no line goes above 100
                    for(var i = 0; i < plot_background.children.length; i++) {
                        var parent = nestedData[plot_background.children[i]];
                        var start_point = parent.start_point;
                        nestedData[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100);
                    }

                    //pass in nestedData, and the index representing the timepoint
                    function collision_detection(data, children, timepoint_index, min, max){
                        var range = max - min;
                        var total_alt_counts = 0;
                        for(var i = 0; i < children.length; i++){
                            //loop through children, and see where we can move the tops and bottoms
                            total_alt_counts = data[children[i]].values[timepoint_index].alt_count + total_alt_counts;
                        }
                        var space = (range - total_alt_counts);
                            space = space / (children.length+1);

                        var new_bottom = min + space;

                        for(var i = 0; i < children.length; i++){
                            data[children[i]].values[timepoint_index].bottom = new_bottom;
                            data[children[i]].values[timepoint_index].top = new_bottom + data[children[i]].values[timepoint_index].alt_count;
                            data[children[i]].values[timepoint_index].pinch_point = (data[children[i]].values[timepoint_index].top
                            + data[children[i]].values[timepoint_index].bottom)/2;
                            new_bottom = data[children[i]].values[timepoint_index].top + space;
                        }
                        return data;
                    }

                    //Find if there are any conflicts with the adjusted borders
                    for(var i = 0; i < num_of_timepoints+1; i++){
                        for(var j = 1; j < plot_background.children.length; j++){
                            var last_top = nestedData[plot_background.children[j-1]].values[i].top;
                            var current_bottom = nestedData[plot_background.children[j]].values[i].bottom;
                            if(current_bottom < last_top){
                                nestedData = collision_detection(nestedData, plot_background.children, i, 0, 100);
                                break;
                            }
                        }
                    }

                    //Adjust children top and bottom based on parents
                    for(var i = 0; i < nestedData.length; i++){
                        var parent_index = nestedData[i].parent_index_of_this;
                        if(parent_index != "plot") {
                                var parent = nestedData[parent_index]
                                var children = parent.children;
                                var start_point = parent.start_point;
                            //Potentially include and && the children has not already been checked
                            //If parent has 2+ children, then the loop below will have taken care of those children already
                            if(children.length != 0) {
                                for (var j = 0; j < children.length; j++) {
                                    var child = nestedData[children[j]];
                                    for (k = 0; k < child.values.length; k++) {
                                        var start_point_space = parent.values[k].alt_count / children.length;
                                        var start_point_base = start_point_space / 2;
                                        child.start_point = start_point_base + (start_point_space * j) + parent.values[k].bottom;
                                        child.values[k].start_point = child.start_point;
                                        if ((child.start_point - child.values[k].alt_count / 2) < parent.values[k].bottom) {
                                            child.values[k].bottom = parent.values[k].bottom;
                                            child.values[k].top = child.values[k].bottom + child.values[k].alt_count;
                                        }
                                        else if (( child.start_point + child.values[k].alt_count / 2) > parent.values[k].top) {
                                            child.values[k].top = parent.values[k].top;
                                            child.values[k].bottom = child.values[k].top - child.values[k].alt_count;
                                        }
                                        else {
                                            child.values[k].top = (child.start_point + child.values[k].alt_count / 2);
                                            child.values[k].bottom = (child.start_point - child.values[k].alt_count / 2);
                                        }
                                    }
                                }
                                for (var j = 0; j < num_of_timepoints + 1; j++) {
                                    nestedData = collision_detection(nestedData, children, j, parent.values[j].bottom, parent.values[j].top);
                                }
                            }
                        }
                    }

                    //load pinches
                    for(var i = 0; i < nestedData.length; i++){
                        var current_allele = nestedData[i];
                        for(var j = 0; j < current_allele.values.length; j++){
                            //Initialize all pinches to false
                            //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                            current_allele.values[j].pinch = false;
                        }
                        current_allele.values = find_origin(current_allele, plot_background, nestedData, yScale);
                    }

                    var topLineGen = d3.svg.line()
                            .interpolate('linear')
                            .x(function(d){
                                if(d.pinch == true){
                                    var x_pos = xScale(d.Sample_Barcode) - xScale(d.previous_timepoint);
                                    x_pos = (x_pos * 0.25);
                                    x_pos = x_pos + xScale(d.previous_timepoint);
                                    return x_pos;
                                }
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                                return yScale(d.top);
                            });

                    var bottomLineGen = d3.svg.line()
                            .interpolate('linear')
                            .x(function(d, i){
                                if(d.pinch == true){
                                    var x_pos = xScale(d.Sample_Barcode) - xScale(d.previous_timepoint);
                                    x_pos = (x_pos * 0.25);
                                    x_pos = x_pos + xScale(d.previous_timepoint);
                                    return x_pos;
                                }
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                               return yScale(d.bottom);
                            });

                    //Get all of the x-values that make up the top line (will be same as bottom, symmetrical)
                    //Then take area along y-axis between the top and bottom lines
                    var areaBetweenLines = d3.svg.area()
                            .interpolate('linear')
                            .x(topLineGen.x())
                            .y0(topLineGen.y())
                            .y1(bottomLineGen.y());


                    nestedData.forEach(function(d, i){

                        canvas.append('path')
                                .attr('fill', 'none')
                                .attr('stroke-width', 5)
                                .attr("stroke", "transparent")
                                .style("stroke-linejoin", "round")
                                .attr('d', topLineGen(d.values));

                        canvas.append('path')
                                .attr('fill', 'none')
                                .attr("stroke", "transparent")
                                .style("stroke-linejoin", "round")
                                .attr('stroke-width', 8)
                                .attr('d', bottomLineGen(d.values));

                        canvas.append('path')
                                .datum(d.values)
                                .attr('fill', fillColors[i])
                                .attr('opacity', 0.75)
                                .attr('d', areaBetweenLines);
                    });



                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + 500 + ")")
                        .call(xAxis);

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);

                }, true);
            }

        }, true);

    })();

</script>
<body ng-controller = "tevDataController">
<!--
Dont need to provide alleles to figure 1 because all that's changing is the colors
-->
<div id="figure1" figure1-plot data="clustered_alleleified_data" style="width: 650px; height: 650px; float:left;">
</div>


<div id="figure2" figure2-plot data="[clustered_alleleified_data, alleles]" style="width: 700px; height: 650px; float: left;">
</div>

<div id="figure3" figure3-plot data="[dendro_data, dendro_y_data, alleleified_data]"
     style="width: 550px; height: 600px; float: left;">
</div>


<div id="figure4" figure4-plot data="fishbone_data" style="width: 550px; height: 550px; float: left;">
</div>

<div id="figure5" figure5-plot data="linked_alleleified_data" style="width: 600px; height: 600px; float: left;">
</div>

</body>
</html>