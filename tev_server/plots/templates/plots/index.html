<!DOCTYPE html>
<html lang="en" ng-app = "tevApp">
<head>
    <meta charset="UTF-8">
    <title>TEV</title>
</head>
<style>
    .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .node circle {
        stroke-width: 1.5px;
    }

    .node_text {
        font: 10px sans-serif;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 1.5px;
    }

    .info_rects,.median_line:hover {
        cursor: pointer;
    }

    div.tooltip {
        position: absolute;
        text-align: center;
        width: 120px;
        height: 40px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
    }

    .noselect {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

</style>

<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.js"></script>
<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"
      integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7"
      crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css"
      integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r"
      crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"
        integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS"
        crossorigin="anonymous"></script>

<script>

    //Function to calculate CCF based on ploidy and purity specified
    function find_CCFs(independent_evos, counter, nested_data, num_of_cancer_cells, num_of_evos, cells_per_evo_array, timepoints, options){
        //need to update to keep track of how many times we need to recursively call this function
        var max_cells_of_this_evo = num_of_cancer_cells; //- (num_of_evos-1);

        if((counter == num_of_evos) && (num_of_evos == 1)){
            return;
        }

        //The following lines of this function are for generating all possible combinations of cell counts per
        //independent clonal expansion based on the purity
        //initialize cells_per_evo_array
        if((counter == num_of_evos) && (counter > 1)){
            counter =  counter-1;
            for(var i = 0; i < max_cells_of_this_evo+1; i++){
                cells_per_evo_array.push(i);
                find_CCFs(independent_evos, counter, nested_data, num_of_cancer_cells, num_of_evos, cells_per_evo_array, timepoints, options);
                cells_per_evo_array = [];
            }
        }

        //if this is not the last independent evolution, continue with the process
        //generate additional combinations if the below is true
        if((counter > 1) && (counter < num_of_evos)) {
            counter = counter - 1;
            for (var i = 0; i < max_cells_of_this_evo + 1; i++) {
                var cells_array  = cells_per_evo_array.slice();
                cells_array.push(i);
                var sum = cells_array.reduce(function(a, b){
                    return a+b;
                }, 0);
                //if we've already reached our limit, break out of the loop
                if(sum > num_of_cancer_cells){
                   break;
                }
                else {
                    find_CCFs(independent_evos, counter, nested_data, num_of_cancer_cells, num_of_evos, cells_array, timepoints, options);
                }
            }
        }
        //else if we are on the last one, start checking the combinations
        if((counter == 1) && (counter != num_of_evos)){
            if(cells_per_evo_array.length != 0) {
                for (var i = 0; i < max_cells_of_this_evo+1; i++) {
                    var cells_array  = cells_per_evo_array.slice();
                    cells_array.push(i);
                    sum = cells_array.reduce(function (a, b) {
                        return a + b;
                    }, 0);
                    if(sum > num_of_cancer_cells){
                        break;
                    }
                    //if we have a good combination, see if it is possible to calculate the cancer cell fraction
                    if ((sum == num_of_cancer_cells) && (cells_array.length == num_of_evos)) {
                        //function to see if there is a solution using the given ploidys
                        calculate_CCF(cells_array, independent_evos, nested_data, num_of_cancer_cells, timepoints, options);
                    }
                    else {
                        continue;
                    }
                }
            }
        }
    }

    //Function to see if there is a solution for CCF given the independent clonal expansions and cell ploidys
    //cells_per_evo_array contains proposed cell counts for all independent clonal expansions except the last listed one
    function calculate_CCF(cells_per_evo_array, independent_evos, nested_data, num_of_cancer_cells, timepoints, options){
        var normal_cells =  100-num_of_cancer_cells;
        //number of chromosomes coming from normal (impure) cells
        var num_chrs_normal_cells = normal_cells*2;

        //calculate total number of chromosomes
        var total_chromosomes = calculate_chromosome_total(cells_per_evo_array, num_chrs_normal_cells, nested_data, independent_evos);

        //and the number of chromosomes in each independent clonal expansion
        var chromosome_counts = {};

        //get the cells counts from each independent clonal expansion by adding the last cell count to array
        var all_evo_cell_counts = cells_per_evo_array;

        //Initialize the chromosome count coming from normal cells
        chromosome_counts.normal = num_chrs_normal_cells;

        for (var t = 0; t < timepoints.length; t++) {
            chromosome_counts[timepoints[t].toString()] = {};
            for (var i = 0; i < independent_evos.length; i++) {
                //calculate number of chromsomes from each specific independent evolution
                //by multiplying number of cells for that independent evolution by the proposed ploidy of those cells
                var chrs_for_this_evo = all_evo_cell_counts[i] * nested_data[independent_evos[i]].ploidy;
                chromosome_counts[timepoints[t].toString()][nested_data[independent_evos[i]].key] = chrs_for_this_evo;
            }
        }

        var chromosomes_affected_of_each = [];
        var will_work = true;

        for(var t = 1; t < timepoints.length; t++) {
            //console.log(timepoints[t]);
            if(will_work == false){
                break;
            }
            for (var i = 0; i < independent_evos.length; i++) {
                //variant allele frequency
                var vaf = nested_data[independent_evos[i]].values[t].alt_count;
                var chromosomes_needed = total_chromosomes * (vaf/100);
                chromosomes_needed = Math.round(chromosomes_needed);

                //console.log(nested_data[independent_evos[i]].key);
                //console.log(chromosomes_needed, " --- ", chromosome_counts[timepoints[t].toString()][nested_data[independent_evos[i]].key]);

                //if the number of cells we have for this independent evolution is less than the chromosomes needed for
                //the VAF at this timepoint, then it wont work
                if ((chromosomes_needed < all_evo_cell_counts[i]) && (nested_data[independent_evos[i]].values[t].alt_count != 0)) {
                    will_work = false;
                    break;
                }

                if (chromosomes_needed > ((chromosome_counts[timepoints[t].toString()][nested_data[independent_evos[i]].key]) + nested_data[independent_evos[i]].ploidy-1)) {
                    will_work = false;
                    break;
                }

                //else, try to find the closest number of chromosomes affected per independent evolution
                else {
                    var proportions = generate_portions(nested_data[independent_evos[i]].ploidy);
                    var proportion_affected = chromosomes_needed / chromosome_counts[timepoints[t].toString()][nested_data[independent_evos[i]].key];
                    var closest_proportion = find_closest_proportion(proportions, proportion_affected);
                    var num_of_chromosomes_affected = proportions.indexOf(closest_proportion) + 1;
                    chromosomes_affected_of_each.push(num_of_chromosomes_affected);
                }
            }
        }
        console.log(will_work);
        if(will_work == true){
            options.push(chromosome_counts);
        }
        return;
    }

    //function to generate possible proportions of chromosomes affected in cell based on ploidy
    function generate_portions(ploidy){
        var proportions_array = [];
        var increment = 1/ploidy;
        for(var i = 0; i < ploidy; i++){
            var proportion = (i+1)*increment;
            proportion = parseFloat(proportion.toFixed(2));
            proportions_array.push(proportion);
        }
        return proportions_array;
    }

    //calculate the total number of chromosomes based on the purity, ploidy, and cells distribution
    function calculate_chromosome_total(cells_per_evo_array, num_chrs_normal_cells, nested_data, independent_evos) {
        var total_chromosomes = num_chrs_normal_cells;
        for (var i = 0; i < cells_per_evo_array.length; i++) {
            var chrs_for_this_evo = cells_per_evo_array[i] * nested_data[independent_evos[i]].ploidy;
            total_chromosomes = total_chromosomes + chrs_for_this_evo;
        }
        return total_chromosomes;
    }

    //find the closest proportion of chromosomes affected by variation
    function find_closest_proportion(proportions, proportion_affected){
        var closest = proportions[0];
        for(var i = 1; i < proportions.length; i++){
            if(Math.abs(proportion_affected-proportions[i]) < Math.abs(proportion_affected-closest)){
                closest = proportions[i];
            }
        }
        return closest;
    }

    //Find unique values for oridinal scale
    function uniqueAxisLabels(data, key) {
        var unique = {};
        var distinct = [];
        data.forEach(function (x) {
            if (!unique[x[key]]) {
                distinct.push(x[key]);
                unique[x[key]] = true;
            }
        });

        return distinct;
    }


    //Find difference between two arrays
    Array.prototype.diff = function(a) {
    return this.filter(function(i) {return a.indexOf(i) < 0;});
    };

    //Sort each allele in nested data by timepoint
    function sort_nested_alleles(nested_data){
        for(var i = 0; i < nested_data.length; i++){
            nested_data[i].values = nested_data[i].values.sort(function(a, b){
               return a.Sample_Barcode - b.Sample_Barcode;
            });
        }
        return nested_data;
    }


    //Order fish plot data by first timepoint, and then by alternative allele freq
    //Directives used in: figure5Plot
    function order_by_rank(data, rank_data){
        var reordered_data = [];
        for(var i = 0; i < data.length; i++){
            var current_allele = data.findIndex(x => x.key == rank_data[i].allele);
            current_allele = data[current_allele];
            reordered_data[i] = current_allele;
        }
        return reordered_data;
    }


    //Dirty way of adding origin (tail fin of fish plot)
    //Important to unshift, because the order of the x-values matters when using d3.line.svg()!
    function add_origin(nestedData, Sample_Barcode) {
        for (var i = 0; i < nestedData.length; i++) {
            var allele_cluster = nestedData[i].values[0].cluster;
            nestedData[i].values.unshift({
                Sample_Barcode: Sample_Barcode,
                alt_count: 0,
                allele: nestedData[i].key,
                cluster: allele_cluster
            });
        }
        return nestedData;
    }

    //Is one < 0 or > 100?
    function parent_border_collision_detection(parent, start_point, min, max) {
        for (var j = 0; j < parent.values.length; j++) {
            if ((start_point - parent.values[j].alt_count / 2) < min) {
                parent.values[j].bottom = min;
                parent.values[j].top = parent.values[j].alt_count;
            }
            else if ((start_point + parent.values[j].alt_count / 2) > max) {
                parent.values[j].top = max;
                parent.values[j].bottom = max - parent.values[j].alt_count;
            }
            else {
                parent.values[j].top = (start_point + parent.values[j].alt_count / 2);
                parent.values[j].bottom = (start_point - parent.values[j].alt_count / 2);
            }
        }
        return parent;
    }


    //pass in nestedData, and the index representing the timepoint
    function collision_detection(data, children, timepoint_index, min, max) {
        var range = max - min;
        var total_alt_counts = 0;
        for (var i = 0; i < children.length; i++) {
            //loop through children, and see where we can move the tops and bottoms
            total_alt_counts = data[children[i]].values[timepoint_index].alt_count + total_alt_counts;
        }
        var space = (range - total_alt_counts);
        space = space / (children.length + 1);

        var new_bottom = min + space;

        for (var i = 0; i < children.length; i++) {
            data[children[i]].values[timepoint_index].bottom = new_bottom;
            data[children[i]].values[timepoint_index].top = new_bottom + data[children[i]].values[timepoint_index].alt_count;
            data[children[i]].values[timepoint_index].pinch_point = (data[children[i]].values[timepoint_index].top
                    + data[children[i]].values[timepoint_index].bottom) / 2;
            new_bottom = data[children[i]].values[timepoint_index].top + space;
        }
        return data;
    }


    //Find if there are any conflicts with the adjusted borders for the independent evolutions
    //And adjust the borders if there are any conflicts
    function adjust_independent_evolution_positions(nestedData, plot_background, num_of_timepoints) {
        for (var i = 0; i < num_of_timepoints + 1; i++) {
            for (var j = 1; j < plot_background.children.length; j++) {
                var last_top = nestedData[plot_background.children[j - 1]].values[i].top;
                var current_bottom = nestedData[plot_background.children[j]].values[i].bottom;
                if (current_bottom < last_top) {
                    nestedData = collision_detection(nestedData, plot_background.children, i, 0, 100);
                    break;
                }
            }
        }
    }


    //Adjust children top and bottom based on parents
    function adjust_children_positioning(nestedData, num_of_timepoints) {
        for (var i = 0; i < nestedData.length; i++) {
            var parent_index = nestedData[i].parent_index_of_this;
            //Added || != 'none' to satisfy fishplot editor (Had to add separate if statement for some reason??)
            //All fishplots that havent been placed down yet have a parent_index of 'none'
            //This is so I can do the collision prevention for the children that are already plotted
            if (parent_index != "plot") {
                if (parent_index != "none") {
                    var parent = nestedData[parent_index];
                    var children = parent.children;
                    var start_point = parent.start_point;
                    //Potentially include an && the children has not already been checked
                    //If parent has 2+ children, then the loop below will have taken care of those children already
                    if (children.length != 0) {
                        for (var j = 0; j < children.length; j++) {
                            var child = nestedData[children[j]];
                            for (k = 0; k < child.values.length; k++) {
                                var start_point_space = parent.values[k].alt_count / children.length;
                                var start_point_base = start_point_space / 2;
                                child.start_point = start_point_base + (start_point_space * j) + parent.values[k].bottom;
                                child.values[k].start_point = child.start_point;
                                if ((child.start_point - child.values[k].alt_count / 2) < parent.values[k].bottom) {
                                    child.values[k].bottom = parent.values[k].bottom;
                                    child.values[k].top = child.values[k].bottom + child.values[k].alt_count;
                                }
                                else if (( child.start_point + child.values[k].alt_count / 2) > parent.values[k].top) {
                                    child.values[k].top = parent.values[k].top;
                                    child.values[k].bottom = child.values[k].top - child.values[k].alt_count;
                                }
                                else {
                                    child.values[k].top = (child.start_point + child.values[k].alt_count / 2);
                                    child.values[k].bottom = (child.start_point - child.values[k].alt_count / 2);
                                }
                            }
                        }
                        for (var j = 0; j < num_of_timepoints + 1; j++) {
                            nestedData = collision_detection(nestedData, children, j, parent.values[j].bottom, parent.values[j].top);
                        }
                    }
                }
            }
        }
        return nestedData;
    }


    //Function to find the actual origin of the fishplots
    //Directives used in: figure5Plot
    function find_origin(current_allele){
        var allele_data = current_allele.values;
        var zeroes = [];
        //Find out if "origin" is the only timepoint that has an alternative allele frequency of zero
        for(var i = 0; i < allele_data.length; i++){
            if(allele_data[i].alt_count == 0){
                zeroes.push(i);
            }
            else {
                break;
            }
        }
        //If "origin" is not the actuall origin of the tumor
        //Trim the data until one timepoint before the actual origin
        if(zeroes.length > 1){
                allele_data.splice(0, zeroes.length - 1);
            }
        return allele_data;
    }

    //Reformat the data based on the cutoff point of the slider in the elbow dendrogram (Figure 3)
    //Directives used in: figure3Plot
    function cut_data(max_path_y, alleleified_data, nodes) {
        var new_data = [];
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].y <= max_path_y) {
                new_data.push(nodes[i]);
            }
        }
        var upper_level_data = [];
        var used_nodes = [];
        for (var i = 0; i < new_data.length; i++) {
            var allele_level_data = [];
            var current_data = new_data[i];
            if (current_data.name != " " && used_nodes.indexOf(current_data.id) == -1) {
                used_nodes.push(current_data.id);
                allele_level_data.push(current_data.name);
                upper_level_data.push(allele_level_data);
                nodes[nodes.indexOf(current_data)].cluster = upper_level_data.length;
            }
            else if (current_data.name == " " && used_nodes.indexOf(current_data.id) == -1) {
                var cluster = upper_level_data.length + 1;
                get_all_children(current_data, used_nodes, allele_level_data, nodes, cluster);
                upper_level_data.push(allele_level_data);
            }
        }
        var updated_linked_alleleified_data = convert_to_allelified(alleleified_data, upper_level_data);
        var new_alleleified_data = update_alleleified_data(alleleified_data, upper_level_data);
        return [updated_linked_alleleified_data, new_alleleified_data, upper_level_data];
    }

    //Convert newly cut data into linked alleleified data, so it is readable by fishplot & fishbone
    //Directives used in: figure3Plot
    function convert_to_allelified(alleleified_data, upper_level_data) {
        var new_linked_alleleified_data = [];
        var allele;
        for (var i = 0; i < upper_level_data.length; i++) {
            var allele_list = upper_level_data[i];
            var parent_allele = upper_level_data[i][0];
            if (allele_list.length > 1) {
                var new_allele_name = allele_list.join("\n");
            }
            else {
                new_allele_name = allele_list[0];
            }
            for (var j = 0; j < alleleified_data.length; j++) {
                //Now generate data grouping the alleles for the fishbone and fishplot
                if (alleleified_data[j].allele == parent_allele) {
                    allele = JSON.parse(JSON.stringify(alleleified_data[j]));
                    allele.allele = new_allele_name;
                    new_linked_alleleified_data.push(allele);
                }
            }
        }
        return new_linked_alleleified_data;
    }

    //Update the clusters of the alleleified data for the line plot and box plot
    //Directives used in: figure3Plot
    function update_alleleified_data(alleleified_data, upper_level_data) {
        for (var i = 0; i < upper_level_data.length; i++) {
            var allele_list = upper_level_data[i];
            for (var j = 0; j < alleleified_data.length; j++) {
                for (var k = 0; k < allele_list.length; k++) {
                    if (alleleified_data[j].allele == allele_list[k]) {
                        alleleified_data[j].cluster = i + 1;
                    }
                }
            }
        }
        return alleleified_data;
    }

    //If the cutoff point of the slider is above a node that isn't directly associated with an allele
    //Find all of the alleles (children) under that node
    //Directives used in: figure3Plot
    function get_all_children(current_data, used_nodes, allele_level_data, nodes, cluster) {
        if (current_data.children != undefined) {
            for (var i = 0; i < current_data.children.length; i++) {
                if (current_data.children[i].name == " ") {
                    used_nodes.push(current_data.children[i].id);
                    get_all_children(current_data.children[i], used_nodes, allele_level_data, nodes, cluster);
                }
                else {
                    if (used_nodes.indexOf(current_data.children[i].id) == -1) {
                        nodes[nodes.indexOf(current_data.children[i])].cluster = cluster;
                        used_nodes.push(current_data.children[i].id);
                        allele_level_data.push(current_data.children[i].name);
                    }
                }
            }
        }
    }

    //Function to correctly format data passed from fishplot (figure5Plot) to fishbone (figure4Plot) for d3 dendrogram
    //Directives used in: figure4Plot
    function add_children(child, parent, data) {
        var childData = {name: child.key, children: [], cluster: child.values[0].cluster};
        parent.children.push(childData);

        for (var i = 0; i < child.children.length; i++) {
            var newChild = data[child.children[i]];
            add_children(newChild, childData, data);
        }
    }


    (function() {

        //Application name: tevApp
        //Dependencies: None
        var tevApp = angular.module('tevApp', []);

        //To distinguish between Django variables used in HTML
        tevApp.config(function($interpolateProvider) {
            $interpolateProvider.startSymbol('{$');
            $interpolateProvider.endSymbol('$}');
        });

        tevApp.factory('alleleify', function(){
            return {
                alleleify: function(data, gene_data){
                    var allele_data = [];

                    //Loop through to get all uuid
                    //So we only have to access them, instead of loop through for every amino acid change
                    var gene_uuids = [];
                    for(var i = 0; i < gene_data.length; i++){
                        gene_uuids.push(gene_data[i].uuid);
                    }

                    for(var i = 0; i < data.length; i++){
                        var timepoint = data[i].timepoint;
                        var alleles = data[i].VariantAlleles;
                        for(var j = 0; j < alleles.length; j++){
                            var allele = gene_data[gene_uuids.indexOf(alleles[j].gene)].name
                                    + '-'
                                    + alleles[j].AA_original
                                    + alleles[j].AA_position.toString()
                                    + alleles[j].AA_variant;
                            var alt_count = alleles[j].alternative_freq;
                            allele_data.push({
                                allele: allele,
                                Sample_Barcode: timepoint,
                                alt_count: alt_count
                            });
                        }
                    }
                    return allele_data;
                },

                patch: function(data){
                    var timepoints = uniqueAxisLabels(data, 'Sample_Barcode');
                    data.sort(function(a,b) {return (a.allele > b.allele) ? 1 : ((b.allele > a.allele) ? -1 : 0);} );

                    var current_allele = data[0].allele;
                    var timepoints_hit = [];
                    var unhit_array = [];

                    for(var i = 0; i < data.length; i++){
                        if(data[i].allele == current_allele){
                            timepoints_hit.push(data[i].Sample_Barcode);
                        }
                        else{
                            var unhit_timepoints = timepoints.diff(timepoints_hit);
                            for(var j = 0; j < unhit_timepoints.length; j++){
                                unhit_array.push({
                                    allele: current_allele,
                                    Sample_Barcode: unhit_timepoints[j],
                                    alt_count: 0
                                });
                            }
                            timepoints_hit = [];
                            current_allele = data[i].allele;
                            timepoints_hit.push(data[i].Sample_Barcode);
                        }
                    }
                    //Get the unhit timepoints from last remaining allele
                    unhit_timepoints = timepoints.diff(timepoints_hit);
                    for(var j = 0; j < unhit_timepoints.length; j++){
                                unhit_array.push({
                                    allele: current_allele,
                                    Sample_Barcode: unhit_timepoints[j],
                                    alt_count: 0
                                });
                            }

                    data = data.concat(unhit_array);
                    return data;
                }
            };
        });

        //Controller name: TevDataController
        //Services: scope, http
        tevApp.controller('tevDataController', ['$scope', '$http', '$filter', 'alleleify', '$q',
            function($scope, $http, $filter, allelify, $q){
            //Initialize the scopes data to empty (will render blank plots until we've fetched data)
                $scope.tevData = [];
                $scope.alleleified_data = [];
                $scope.linked_alleleified_data = [];
                $scope.dendro_data = [];
                $scope.dendro_y_data = [];
                $scope.fishbone_data = [];
                //Created this variable because if alleleified_data is changed by dendrogram grouping,
                // it would keep calling itself
                $scope.clustered_alleleified_data = [];
                $scope.alleles = [];

                var source_uuid = '{{ source }}';
                var dendro_data = {{ d3_dendro_data|safe }};
                var dendro_y_data = {{ dendro_y_data }};

                //Get the data from the API
                var source_request = $http.get('http://127.0.0.1:8000/api/v1/sources/');
                var gene_request = $http.get('http://127.0.0.1:8000/api/v1/genes/');

                $q.all([source_request, gene_request]).then(function(results_array){
                    var tevData = results_array[0].data;
                    var gene_data = results_array[1].data;
                    tevData = $filter('filter')(tevData, {'uuid': source_uuid})[0];
                    $scope.tevData = tevData.Samples;

                    var alleleified_data = allelify.alleleify($scope.tevData, gene_data);
                    alleleified_data = allelify.patch(alleleified_data);
                    $scope.alleleified_data = alleleified_data;

                    //Send through this data, when the data from the API has been recieved
                    $scope.dendro_data = dendro_data;
                    $scope.dendro_y_data = dendro_y_data;
                });
        }]);

        //Directive that contains d3 code to render allele frequency change over timepoints
        //Plot type: Line plot
        tevApp.directive('figure1Plot', function(){
            return {
               scope: {
                   data: '='
               },
               restrict: 'A',
               link: link
           };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;
                var strokeColors = ['#a6cee3','#1f78b4','#b2df8a','#33a02c', '#fb9a99', '#e31a1c',
                                    '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99','#b15928'];

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    d3.select(el).select('div').remove();

                    data = updatedData;

                    if(data.length == 0){
                        return;
                    }

                    var canvas = d3.select(el).append("svg")
                        .attr("height", height)
                        .attr("width", width);

                    var div_tooltip = d3.select(el).append("div")
                            .attr("class", "tooltip")
                            .style("opacity", 0);

                    var yScale = d3.scale.linear().range([40, height-40]).domain([1, 0]);
                    var yAxis = d3.svg.axis().scale(yScale).orient("left");

                    var axisLabels = uniqueAxisLabels(data, 'Sample_Barcode');
                    axisLabels = axisLabels.sort(function(a, b){
                       return a - b;
                    });

                    var xScale = d3.scale.ordinal().rangePoints([40, width-40], 0.5).domain(axisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    var lineGen = d3.svg.line()
                            .x(function(d){
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                                return yScale(d.alt_count/100);
                            });

                    var nestedData = d3.nest()
                            .key(function(d){
                               return d.allele;
                            })
                            .entries(data);

                    nestedData = sort_nested_alleles(nestedData);

                    var lineSvg = canvas.append("g");
                    var pointSvg = canvas.append("g");

                    nestedData.forEach(function(d, i){

                        lineSvg.append("path")
                                .attr("fill", "none")
                                .attr("stroke", function(){
                                    var index = d.values[0].cluster-1;
                                    return strokeColors[index];
                                })
                                .attr("stroke-width", 2)
                                .attr("d", lineGen(d.values));

                        pointSvg.selectAll("timepoints")
                                .data(d.values)
                                .enter()
                                .append("rect")
                                .attr("x", function(d){
                                    return (xScale(d.Sample_Barcode)-5);
                                })
                                .attr("y", function(d){
                                    return (yScale(d.alt_count/100) - 5);
                                })
                                .attr("width", 12)
                                .attr("height", 12)
                                .attr('class', 'info_rects')
                                .attr("fill", function(){
                                    var index = d.values[0].cluster-1;
                                    return strokeColors[index];
                                })
                                .on("mouseover", function(d){
                                    div_tooltip.style("opacity", 0.9)
                                    .html('<b>' +d.Sample_Barcode + '</b>'+ '<br/>' + '<br/>'
                                            + d.allele + ': ' + '<b>' + d.alt_count + '</b>')
                                            .style("top", (d3.event.pageY-40) + "px")
                                            .style("left", (d3.event.pageX + 40) + "px");
                                })
                                .on("mouseout", function(){
                                    div_tooltip.style('opacity', 0);
                                });

                    });

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + (height-40) + ")")
                        .call(xAxis);

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);

                }, true);
            }
        });

        //Directive that contains d3 code to render distribution of allele frequency at timepoints
        //Plot type: Box plots
        tevApp.directive('figure2Plot', function(){
            return{
                restrict: 'A',
                link: link,
                scope: {
                    data: '='
                }
            };

            function link(scope, element){
                var data = scope.data[0];
                var alleles = scope.data[1];
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;
                var fillColors = ['#a6cee3','#1f78b4','#b2df8a','#33a02c', '#fb9a99', '#e31a1c',
                                    '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99','#b15928'];


                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    d3.select(el).select('div').remove();

                    data = updatedData[0];
                    alleles = updatedData[1];

                    if(data.length == 0){
                        return;
                    }

                    var canvas = d3.select(el).append("svg")
                        .attr("height", height)
                        .attr("width", width);

                    var information = ['90th:', 'Q3:', 'median:', 'Q1:', '10th:'];
                    var informationSvg = canvas.append("g");

                    informationSvg.selectAll("information_text")
                            .data(information)
                            .enter()
                            .append('text')
                            .attr('x', 520)
                            .attr('y', function(d, i){
                                return 60 + (25*i);
                            })
                            .style('font', '12px sans-serif')
                            .style('text-anchor', 'left')
                            .text(function(d){return d;});

                    var div_tooltip = d3.select(el).append("div")
                            .attr("class", "tooltip")
                            .style("opacity", 0);

                    var axisLabels = uniqueAxisLabels(data, 'cluster');
                    axisLabels.sort(function(a, b){
                       return a - b;
                    });

                    var yScale = d3.scale.linear().range([40, height-40]).domain([1, 0]);
                    var yAxis = d3.svg.axis().scale(yScale).orient("left");

                    var xScale = d3.scale.ordinal().rangePoints([40, width-40], 0.5).domain(axisLabels);
                    var xAxis = d3.svg.axis().scale(xScale);

                    if(alleles.length == axisLabels.length){
                        axisLabels = uniqueAxisLabels(data, 'allele');
                        var nestedData = d3.nest().key(function(d){return d.allele}).entries(data);
                        xScale = d3.scale.ordinal().rangePoints([40, width-40], 0.5).domain(axisLabels);
                        xAxis = d3.svg.axis().scale(xScale);
                    }
                    else{
                        nestedData = d3.nest().key(function(d){return d.cluster}).entries(data);
                        xAxis.tickFormat(function(d){return "cluster " + d;})
                    }

                    var boxData = [];
                    nestedData.forEach(function(d, i){
                        var quartileData = [];
                        var alleles = [];
                        for(var j = 0; j < d.values.length; j++){
                            quartileData[j] = d.values[j].alt_count/100;
                            if(alleles.indexOf(d.values[j].allele) == -1){
                                alleles.push(d.values[j].allele);
                            }
                        }
                        alleles = alleles.join('<br/>')
                        alleles = '<b> alleles </b><br/>' + alleles;
                        quartileData.sort(function(a,b) { return a - b;});

                        boxData[i] = {
                            x: d.key,
                            y: d3.quantile(quartileData, 0.75),
                            Q3: d3.quantile(quartileData, 0.75).toFixed(2),
                            Q1: d3.quantile(quartileData, 0.25).toFixed(2),
                            median: d3.median(quartileData).toFixed(2),
                            pNinety: d3.quantile(quartileData, 0.90).toFixed(2),
                            pTen: d3.quantile(quartileData, 0.10).toFixed(2),
                            color: fillColors[d.values[0].cluster-1],
                            alleles: alleles

                        };
                    });

                    //Start of d3 box plot
                    canvas.selectAll('boxes')
                            .data(boxData)
                            .enter()
                            .append('rect')
                            .attr('x', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('y', function(d){
                                return yScale(d.Q3);
                            })
                            .attr('width', 20)
                            .attr('height', function(d){
                                return (yScale(d.Q1) - yScale(d.Q3));
                            })
                            .attr('class', 'info_rects')
                            .attr('fill', function(d){
                               return d.color;
                            })
                            .on('mouseover', function(d){
                                var box_information = [d.pNinety, d.Q3, d.median, d.Q1, d.pTen];
                                informationSvg.selectAll('information_text')
                                        .data(box_information)
                                        .enter()
                                        .append('text')
                                        .attr('x', 520+50)
                                        .attr('y', function(d, i){
                                            return 60 + (25*i);
                                        })
                                        .attr('class', 'box_info')
                                        .style('font', '12px sans-serif')
                                        .style('text-anchor', 'left')
                                        .text(function(d){
                                           return d;
                                        });

                                div_tooltip.style("opacity", 0.9)
                                    .html(d.alleles)
                                        .style("top", (d3.mouse(this)[1] - 40) + "px")
                                        .style("left", (d3.mouse(this)[0] + 40) + "px");
                            })
                            .on('mouseout', function(d){
                                d3.selectAll('.box_info').remove();

                                div_tooltip.style('opacity', 0);
                            });

                    canvas.selectAll('upperVerticalBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x);
                            })
                            .attr('x2', function(d){
                                return xScale(d.x);
                            })
                            .attr('y1', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('y2', function(d){
                                return yScale(d.Q3);
                            })
                            .attr('fill', 'none')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1);


                    canvas.selectAll('lowerVerticalBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x);
                            })
                            .attr('x2', function(d){
                                return xScale(d.x);
                            })
                            .attr('y1', function(d){
                                return yScale(d.Q1);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('pNinetyBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pNinety);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('pTenBars')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('y2', function(d){
                                return yScale(d.pTen);
                            })
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    canvas.selectAll('medianLines')
                            .data(boxData)
                            .enter()
                            .append('line')
                            .attr('x1', function(d){
                                return xScale(d.x) - 10;
                            })
                            .attr('x2', function(d){
                                return xScale(d.x) + 10;
                            })
                            .attr('y1', function(d){
                                return yScale(d.median);
                            })
                            .attr('y2', function(d){
                                return yScale(d.median);
                            })
                            .attr('class', 'median_line')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none')
                            .on('mouseover', function(d){
                                if(d.Q1 == d.Q3) {
                                    var box_information = [d.pNinety, d.Q3, d.median, d.Q1, d.pTen];
                                    informationSvg.selectAll('information_text')
                                            .data(box_information)
                                            .enter()
                                            .append('text')
                                            .attr('x', 520 + 50)
                                            .attr('y', function (d, i) {
                                                return 60 + (25 * i);
                                            })
                                            .attr('class', 'box_data')
                                            .style('font', '12px sans-serif')
                                            .style('text-anchor', 'left')
                                            .text(function (d) {
                                                return d;
                                            });

                                    div_tooltip.style("opacity", 0.9)
                                            .html(d.alleles)
                                            .style("top", (d3.event.y - 40) + "px")
                                            .style("left", (d3.event.x + 40) + "px");
                                }
                            })
                            .on('mouseout', function(d){
                                if(d.Q1 == d.Q3) {
                                    d3.selectAll('.box_data').remove();

                                    div_tooltip.style('opacity', 0);
                                }
                            });

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + (height-40) + ")")
                        .call(xAxis)
                            .selectAll("text")
                            .style('text-anchor', 'end')
                            .attr('transform', 'rotate(-65)');

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);
                }, true);
            }
        });

        //Directive that contains d3 code to render dendrogram clustered by alternative allele freq
        //Plot type: Elbow dendrogram
        tevApp.directive('figure3Plot', function(){

            return {
               restrict: 'A',
               scope: {
                   data: '='
               },
               link: link
            };

            function link(scope, element){
                var data = scope.data[0];
                var dendro_y_positions = scope.data[1];
                var alleleified_data = scope.data[2];
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var fillColors = ['#a6cee3','#1f78b4','#b2df8a','#33a02c', '#fb9a99', '#e31a1c',
                                    '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99','#b15928'];

                var cluster = d3.layout.cluster()
                        .size([420, 420]);

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();
                    var alleles = [];

                    data = updatedData[0];
                    dendro_y_positions = updatedData[1];
                    alleleified_data = updatedData[2];

                    if(alleleified_data.length == 0){
                        return;
                    }

                    var canvas = d3.select(el).append('svg')
                            .attr('height', height)
                            .attr('width', width);

                    var sliderSvg = canvas.append('g');

                    canvas = canvas.append('g')
                            .attr('transform', 'translate(0, 75)');

                    var nodes = cluster.nodes(data);
                    var links = cluster.links(nodes);

                    //Update dendrogram position based on python clustering position
                    nodes.forEach(function(d, i){
                        d.y = dendro_y_positions[i];
                        d.id = i;
                    });

                    var drag = d3.behavior.drag()
                                .on('drag', function () {
                                    var slider = d3.select(this);
                                    var max_path_y = yScale.invert(30);
                                    if (d3.event.x < 30) {
                                        slider.attr('cx', 30);
                                        d3.select('#cutoff_line').attr('x1', 30).attr('x2', 30);
                                        max_path_y = yScale.invert(30);
                                    }
                                    else if (d3.event.x > 450) {
                                        slider.attr('cx', 450);
                                        d3.select('#cutoff_line').attr('x1', 450).attr('x2', 450);
                                        max_path_y = yScale.invert(450);
                                    }
                                    else {
                                        slider.attr('cx', d3.event.x);
                                        var cutoff = d3.select('#cutoff_line').attr('x1', d3.event.x).attr('x2', d3.event.x);
                                        max_path_y = yScale.invert(d3.event.x);
                                    }
                                    var linked_alleleified_data = cut_data(max_path_y, alleleified_data, nodes);
                                    var clusters = linked_alleleified_data[2];
                                    for(var i = 0; i < clusters.length; i++){
                                        var alleles_in_cluster = clusters[i];
                                        for(var j = 0; j < alleles_in_cluster.length; j++){
                                            var id = '#allele' + alleles.indexOf(alleles_in_cluster[j]);
                                            var node = d3.select(id);
                                            node.attr('fill', fillColors[i]);
                                        }
                                    }
                                    scope.$apply(function(){
                                        scope.$parent.linked_alleleified_data = linked_alleleified_data[0];
                                        scope.$parent.clustered_alleleified_data = linked_alleleified_data[1];
                                    });
                                });

                    sliderSvg.append('line')
                            .attr('x1', 30)
                            .attr('x2', 450)
                            .attr('y1', 50)
                            .attr('y2', 50)
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1.5)
                            .attr('fill', 'none');

                    sliderSvg.append('circle')
                            .attr('r', 7)
                            .attr('cy', 50)
                            .attr('cx', 450)
                            .attr('id', 'slider_circle')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 0.5)
                            .attr('fill', '#EEEEEE')
                            .style('cursor', 'pointer')
                            .call(drag);

                    var y_max = Math.max.apply(null, dendro_y_positions);
                    var yScale = d3.scale.linear().domain([y_max, 0]).range([30, 450]);
                    var yAxis = d3.svg.axis().scale(yScale).orient('top');

                    var link = canvas.selectAll('.link')
                            .data(links)
                            .enter()
                            .append('path')
                            .attr('class', 'link')
                            .attr('d', function elbow(d, i) {
                                return "M" + yScale(d.source.y) + "," + d.source.x
                                        + "V" + d.target.x + "H" + yScale(d.target.y);
                            })
                            .attr('fill', 'none')
                            .attr('stroke', "#ccc")
                            .attr('stroke-width', 1.5)
                            .attr('transform', 'translate(0,40)');

                    var node = canvas.selectAll('.node')
                            .data(nodes)
                            .enter()
                            .append('g')
                            .attr('transform', function(d){return "translate("+ yScale(d.y) + "," + (d.x + 40) + ")";});

                    node.append('circle')
                            .attr('r', function(d){
                                if(d.name == " "){
                                    return 0;
                                }
                                return 4.5;
                            })
                            .attr('id', function(d){
                                if(d.name != " ") {
                                    alleles.push(d.name);
                                    return 'allele'+ (d.cluster-1);
                                }
                                else{
                                    return "empty";
                                }
                            })
                            .attr('stroke-width', 1.5)
                            .attr('fill', function(d){
                                return fillColors[d.cluster-1];
                            });

                    canvas.append('line')
                            .attr('x1', function(){
                                var x = d3.select('#slider_circle').attr('cx');
                                return x;
                            })
                            .attr('x2', function(){
                                var x = d3.select('#slider_circle').attr('cx');
                                return x;
                            })
                            .attr('y1', 30)
                            .attr('y2', 450)
                            .attr('id', 'cutoff_line')
                            .attr('stroke', 'black')
                            .attr('stroke-width', 1)
                            .attr('fill', 'none');

                    node.append("text")
                            .attr("dx", function(d) { return d.children ? -8 : 8; })
                            .attr("dy", 3)
                            .attr('class', 'node_text')
                            .attr("text-anchor", function(d) { return d.children ? "end" : "start"; })
                            .text(function(d) { return d.name; });

                    canvas.append("svg:g")
                            .attr("class", "axis")
                            .attr('transform', 'translate(0, 25)')
                            .call(yAxis);

                    //Initialize the fishplot data
                    var linked_alleleified_data = cut_data(0, alleleified_data, nodes);
                    scope.$parent.linked_alleleified_data = linked_alleleified_data[0];
                    scope.$parent.clustered_alleleified_data = linked_alleleified_data[1];
                    //Input the alleles, ordered by clustering
                    scope.$parent.alleles = alleles;

                }, true);
            }

        });

        //Directive that contains d3 code to render proposed clonal evolution
        //Plot type: Fishbone
        tevApp.directive('figure4Plot', function(){
            return {
                restrict: 'A',
                scope: {
                    data: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el =  element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var fill_colors = ['#a6cee3','#1f78b4','#b2df8a','#33a02c', '#fb9a99', '#e31a1c',
                                    '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99','#b15928'];

                var cluster = d3.layout.cluster()
                        .size([420, 420]);

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();

                    data = updatedData;

                    if(data.length == 0){
                        return;
                    }

                    var fishbone_data = {};
                    fishbone_data.name = data[0].key;
                    fishbone_data.children = [];
                    fishbone_data.cluster = data[0].values[0].cluster

                    for(var i = 0; i < data[0].children.length; i++){
                        var child = data[0].children[i];
                        child = data[child];
                        add_children(child, fishbone_data, data);
                    }

                    var cluster = d3.layout.cluster()
                            .size([375, 375]);

                    var diagonal = d3.svg.diagonal()
                           .projection(function(d) { return [d.y, d.x]; });

                    var svg = d3.select(el).append("svg")
                            .attr("height", height)
                            .attr("width", width)
                            .append("g")
                            .attr("transform", "translate(100,75)");

                    var nodes = cluster.nodes(fishbone_data),
                            links = cluster.links(nodes);

                    var link = svg.selectAll(".link")
                            .data(links)
                            .enter().append("path")
                            .attr("class", "link")
                            .attr("d", diagonal);

                    var node = svg.selectAll(".node")
                            .data(nodes)
                            .enter().append("g")
                            .attr("class", "node")
                            .attr("transform", function (d) {
                                return "translate(" + d.y + "," + d.x + ")";
                            });

                    node.append("circle")
                            .attr("r", 4.5)
                            .attr('fill', function(d, i){
                                return fill_colors[d.cluster-1];
                            });

                    nodes.forEach(function(d){
                        var names = d.name.split('\n');
                        for(var i = 0; i < names.length; i++) {
                            var name = names[i];
                            svg.append('text')
                                    .attr('class', 'node_text')
                                    .attr("transform","translate(" + d.y + "," + d.x + ")")
                                    .attr('dx', function(){
                                        return d.children ? -8 : 8;
                                    })
                                    .attr('dy', function(){
                                        return ((i+1)*10);
                                    })
                                    .style("text-anchor", function(){
                                        return d.children ? "end" : "start";
                                    })
                                    .text(name);
                        }
                    });

                });

            }

        });

        //Directive that contains d3 code to render proposed clonal evolution and alternative allele freq
        //Plot type: Fishplot
        tevApp.directive('figure5Plot', function(){

            return {
                restrict: 'A',
                scope: {
                    data: '='
                },
                link: link
            };

            function link(scope, element){
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var fillColors = ['#a6cee3','#1f78b4','#b2df8a','#33a02c', '#fb9a99', '#e31a1c',
                                    '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99','#b15928'];

                scope.$watch('data', function(updatedData){
                    d3.select(el).select('svg').remove();

                    data = updatedData;

                    if(data.length == 0 || data[0].cluster == undefined){
                        return;
                    }

                    var canvas = d3.select(el).append('svg')
                        .attr('width', width)
                        .attr('height', height);

                    var xAxisLabels = uniqueAxisLabels(data, 'Sample_Barcode');
                    xAxisLabels = xAxisLabels.sort(function(a, b){
                       return a - b;
                    });
                    var num_of_timepoints = xAxisLabels.length;
                    var sample_timepoints = uniqueAxisLabels(data, 'Sample_Barcode');

                    var x_max = Math.max.apply(null, xAxisLabels);

                    var ten_percent_below_zero = 0.1 * x_max;
                    ten_percent_below_zero = parseInt(0 - ten_percent_below_zero);
                    xAxisLabels.unshift(ten_percent_below_zero);

                    var ten_percent_above_max = 0.1 * x_max;
                    ten_percent_above_max = x_max + ten_percent_above_max;
                    xAxisLabels.push(ten_percent_above_max);

                    var xScale = d3.scale.linear().rangeRound([40, width-40], 0.5)
                            .domain(d3.extent(xAxisLabels, function(d){return d;}));
                    var xAxis = d3.svg.axis().scale(xScale).tickValues(sample_timepoints);

                    var yScale = d3.scale.linear().range([40, height-40], 0.5).domain([101, -1]);
                    var yAxis = d3.svg.axis().scale(yScale).orient('left').ticks(0);

                    var nestedData = d3.nest().key(function(d){return d.allele}).entries(data);
                    nestedData = sort_nested_alleles(nestedData);

                    nestedData = add_origin(nestedData, ten_percent_below_zero);

                    //Set up data for comparisons
                    var fishplot_data = [];

                    nestedData.forEach(function(d, i){
                        var allele_data = {};
                        allele_data['allele'] = d.key;
                        allele_data['freqs'] = [];
                        var freqs = d.values;
                        for(var j = 0; j < freqs.length; j++){
                            allele_data['freqs'].push(freqs[j].alt_count);
                        }
                        fishplot_data.push(allele_data);
                    });


                    var sort_array = [];
                    for(var i = 0; i < fishplot_data.length; i++){
                        //Have to rank when ordering, because a subclone that develops later
                        //cannot be parent of clone that derived earlier, even if it has a higher variant allele freq
                        var ranking_adjustment = Math.pow(10, num_of_timepoints);
                        var allele_freqs = fishplot_data[i].freqs;
                        for(var j = 1; j < allele_freqs.length; j++){
                            if(allele_freqs[j] != 0){
                                var rank = ranking_adjustment * allele_freqs[j];
                                sort_array.push({
                                    allele: fishplot_data[i].allele,
                                    rank: rank
                                });
                                break;
                            }
                            ranking_adjustment = ranking_adjustment/10;
                        }
                    }

                    sort_array.sort(function(a, b){
                       return b.rank - a.rank;
                    });

                    //Order data based on rank
                    nestedData = order_by_rank(nestedData, sort_array);



                    var plot_background = {};
                    plot_background.key = "plot";
                    plot_background.values = [];
                    plot_background.values.length = nestedData[0].values.length;
                    plot_background.values.fill({alt_count: 100});
                    plot_background.children = [0];
                    plot_background.groups = {0: 0};

                    //Initialize first parent group
                    nestedData[0].group = 0;
                    nestedData[0].start_point = 50;
                    nestedData[0].parent_index_of_this = "plot";
                    nestedData[0].children = [];
                    nestedData[0].id = 0;

                    //Array to hold alleles that didn't fit on plot
                    var unused = [];


                    for(var i = 1; i < nestedData.length; i++) {
                        var current_allele_data = nestedData[i];
                        var former_allele_data = nestedData[i-1];
                        current_allele_data.group = former_allele_data.group;
                        current_allele_data.start_point = former_allele_data.start_point;
                        current_allele_data.parent_index_of_this = i-1;
                        current_allele_data.children = [];
                        current_allele_data.id = i;


                        //check if it can fit inside its parent
                        var append_as_child = 'yes';
                        var parent_of_child_index = i;
                        for(var j = 1; j < current_allele_data.values.length; j++){
                            if(current_allele_data.values[j].alt_count > former_allele_data.values[j].alt_count) {
                                append_as_child = 'no';
                                break;
                            }
                        }
                        if(append_as_child == 'yes'){
                            former_allele_data.children.push(parent_of_child_index);
                        }
                        else {
                            var done = 0;
                            var children_used = [];
                            while (done != 1){
                                var next_up = former_allele_data.parent_index_of_this;
                                current_allele_data.parent_index_of_this = next_up;
                                if(next_up == "plot"){
                                    children_used.push(former_allele_data.id);
                                    var children = plot_background.children.diff(children_used);
                                    if(children.length == 0) {
                                        var parent_allele = plot_background;
                                    }
                                    else {
                                        var next_group = nestedData[children[0]].group;
                                        //find the last allele that was a child of the new group
                                        for(var l = i; l >= 0; l--){
                                            if(nestedData[l].group == next_group){
                                                parent_allele = nestedData[l];
                                                var new_group_dummy_data = {};
                                                new_group_dummy_data.group = next_group;
                                                new_group_dummy_data.parent_index_of_this = parent_allele.id;
                                                new_group_dummy_data.values = [];
                                                new_group_dummy_data.values.length = parent_allele.values.length;
                                                new_group_dummy_data.values.fill({alt_count: 0});
                                                former_allele_data = new_group_dummy_data;
                                                current_allele_data.parent_index_of_this = parent_allele.id;
                                                break;
                                            }
                                        }
                                    }
                                }
                                else{
                                    var parent_allele = nestedData[next_up];
                                }
                                //Check if it can fit inside parent_allele alongside parent_allele's children
                                //Array that holds total freq of children alleles at timepoint
                                var total_children_freq = [];
                                total_children_freq.length = parent_allele.values.length;
                                total_children_freq.fill(0);
                                for(var j = 0; j < parent_allele.children.length; j++){
                                    var child_allele = parent_allele.children[j];
                                    child_allele = nestedData[child_allele];
                                    for(var k = 0; k < total_children_freq.length; k++){
                                        total_children_freq[k] = child_allele.values[k].alt_count + total_children_freq[k];
                                    }
                                }
                                //Now add the current_allele values to the children total and see if they fit inside of parent
                                var check_if_fits = 1;
                                for(var j = 0; j < total_children_freq.length; j++){
                                    if((total_children_freq[j] + current_allele_data.values[j].alt_count) > parent_allele.values[j].alt_count){
                                        //If this is true at least one, check_if_fits will be 0 and we assign the parent
                                        //as the former allele
                                        former_allele_data = parent_allele;
                                        check_if_fits = 0;
                                    }
                                }
                                if(check_if_fits == 1){
                                    parent_allele.children.push(i);
                                    if(parent_allele.key == "plot"){
                                        current_allele_data.group = (parent_allele.children.length - 1);
                                        plot_background.groups[current_allele_data.group.toString()] = i;
                                        var start_point_space = 100/parent_allele.children.length;
                                        var base_start_point = start_point_space/2;
                                        for(var g = 0; g < i+1; g++){
                                            var start = base_start_point + (nestedData[g].group * start_point_space);
                                            nestedData[g].start_point = start;
                                        }
                                    }
                                    else{
                                        current_allele_data.group = parent_allele.group;
                                        current_allele_data.start_point = parent_allele.start_point;
                                        }
                                    done = 1;
                                }
                                if(check_if_fits == 0 && parent_allele.key == "plot"){
                                    //Doesn't fit... done=1 to move on
                                    unused.push(current_allele_data.key);
                                    done = 1;
                                }
                            }
                        }
                    }

                    scope.$parent.fishbone_data = nestedData;

                    //Find where the lines of the border should be, adjusting so that no line goes below 0
                    //and no line goes above 100
                    for(var i = 0; i < plot_background.children.length; i++) {
                        var parent = nestedData[plot_background.children[i]];
                        var start_point = parent.start_point;
                        nestedData[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100);
                    }

                    adjust_independent_evolution_positions(nestedData, plot_background, num_of_timepoints);

                    nestedData = adjust_children_positioning(nestedData, num_of_timepoints);

                    //load pinches
                    for(var i = 0; i < nestedData.length; i++){
                        var current_allele = nestedData[i];
                        for(var j = 0; j < current_allele.values.length; j++){
                            //Initialize all pinches to false
                            //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                            current_allele.values[j].pinch = false;
                        }
                    }

                    var topLineGen = d3.svg.line()
                            .interpolate('linear')
                            .x(function(d){
                                if(d.pinch == true){
                                    var x_pos = (xScale(d.Sample_Barcode) + xScale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                                return yScale(d.top);
                            });

                    var bottomLineGen = d3.svg.line()
                            .interpolate('linear')
                            .x(function(d, i){
                                if(d.pinch == true){
                                    var x_pos = (xScale(d.Sample_Barcode) + xScale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return xScale(d.Sample_Barcode);
                            })
                            .y(function(d){
                               return yScale(d.bottom);
                            });

                    //Get all of the x-values that make up the top line (will be same as bottom, symmetrical)
                    //Then take area along y-axis between the top and bottom lines
                    var areaBetweenLines = d3.svg.area()
                            .interpolate('linear')
                            .x(topLineGen.x())
                            .y0(topLineGen.y())
                            .y1(bottomLineGen.y());

                    nestedData.forEach(function(d, i){

                        canvas.append('path')
                                .attr('fill', 'none')
                                .attr('stroke-width', 5)
                                .attr("stroke", "transparent")
                                .style("stroke-linejoin", "round")
                                .attr('d', topLineGen(d.values));

                        canvas.append('path')
                                .attr('fill', 'none')
                                .attr("stroke", "transparent")
                                .style("stroke-linejoin", "round")
                                .attr('stroke-width', 8)
                                .attr('d', bottomLineGen(d.values));

                        canvas.append('path')
                                .datum(d.values)
                                .attr('fill', function(d){
                                    return fillColors[d[0].cluster-1];
                                })
                                .attr('opacity', 0.75)
                                .attr('d', areaBetweenLines)
                                .on('mouseover', function(d){
                                    var text = d[0].allele;

                                   canvas.append('text')
                                           .attr('x', d3.mouse(this)[0]+10)
                                           .attr('y', d3.mouse(this)[1]-10)
                                           .attr('id', 'fishplot_text')
                                           .text(text);
                                })
                                .on('mousemove', function(){
                                    d3.select('#fishplot_text')
                                            .attr('x', d3.mouse(this)[0]+10)
                                            .attr('y', d3.mouse(this)[1]-10);
                                })
                                .on('mouseout', function(){
                                   d3.select('#fishplot_text').remove();
                                });
                    });



                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(0," + (height-40) + ")")
                        .call(xAxis);

                    canvas.append("svg:g")
                        .attr("class", "axis")
                        .attr("transform", "translate(" + 4 + "0)")
                        .call(yAxis);

                }, true);
            }

        });

        tevApp.directive('fishplotEditor', function () {
            return {
                restrict: 'A',
                scope: {
                    data: '='
                },
                link: link
            };

            function link(scope, element) {
                var data = scope.data;
                var el = element[0];
                var width = el.clientWidth;
                var height = el.clientHeight;

                var fill_colors = ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c',
                    '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'];

                scope.$watch('data', function (updated_data) {
                    d3.select(el).selectAll('svg').remove();
                    d3.select(el).selectAll('div').remove();
                    data = updated_data;

                    var mini_nested_data = d3.nest().key(function (d) {
                        return d.allele;
                    }).entries(data);

                    mini_nested_data = sort_nested_alleles(mini_nested_data);

                    var canvas_nested_data = d3.nest().key(function (d) {
                        return d.allele;
                    }).entries(data);

                    canvas_nested_data = sort_nested_alleles(canvas_nested_data);

                    var fishplot_data = [];

                    canvas_nested_data.forEach(function(d, i){
                        var allele_data = {};
                        allele_data['allele'] = d.key;
                        allele_data['freqs'] = [];
                        var freqs = d.values;
                        for(var j = 0; j < freqs.length; j++){
                            allele_data['freqs'].push(freqs[j].alt_count);
                        }
                        fishplot_data.push(allele_data);
                    });

                    var x_axis_labels = [];
                    x_axis_labels = uniqueAxisLabels(data, 'Sample_Barcode');
                    x_axis_labels = x_axis_labels.sort(function(a, b){
                       return a - b;
                    });

                    var num_of_timepoints = x_axis_labels.length;
                    var sample_timepoints = uniqueAxisLabels(data, 'Sample_Barcode');
                    sample_timepoints = sample_timepoints.sort(function(a, b){
                       return a - b;
                    });

                    var tick_labels = uniqueAxisLabels(data, 'Sample_Barcode');
                    tick_labels = tick_labels.sort(function(a, b){
                       return a - b;
                    });

                    var x_max = Math.max.apply(null, x_axis_labels);

                    var ten_percent_below_zero = 0.1 * x_max;
                    ten_percent_below_zero = parseInt(0 - ten_percent_below_zero);
                    x_axis_labels.unshift(ten_percent_below_zero);

                    sample_timepoints.unshift(ten_percent_below_zero);

                    var ten_percent_above_max = 0.1 * x_max;
                    ten_percent_above_max = x_max + ten_percent_above_max;
                    x_axis_labels.push(ten_percent_above_max);

                    //Sorting data by what can fit in what
                    var sort_array = [];
                    for(var i = 0; i < fishplot_data.length; i++){
                        //Have to rank when ordering, because a subclone that develops later
                        //cannot be parent of clone that derived earlier, even if it has a higher variant allele freq
                        var ranking_adjustment = Math.pow(10, num_of_timepoints);
                        var allele_freqs = fishplot_data[i].freqs;
                        for(var j = 1; j < allele_freqs.length; j++){
                            if(allele_freqs[j] != 0){
                                var rank = ranking_adjustment * allele_freqs[j];
                                sort_array.push({
                                    allele: fishplot_data[i].allele,
                                    rank: rank
                                });
                                break;
                            }
                            ranking_adjustment = ranking_adjustment/10;
                        }
                    }

                    sort_array.sort(function(a, b){
                       return b.rank - a.rank;
                    });

                    //Order mini fishplot svgs by rank
                    mini_nested_data = order_by_rank(mini_nested_data, sort_array);
                    //Also reorder nested data to be used for canvas to keep it consistent
                    canvas_nested_data = order_by_rank(canvas_nested_data, sort_array);

                    //console.log(canvas_nested_data);

                    //Add children, parent, and index fields
                    for (var i = 0; i < canvas_nested_data.length; i++) {
                        canvas_nested_data[i].children = [];
                        canvas_nested_data[i].parent_index_of_this = 'none';
                        canvas_nested_data[i].index = i;
                        canvas_nested_data[i].ploidy = 2;
                        canvas_nested_data[i].color = fill_colors[canvas_nested_data[i].values[0].cluster-1];

                        mini_nested_data[i].ploidy = 2;
                        mini_nested_data[i].color = fill_colors[mini_nested_data[i].values[0].cluster-1];
                    }

                    //Add input for purity atop the canvas
                    var purity_div_height  = height*0.05;

                    var purity_div_wrapper = d3.select(el).append('div')
                            .style('top', '0px')
                            .style('left', '0px')
                            .style('width', '100%')
                            .style('height', purity_div_height+'px')
                            .style('position', 'relative')
                            .style('float', 'left')
                            .style('padding', '0px')
                            .attr('id', 'purity_div_wrapper');

                    var purity_input_div = purity_div_wrapper.append('div')
                            .style('top', '0px')
                            .style('left', function(){
                                //left of canvas is actually set below
                                var canvas_left = (width * 0.27);
                                var rightmost_of_div = purity_div_wrapper.node().clientWidth;
                                var middle_of_canvas = (canvas_left + rightmost_of_div)/2;
                                return middle_of_canvas + 'px';
                            })
                            .style('width', '73%')
                            .style('height', '100%')
                            .style('float', 'right')
                            .style('position', 'absolute')
                            .attr('id', 'purity_input_div');

                    var purity_input_label = purity_input_div.append('label')
                            .attr('for', 'purity_input')
                            .style('padding-right', '5px')
                            .html(function(){
                                return 'Purity:     '
                            });

                    //push the label and input to the left by the length of the label (this will center it)
                    purity_input_div.style('left', function(){
                        var current_left = parseFloat(purity_input_div.style('left'));
                        return (current_left - purity_input_label.node().clientWidth) + 'px';
                    });

                    var CCF_options = [];

                    var purity_input = purity_input_div.append('input')
                            .attr('id', 'purity_input')
                            .attr('type', 'number')
                            .attr('name', 'Purity: ')
                            .attr('min', '0')
                            .attr('max', '100')
                            .attr('value', '80')
                            .on('change', function(){
                                if(parseInt(purity_input.node().value) > 100){
                                    purity_input.node().value = 100;
                                    if(plot_background.children.length != 0) {
                                        CCF_options = [];
                                        var complete_nested_data = canvas_nested_data.slice();
                                        find_CCFs(plot_background.children, plot_background.children.length, complete_nested_data,
                                                parseInt(purity_input.node().value), plot_background.children.length, [], sample_timepoints, CCF_options);
                                    }
                                }
                                if(parseInt(purity_input.node().value) < 0){
                                    purity_input.node().value = 0;
                                    if(plot_background.children.length != 0) {
                                        CCF_options = [];
                                        complete_nested_data = canvas_nested_data.slice();
                                        find_CCFs(plot_background.children, plot_background.children.length, complete_nested_data,
                                                parseInt(purity_input.node().value), plot_background.children.length, [], sample_timepoints, CCF_options);
                                    }
                                }
                                else {
                                    if(plot_background.children.length != 0) {
                                        CCF_options = [];
                                        complete_nested_data = canvas_nested_data.slice();
                                        find_CCFs(plot_background.children, plot_background.children.length, complete_nested_data,
                                                parseInt(purity_input.node().value), plot_background.children.length, [], sample_timepoints, CCF_options);
                                    }
                                }
                            });

                    //Div wrapper for dragable div
                    var dragable_div_wrapper = d3.select(el).append('div')
                            .style('top', '0px')
                            .style('left', '0px')
                            .style('width', '25%')
                            .style('height', height + 'px')
                            .style('float', 'left')
                            .style('overflow', 'visible')
                            .style('padding', '0px')
                            .style('position', 'relative')
                            .attr('id', 'dragable_div_wrapper');

                    var new_height = d3.select('#dragable_div_wrapper').node().offsetHeight;
                    new_height = new_height + purity_div_height;
                    d3.select(el).style('height', new_height + 'px');


                    //Div to hold container svg
                    var container = dragable_div_wrapper.append('div')
                            .style('top', '0px')
                            .style('left', '0px')
                            .style('width', '100%')
                            .style('height', height + 'px')
                            .style('float', 'left')
                            .style('overflow-y', 'scroll')
                            .style('overflow-x', 'hidden')
                            .style('padding', '2px')
                            .style('border', '1px solid black')
                            .style('position', 'absolute')
                            .attr('id', 'container_div')
                            .on('scroll', function () {
                                d3.selectAll('#dragable_div').remove();
                            });

                    //Div to hold canvas svg
                    var canvas = d3.select(el).append('div')
                            .style('top', purity_div_height + 'px')
                            .style('left', width * 0.27 + 'px')
                            .style('width', '73%')
                            .style('height', height + 'px')
                            .style('border', '1px solid black')
                            .style('padding', '2px')
                            .style('float', 'right')
                            .attr('id', 'canvas_div');

                    //Will contain the index in the nested data of what fish the user is currently moused over
                    var moused_over;

                    //Canvas svg where fishplot will be plotted
                    var canvas_svg = canvas.append('svg')
                            .attr('width', '100%')
                            .attr('height', '100%')
                            .attr('id', 'canvas_svg')
                            .attr('index', 'canvas_svg')
                            .on('mouseover', function () {
                                if (dragging) {
                                    moused_over = d3.select(this).attr('index');
                                }
                            });

                    var canvas_range_max_x = d3.select('#canvas_svg').node().clientWidth;
                    var canvas_x_scale = d3.scale.linear()
                            .rangeRound([canvas_range_max_x*0.01, canvas_range_max_x*0.99], 0.25)
                            .domain(d3.extent(x_axis_labels, function(d){ return d;}));
                    var canvas_x_axis = d3.svg.axis().scale(canvas_x_scale).tickValues(tick_labels);

                    var canvas_range_max_y = d3.select('#canvas_svg').node().clientHeight * 0.95;
                    var canvas_y_scale = d3.scale.linear().range([0, canvas_range_max_y]).domain([101, -1]);

                    function y_scale_domain_max(nested_data) {
                        var max_array = [];
                        for (var i = 0; i < nested_data.length; i++) {
                            var allele_alt_counts = [];
                            var timepoint_data = nested_data[i].values;
                            for (var j = 0; j < timepoint_data.length; j++) {
                                allele_alt_counts[j] = timepoint_data[j].alt_count;
                            }
                            max_array[i] = Math.max.apply(Math, allele_alt_counts);
                        }
                        return Math.max.apply(Math, max_array);
                    }

                    var y_max = y_scale_domain_max(mini_nested_data);

                    mini_nested_data = add_origin(mini_nested_data, ten_percent_below_zero);
                    canvas_nested_data = add_origin(canvas_nested_data, ten_percent_below_zero);


                    function generate_mini_fishplot_top_and_bottom(nested_data, y_max) {
                        var mid_point = y_max / 2;
                        for (var i = 0; i < nested_data.length; i++) {
                            var allele_freqs = nested_data[i].values;
                            for (var j = 0; j < allele_freqs.length; j++) {
                                var split = allele_freqs[j].alt_count / 2;
                                allele_freqs[j].top = mid_point + split;
                                allele_freqs[j].bottom = mid_point - split;
                            }
                        }
                    }

                    generate_mini_fishplot_top_and_bottom(mini_nested_data, y_max);
                    var mini_x_range_max = d3.select('#container_div').node().clientWidth;

                    var mini_x_scale = d3.scale.linear().rangeRound([0, mini_x_range_max], 0.5)
                            .domain(d3.extent(x_axis_labels, function(d){return d;}));
                    var mini_y_scale = d3.scale.linear().range([20, 140]).domain([y_max + 1, -1]);

                    var top_line_gen = d3.svg.line()
                            .interpolate('linear')
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (mini_x_scale(d.Sample_Barcode) + mini_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return mini_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return mini_y_scale(d.top);
                            });

                    var canvas_top_line_gen = d3.svg.line()
                            .interpolate('linear')
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (canvas_x_scale(d.Sample_Barcode) + canvas_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return canvas_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return canvas_y_scale(d.top);
                            });

                    var bottom_line_gen = d3.svg.line()
                            .interpolate('linear')
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (mini_x_scale(d.Sample_Barcode) + mini_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return mini_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return mini_y_scale(d.bottom);
                            });

                    var canvas_bottom_line_gen = d3.svg.line()
                            .interpolate('linear')
                            .x(function (d) {
                                if (d.pinch == true) {
                                    var x_pos = (canvas_x_scale(d.Sample_Barcode) + canvas_x_scale(d.next_timepoint))/2;
                                    return x_pos;
                                }
                                return canvas_x_scale(d.Sample_Barcode);
                            })
                            .y(function (d) {
                                return canvas_y_scale(d.bottom);
                            });

                    var area_between_lines = d3.svg.area()
                            .interpolate('linear')
                            .x(top_line_gen.x())
                            .y0(top_line_gen.y())
                            .y1(bottom_line_gen.y());

                    var canvas_area_between_lines = d3.svg.area()
                            .interpolate('linear')
                            .x(canvas_top_line_gen.x())
                            .y0(canvas_top_line_gen.y())
                            .y1(canvas_bottom_line_gen.y());

                    var container_div_height = 600;
                    var top;
                    var mini_fishplot_container_height = 160;
                    var mini_fishplots = container.selectAll('alleles')
                            .data(mini_nested_data)
                            .enter()
                            .append('div')
                            .style('top', function (d, i) {
                                //150 will be height of divs holding mini fishplots
                                if (i == 0) {
                                    top = 10;
                                }
                                else {
                                    top = top + mini_fishplot_container_height + 10;
                                    if (top + mini_fishplot_container_height > container_div_height) {
                                        container_div_height = top + mini_fishplot_container_height;
                                        d3.select('#container_div').attr('height', container_div_height)
                                    }
                                }
                                return top + 'px';
                            })
                            .style('left', '0px')
                            .style('width', mini_x_range_max + 'px')
                            .style('height', mini_fishplot_container_height + 'px')
                            .style('border', '0.5px solid black')
                            .style('position', 'absolute')
                            .style('cursor', 'pointer')
                            .style('background', '#FFF')
                            .style('opacity', 1)
                            .attr('index', function (d, i) {
                                return i;
                            })
                            .attr('class', 'mini_fishplot_divs')
                            .attr('z-index', 5)
                            .attr('id', function (d, i) {
                                return 'mini_fishplot_div' + i;
                            });


                    var plot_background = {};
                    plot_background.key = "plot";
                    plot_background.values = [];
                    plot_background.values.length = canvas_nested_data[0].values.length;
                    //Depends on what the domain is for the canvas... right now the max is 100 total for the fishplot(s)
                    plot_background.values.fill({alt_count: 100});
                    plot_background.children = [];
                    plot_background.groups = {0: 0};
                    var groups = [];


                    var old_x_pos = 0;
                    var new_x_pos = 0;
                    var old_y_pos = 0;
                    var new_y_pos = 0;
                    var top_in_container, left_in_container;


                    //Lay down an svg in the divs
                    var svgs = mini_fishplots.append('svg')
                            .attr('width', '100%')
                            .attr('height', '100%')
                            .attr('class', 'mini_fishplots')
                            .attr('opacity', 1)
                            .attr('id', function (d, i) {
                                return 'mini_fishplot_svg' + i;
                            });

                    var dragging = false;

                    //Keep track of fishplots on canvas & order they're in
                    //In case new plot added to canvas background and need to move/shift everything
                    var fishplot_svgs = [];

                    //Retains un-trimmed copy of updated values
                    function update_canvas_nested_data(canvas_nested_data, fishplot_svgs) {
                        for (var i = 0; i < fishplot_svgs.length; i++) {
                            var current_index = fishplot_svgs[i];
                            canvas_nested_data[current_index] = JSON.parse(JSON.stringify(canvas_nested_data[current_index]));
                        }
                    }


                    //Check if it can fit within parent
                    function can_fit(nested_data, parent, current_data, num_of_timepoints) {
                        //Add 1 to include the origin
                        num_of_timepoints = num_of_timepoints + 1;
                        var children = parent.children;
                        for (var i = 0; i < num_of_timepoints; i++) {
                            var freq_at_timepoint = current_data.values[i].alt_count;
                            for (var j = 0; j < children.length; j++) {
                                freq_at_timepoint = freq_at_timepoint + nested_data[children[j]].values[i].alt_count;
                            }
                            if (freq_at_timepoint > parent.values[i].alt_count) {
                                return false;
                            }
                        }
                        return true;
                    }

                    //Make nested data in correct order using only those plotted
                    //This makes the data being plotted compatible with the adjust children positioning function
                    function reconstruct_data(nested_data, fishplot_svgs){
                        var new_data = [];
                       for(var i = 0; i < fishplot_svgs.length; i++){
                           var current_data = nested_data[fishplot_svgs[i]];
                           var new_children = [];
                           if(current_data.parent_index_of_this != 'plot'){
                               current_data.parent_index_of_this = fishplot_svgs.indexOf(current_data.parent_index_of_this);
                           }
                           for(var j = 0; j < current_data.children.length; j++){
                               new_children.push(fishplot_svgs.indexOf(parseInt(current_data.children[j])));
                           }
                           current_data.children = new_children;
                           new_data.push(current_data);
                       }
                        return new_data;
                    }

                    //Indices of used fishplots where the one being dragged wont be able to fit
                    var cant_fit = [];

                    //Make all mini fishplots opacity 1 on mouse-up of primary div
                    //Precaution for if user drags mouse too fast
                    d3.select(el).on('mousemove', function () {
                                if (dragging == true) {
                                    var dragable_div = d3.select('#dragable_div');

                                    new_x_pos = d3.event.x;
                                    var x_difference = new_x_pos - old_x_pos;

                                    new_y_pos = d3.event.y;
                                    var y_difference = new_y_pos - old_y_pos;

                                    old_x_pos = new_x_pos;
                                    old_y_pos = new_y_pos;

                                    dragable_div.style('left', function () {
                                                return parseInt(dragable_div.style('left')) + x_difference + 'px';
                                            })
                                            .style('top', function () {
                                                return parseInt(dragable_div.style('top')) + y_difference + 'px';
                                            });
                                    dragable_div.style('pointer-events', 'none').style('cursor', 'pointer');

                                }
                                else {
                                    return;
                                }
                            })
                            .on('mouseup', function () {
                                old_x_pos = 0;
                                old_y_pos = 0;
                                dragging = false;
                                var svg_index = d3.select('#dragable_div').attr('index');

                                for(var i = 0; i < cant_fit.length; i++){
                                    d3.select('#big_fish'+cant_fit[i])
                                            .attr('fill', canvas_nested_data[cant_fit[i]].color);
                                }

                                cant_fit = [];

                                var mini_fishplot = d3.select('#dragable_div');

                                //give leeway of 2px for minimum left position of mini fishplot
                                var minimum_left_pos = parseInt(d3.select('#canvas_div').style('left')) - 2;
                                minimum_left_pos = Math.floor(minimum_left_pos);
                                var mini_fishplot_left = parseInt(mini_fishplot.style('left'));

                                //If the mini fishplot is dragged over the canvas background
                                //center the starting y value at the middle of the mini fishplot div
                                var half_height = mini_fishplot.node().clientHeight / 2;
                                var mini_fishplot_top = mini_fishplot.style('top');
                                var start = parseInt(mini_fishplot_top) + half_height;

                                start = canvas_y_scale.invert(start);

                                if ((mini_fishplot_left + left_adjustment) > minimum_left_pos) {
                                    d3.select(el).style('cursor', 'default');

                                    if (moused_over == 'canvas_svg') {

                                        var nested_data = canvas_nested_data.slice(0);

                                        var data_index = mini_fishplot.attr('index');

                                        var data = nested_data[data_index];

                                        var fit = can_fit(nested_data, plot_background, data, num_of_timepoints);

                                        //If it can fit, plot it and re-adjust all other independent clonal evolutions
                                        if (fit) {

                                            svg_index = mini_fishplot.attr('index');
                                            d3.select('#fishplot_area'+ svg_index).attr('opacity', 1);

                                            d3.select('#mini_fishplot_div' + svg_index).style('opacity', 0.35);
                                            d3.select('#dragable_div').remove();

                                            data.start_point = start;
                                            data.group = groups.length;
                                            data.parent_index_of_this = 'plot';

                                            //Re-do top and bottom based on start position from mousedown
                                            for (var i = 0; i < num_of_timepoints; i++) {
                                                data.values[i].top = data.start_point + (data.values[i].alt_count / 2);
                                                data.values[i].bottom = data.start_point - (data.values[i].alt_count / 2);
                                            }

                                            groups.push(data.group);
                                            if (plot_background.groups[data.group.toString()] == undefined) {
                                                plot_background.groups[data.group.toString()] = data_index;
                                            }

                                            plot_background.children.push(parseInt(data_index));

                                            plot_background.children.sort(function(a, b){
                                               return nested_data[a].start_point - nested_data[b].start_point;
                                            });

                                            fishplot_svgs.push(parseInt(data_index));

                                            canvas_nested_data[data_index] = JSON.parse(JSON.stringify(data));

                                            //Create shallow copy for values of each fishplot used
                                            //Prevents find_origin function from permanently trimming allele values
                                            update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                            for (var i = 0; i < plot_background.children.length; i++) {
                                                var parent = nested_data[plot_background.children[i]];
                                                var start_point = parent.start_point;
                                                nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100);
                                            }

                                            adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints);

                                            //Retain a complete nested data, that doesnt affect canvas_nested_data, to be used when
                                            //determining CCF solutions
                                            var complete_nested_data = nested_data.slice();

                                            nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                            //collision detection for children after adjusting the independent evolution positions
                                            nested_data = adjust_children_positioning(nested_data, num_of_timepoints);

                                            //load pinches
                                            //Have to use fishplot svgs to select specific indices of nested_data
                                            //Otherwise, we prematurely clip off the origin of fishplots starting after
                                            //The first timepoint (i.e. Pretreatment in example file)
                                            for (var i = 0; i < fishplot_svgs.length; i++) {
                                                var current_allele = nested_data[i];
                                                for (var j = 0; j < current_allele.values.length; j++) {
                                                    //Initialize all pinches to false
                                                    //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                                    current_allele.values[j].pinch = false;
                                                }
                                                current_allele.values = find_origin(current_allele);
                                            }

                                            d3.selectAll('.big_fish').remove();


                                            for (var i = 0; i < nested_data.length; i++) {
                                                var current_data = nested_data[i];

                                                canvas_svg.append('path')
                                                        .attr('fill', 'none')
                                                        .attr('stroke-width', 5)
                                                        .attr("stroke", "transparent")
                                                        .attr('class', 'big_fish')
                                                        .style("stroke-linejoin", "round")
                                                        .attr('d', function () {
                                                            return canvas_top_line_gen(current_data.values);
                                                        });

                                                canvas_svg.append('path')
                                                        .attr('fill', 'none')
                                                        .attr("stroke", "transparent")
                                                        .style("stroke-linejoin", "round")
                                                        .attr('class', 'big_fish')
                                                        .attr('stroke-width', 8)
                                                        .attr('d', function () {
                                                            return canvas_bottom_line_gen(current_data.values);
                                                        });

                                                canvas_svg.append('path')
                                                        .datum(current_data.values)
                                                        .attr('fill', fill_colors[current_data.values[0].cluster - 1])
                                                        .attr('opacity', 1)
                                                        .attr('class', 'big_fish')
                                                        .attr('d', canvas_area_between_lines)
                                                        .attr('index', current_data.index)
                                                        .attr('id', 'big_fish'+current_data.index)
                                                        .on('mouseenter', function (d) {
                                                            d3.select(this).attr('opacity', 0.75);
                                                            moused_over = parseInt(d3.select(this).attr('index'));
                                                        })
                                                        .on('mouseleave', function () {
                                                            d3.select(this).attr('opacity', 1);
                                                        });
                                            }

                                            CCF_options = [];

                                            find_CCFs(plot_background.children, plot_background.children.length, complete_nested_data,
                                                    parseInt(purity_input.node().value), plot_background.children.length, [], sample_timepoints, CCF_options);

                                            console.log(CCF_options);
                                        }
                                        else {
                                            setTimeout(function() {
                                                var index = d3.select('#dragable_div').attr('index');
                                                d3.select('#fishplot_area'+index).attr('opacity', 1);
                                            }, 500);
                                            d3.select('#dragable_div').transition()
                                                    .duration(500)
                                                    .style('top', top_in_container)
                                                    .style('left', left_in_container)
                                                    .remove();
                                        }
                                    }
                                    else {
                                        nested_data = canvas_nested_data.slice(0);

                                        var parent_of_this = moused_over;

                                        parent = nested_data[parent_of_this];

                                        data_index = mini_fishplot.attr('index');

                                        data = nested_data[data_index];

                                        data.start_point = start;
                                        data.group = parent.group;
                                        data.values[0].start_point = start;
                                        data.parent_index_of_this = parseInt(parent_of_this);

                                        //If it can git, make it a child of the current fishplot
                                        //And re-adjust everything that has already been plotted
                                        fit = can_fit(nested_data, parent, data, num_of_timepoints);

                                        if (fit) {

                                            svg_index = mini_fishplot.attr('index');
                                            d3.select('#fishplot_area'+ svg_index).attr('opacity', 1);

                                            d3.select('#mini_fishplot_div' + svg_index).style('opacity', 0.35);
                                            d3.select('#dragable_div').remove();

                                            //Add the current fish as a subclone
                                            parent.children.push(parseInt(data.index));
                                            parent.children.sort(function(a, b){
                                                console.log(canvas_nested_data[a], canvas_nested_data[b]);
                                               return canvas_nested_data[a].values[0].start_point
                                                       - canvas_nested_data[b].values[0].start_point;
                                            });
                                            fishplot_svgs.push(parseInt(data_index));

                                            //Re-do top and bottom based on start position of parent
                                            for (var i = 0; i < num_of_timepoints; i++) {
                                                data.values[i].top = data.start_point + (data.values[i].alt_count / 2);
                                                data.values[i].bottom = data.start_point - (data.values[i].alt_count / 2);
                                            }

                                            canvas_nested_data[data_index] = JSON.parse(JSON.stringify(data));

                                            //Create shallow copy for values of each fishplot used
                                            //Prevents find_origin function from permanently trimming allele values
                                            update_canvas_nested_data(canvas_nested_data, fishplot_svgs);

                                            for (var i = 0; i < plot_background.children.length; i++) {
                                                parent = nested_data[plot_background.children[i]];
                                                start_point = parent.start_point;
                                                nested_data[plot_background.children[i]] = parent_border_collision_detection(parent, start_point, 0, 100);
                                            }

                                            adjust_independent_evolution_positions(nested_data, plot_background, num_of_timepoints);

                                            nested_data = reconstruct_data(nested_data, fishplot_svgs);

                                            //collision detection for children after adjusting the independent evolution positions
                                            nested_data = adjust_children_positioning(nested_data, num_of_timepoints);


                                            for (var i = 0; i < nested_data.length; i++) {
                                                current_allele = nested_data[i];
                                                for (var j = 0; j < current_allele.values.length; j++) {
                                                    //Initialize all pinches to false
                                                    //Pinch will only be true if the "origin" timepoint is not the subclones actual origin
                                                    current_allele.values[j].pinch = false;
                                                }
                                                current_allele.values = find_origin(current_allele);
                                            }


                                            d3.selectAll('.big_fish').remove();

                                            for (var i = 0; i < nested_data.length; i++) {
                                                current_data = nested_data[i];

                                                canvas_svg.append('path')
                                                        .attr('fill', 'none')
                                                        .attr('stroke-width', 5)
                                                        .attr("stroke", "transparent")
                                                        .attr('class', 'big_fish')
                                                        .style("stroke-linejoin", "round")
                                                        .attr('d', function () {
                                                            return canvas_top_line_gen(current_data.values);
                                                        });

                                                canvas_svg.append('path')
                                                        .attr('fill', 'none')
                                                        .attr("stroke", "transparent")
                                                        .style("stroke-linejoin", "round")
                                                        .attr('class', 'big_fish')
                                                        .attr('stroke-width', 8)
                                                        .attr('d', function () {
                                                            return canvas_bottom_line_gen(current_data.values);
                                                        });

                                                canvas_svg.append('path')
                                                        .datum(current_data.values)
                                                        .attr('fill', fill_colors[current_data.values[0].cluster - 1])
                                                        .attr('opacity', 1)
                                                        .attr('class', 'big_fish')
                                                        .attr('d', canvas_area_between_lines)
                                                        .attr('index', current_data.index)
                                                        .attr('id', 'big_fish'+current_data.index)
                                                        .on('mouseenter', function (d) {
                                                            d3.select(this).attr('opacity', 0.75);
                                                            moused_over = parseInt(d3.select(this).attr('index'));
                                                        })
                                                        .on('mouseleave', function () {
                                                            d3.select(this).attr('opacity', 1);
                                                        });
                                            }
                                        }
                                        else {
                                            setTimeout(function() {
                                                var index = d3.select('#dragable_div').attr('index');
                                                d3.select('#fishplot_area'+index).attr('opacity', 1);
                                            }, 500);

                                            d3.select('#dragable_div').transition()
                                                    .duration(500)
                                                    .style('top', top_in_container)
                                                    .style('left', left_in_container)
                                                    .remove();
                                        }
                                    }
                                }
                                else {
                                    setTimeout(function() {
                                                var index = d3.select('#dragable_div').attr('index');
                                                d3.select('#fishplot_area'+index).attr('opacity', 1);
                                            }, 500);

                                    d3.select('#dragable_div').transition()
                                            .duration(500)
                                            .style('top', top_in_container)
                                            .style('left', left_in_container)
                                            .remove();

                                }
                                return;
                            });

                    //dirty fish to preventing blank mini fishplots
                    d3.select('body')
                            .on('mouseup', function () {
                                for (var i = 0; i < cant_fit.length; i++) {
                                    d3.select('#big_fish' + cant_fit[i])
                                            .attr('fill', canvas_nested_data[cant_fit[i]].color);
                                }
                                setTimeout(function () {
                                    d3.select('#dragable_div').remove();
                                    d3.selectAll('.fishplot_areas').attr('opacity', 1);
                                }, 500);
                            });

                    //Cog wheel glyph icon
                    svgs.append('svg:image')
                            .attr('x', mini_x_range_max*0.01)
                            .attr('y', mini_fishplot_container_height*0.85)
                            .attr('width',  mini_fishplot_container_height*0.15)
                            .attr('height', mini_fishplot_container_height*0.15)
                            .attr('id', 'cog_wheel')
                            .attr('xlink:href', 'https://cdn1.iconfinder.com/data/icons/trycons/32/settings-512.png')
                            .on('click', function(d, i){
                                //return if the fishplot of this allele has already been plotted
                                if(fishplot_svgs.indexOf(i) != -1){
                                    return;
                                }
                                d3.select('#dragable_div').remove();
                                var ploidy_num = d3.select('#ploidy_text'+i).node().innerHTML.split(' ')[1];
                                var cn_num = d3.select('#cn_text'+i).node().innerHTML.split(' ')[1];

                                d3.select('#cn_input').attr('value', cn_num).attr('fishplot_index', i);
                                d3.select('#ploidy_input').attr('value', ploidy_num).attr('fishplot_index', i);

                                $("#exampleModal").modal('show');

                            });

                    //Mini fishplot divs in scroll container
                    svgs.append('path')
                            .attr('fill', 'none')
                            .attr('stroke-width', 5)
                            .attr("stroke", "transparent")
                            .style("stroke-linejoin", "round")
                            .attr('d', function (d) {
                                return top_line_gen(d.values);
                            });

                    svgs.append('path')
                            .attr('fill', 'none')
                            .attr("stroke", "transparent")
                            .style("stroke-linejoin", "round")
                            .attr('stroke-width', 8)
                            .attr('d', function (d) {
                                return bottom_line_gen(d.values);
                            });

                    //difference between edge of mini fishplot div, and where fishplot fill starts
                    var left_adjustment = 0;


                    svgs.append('path')
                            .attr('fill', function (d) {
                                return d.color;
                            })
                            .datum(function (d) {
                                return d.values;
                            })
                            .attr('opacity', 1)
                            .attr('d', area_between_lines)
                            .attr('id', function(d, i){
                                return 'fishplot_area'+i
                            })
                            .attr('class', 'fishplot_areas')
                            .on('mousedown', function (d, i) {
                                d3.selectAll('.mini_fishplots').attr('opacity', 1);
                                var div_id = '#mini_fishplot_div' + i;
                                var svg_id = '#mini_fishplot_svg' + i;
                                var mini_fishplot = d3.select(svg_id);

                                //get svg info for clone
                                var dragable_div_content = mini_fishplot.node().outerHTML;

                                //Calculate top based on the top of the mini fishplot div and how far user scrolled
                                top_in_container = parseInt(d3.select(div_id).style('top')) - d3.select('#container_div').node().scrollTop;
                                top_in_container = top_in_container + 'px';
                                left_in_container = d3.select(div_id).style('left');
                                var width = d3.select(div_id).style('width');
                                var height = d3.select(div_id).style('height');

                                //remove any clones that are already layed down, if any at all
                                //Some may be left behind if user moves mouse rapdily
                                d3.selectAll('#dragable_div').remove();

                                if(fishplot_svgs.indexOf(i) != -1){
                                    return;
                                }

                                for(var j=0; j<fishplot_svgs.length; j++) {
                                    var plotted_data = canvas_nested_data[fishplot_svgs[j]];
                                    var data = canvas_nested_data[i];
                                    var fit = can_fit(canvas_nested_data, plotted_data, data, num_of_timepoints);
                                    if(!fit){
                                        cant_fit.push(fishplot_svgs[j]);
                                        d3.select('#big_fish'+ plotted_data.index)
                                                .attr('fill', '#d3d3d3');
                                    }
                                }

                                var dragable_div = dragable_div_wrapper.append('div')
                                        .style('top', top_in_container)
                                        .style('left', left_in_container)
                                        .style('width', width)
                                        .style('height', height)
                                        .style('position', 'absolute')
                                        .style('cursor', 'pointer')
                                        .html(dragable_div_content)
                                        .attr('index', i)
                                        .attr('z-index', 10)
                                        .attr('id', 'dragable_div');

                                d3.select('#dragable_div').selectAll('.info_text').remove();
                                d3.select('#dragable_div').selectAll('.info_lines').remove();

                                //remove cog wheel
                                d3.select('#dragable_div').select('#cog_wheel').remove();

                                var bounding = d3.select('#fishplot_area' + i).node().getBoundingClientRect();
                                left_adjustment = bounding.left - parseInt(left_in_container);

                                old_x_pos = d3.event.x;
                                old_y_pos = d3.event.y;

                                dragging = true;

                                d3.select('#fishplot_area'+i).attr('opacity', 0);

                                d3.select('#dragable_div').style('pointer-events', 'none')
                                        //give mouseup remove functionality
                                        .on('mouseup', function(){
                                           d3.select(this).remove();
                                        });
                                d3.select(el).style('cursor', 'pointer');

                            });


                    //Ploidy and CN table configuration
                    svgs.append('text')
                            .attr('x', function(d, i){
                                var center = d3.select('#mini_fishplot_svg'+i).node().clientWidth/2;
                                return center + 'px';
                            })
                            .attr('y', '155px')//if it were a formula this would be 15.5/16 using container height = 160
                            .text(function(d){
                               return d.key;
                            })
                            .attr('font-size', '15px')
                            .attr('text-anchor', 'middle')
                            .attr('class', 'noselect info_text');

                    svgs.append('text')
                            .attr('x', function(d, i){
                                var center = d3.select('#mini_fishplot_svg'+i).node().clientWidth/2;
                                center = center * 0.5; //cut in half, then cut in half again
                                return center + 'px';
                            })
                            .attr('y', '15px')
                            .text(function(){
                                return 'CN: ' + 2; //Will put variable for CN eventually
                            })
                            .attr('font-size', '15px')
                            .attr('text-anchor', 'middle')
                            .attr('id', function(d, i){
                                return 'cn_text'+i;
                            })
                            .attr('class', 'noselect info_text');

                    svgs.append('text')
                            .attr('font-size', '15px')
                            .attr('text-anchor', 'middle')
                            .attr('id', function(d, i){
                                return 'ploidy_text'+i;
                            })
                            .attr('class', 'noselect info_text')
                            .attr('x', function(d, i){
                                var center = d3.select('#mini_fishplot_svg'+i).node().clientWidth/2;
                                center = center * 1.5; //cut in half, then cut in half again
                                return center + 'px';
                            })
                            .attr('y', '15px')
                            .text(function(){
                                return 'Ploidy: ' + 2; //Will put variable for Ploidy eventually
                            });

                    //update the ploidy after the user saves the changes
                    d3.select('#save_button')
                            .on('click', function(){
                                var index =  d3.select('#ploidy_input').attr('fishplot_index');
                                var value = d3.select('#ploidy_input').node().valueAsNumber;
                                canvas_nested_data[index].ploidy = value;
                            });

                    svgs.append('line')
                            .attr('x1', '0px')
                            .attr('x2', function(d, i){
                                return d3.select('#mini_fishplot_svg'+i).node().clientWidth;
                            })
                            .attr('y1', '20px')
                            .attr('y2', '20px')
                            .attr('fill', 'none')
                            .attr('stroke', '#000000')
                            .attr('class', 'info_lines');

                    svgs.append('line')
                            .attr('x1', function(d, i){
                                return d3.select('#mini_fishplot_svg'+i).node().clientWidth/2;
                            })
                            .attr('x2', function(d, i){
                                return d3.select('#mini_fishplot_svg'+i).node().clientWidth/2;
                            })
                            .attr('y1', '0px')
                            .attr('y2', '20px')
                            .attr('stroke', '#000000')
                            .attr('class', 'info_lines');

                    canvas_svg.append("svg:g")
                        .attr("class", "axis noselect")
                        .attr("transform", "translate(0," + canvas_range_max_y + ")")
                        .call(canvas_x_axis);


                });
            }
        });

    })();

    function update_clonal_information_text(){
        var fishplot_index = d3.select('#cn_input').attr('fishplot_index');

        d3.select('#cn_text'+fishplot_index)
                .text(function(){
                    return 'CN: ' + d3.select('#cn_input').node().valueAsNumber;
                });

        d3.select('#ploidy_text'+fishplot_index)
                .text(function(){
                   return 'Ploidy: ' + d3.select('#ploidy_input').node().valueAsNumber;
                });
    }

</script>
<body ng-controller = "tevDataController" style="margin-left: 2.5%; margin-right: 2.5%; margin-bottom: 2.5%">
<!--
Dont need to provide alleles to figure 1 because all that's changing is the colors
-->

<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">TEV</a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
                <li class="active"><a href="">Summary<span class="sr-only">(current)</span></a></li>
                <li><a href="#figure6">Fishplot Editor</a></li>
            </ul>
        </div>
    </div>
</nav>

<div class="row">
<div id="figure1" figure1-plot data="clustered_alleleified_data" class="col-md-5"
     style="height: 650px; float:left;">
</div>


<div id="figure2" figure2-plot data="[clustered_alleleified_data, alleles]" class="col-md-5"
     style="height: 650px; float: right;">
</div>
</div>

<div class="row">
<div id="figure3" figure3-plot data="[dendro_data, dendro_y_data, alleleified_data]" class="col-md-5"
     style="height: 600px; float: left;">
</div>


<div id="figure4" figure4-plot data="fishbone_data" class="col-md-5"
     style="height: 600px; float: right;">
</div>
</div>

<!--
<div class="row">
    <div class="col-lg-12 col-md-12 col-sm-12">
        <div id="figure5" figure5-plot data="linked_alleleified_data" style="width: 100%; height: 600px; float: left;">
        </div>
    </div>
</div>
-->

<div class="row">
    <div class="col-lg-12 col-md-12 col-sm-12">
        <div id="figure6" fishplot-editor data="alleleified_data" style="width: 100%; height: 600px; float: left;
overflow: hidden;">
        </div>

        <div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"
             aria-hidden="true">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                        <h4 class="modal-title" id="exampleModalLabel">Edit Clonal Information</h4>
                    </div>
                    <div class="modal-body">
                        <form>

                                    <label for="cn_input" class="form-control-label">Copy Number (CN):</label>
                                    <input class="form-control" id="cn_input" type="number" min="0" max="100"/>




                                    <label for="ploidy_input" class="form-control-label">Ploidy:</label>
                                    <input class="form-control" id="ploidy_input" type="number" min="0" max="100"/>


                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-dismiss="modal" id="save_button"
                                onclick="update_clonal_information_text()">Save</button>
                    </div>
                </div>
            </div>
        </div>


    </div>
</div>

</body>
</html>